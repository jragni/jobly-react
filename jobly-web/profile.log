SCRIPT  /usr/local/Cellar/neovim/0.5.0/share/nvim/runtime/ftplugin/javascript.vim
Sourced 1 time
Total time:   0.000709
 Self time:   0.000709

count  total (s)   self (s)
                            " Vim filetype plugin file
                            " Language:     Javascript
                            " Maintainer:   Doug Kearns <dougkearns@gmail.com>
                            " Last Change:  2020 Jun 23
                            " Contributor:  Romain Lafourcade <romainlafourcade@gmail.com>
                            
    1              0.000012 if exists("b:did_ftplugin")
                                finish
    1              0.000001 endif
    1              0.000004 let b:did_ftplugin = 1
                            
    1              0.000014 let s:cpo_save = &cpo
    1              0.000009 set cpo-=C
                            
                            " Set 'formatoptions' to break comment lines but not other lines,
                            " and insert the comment leader when hitting <CR> or using "o".
    1              0.000007 setlocal formatoptions-=t formatoptions+=croql
                            
                            " Set completion with CTRL-X CTRL-O to autoloaded function.
    1              0.000004 if exists('&ofu')
    1              0.000003     setlocal omnifunc=javascriptcomplete#CompleteJS
    1              0.000001 endif
                            
                            " Set 'comments' to format dashed lists in comments.
    1              0.000005 setlocal comments=sO:*\ -,mO:*\ \ ,exO:*/,s1:/*,mb:*,ex:*/,://
                            
    1              0.000003 setlocal commentstring=//%s
                            
                            " Change the :browse e filter to primarily show JavaScript-related files.
    1              0.000007 if (has("gui_win32") || has("gui_gtk")) && !exists("b:browsefilter")
                                let b:browsefilter =
                                            \ "JavaScript Files (*.js)\t*.js\n"
                                            \ .. "JSX Files (*.jsx)\t*.jsx\n"
                                            \ .. "JavaScript Modules (*.es, *.es6, *.cjs, *.mjs, *.jsm)\t*.es;*.es6;*.cjs;*.mjs;*.jsm\n"
                                            \ .. "Vue Templates (*.vue)\t*.vue\n"
                                            \ .. "JSON Files (*.json)\t*.json\n"
                                            \ .. "All Files (*.*)\t*.*\n"
    1              0.000001 endif
                            
                            " The following suffixes should be implied when resolving filenames
    1              0.000003 setlocal suffixesadd+=.js,.jsx,.es,.es6,.cjs,.mjs,.jsm,.vue,.json
                            
                            " The following suffixes should have low priority
                            "   .snap    jest snapshot
    1              0.000003 setlocal suffixes+=.snap
                            
                            " Remove irrelevant part of 'path'.
                            " User is expected to augment it with contextually-relevant paths
    1              0.000003 setlocal path-=/usr/include
                            
                            " Matchit configuration
    1              0.000003 if exists("loaded_matchit")
    1              0.000002     let b:match_ignorecase = 0
    1              0.000005     let b:match_words =
                                            \ '\<do\>:\<while\>,'
                                            \ .. '<\@<=\([^ \t>/]\+\)\%(\s\+[^>]*\%([^/]>\|$\)\|>\|$\):<\@<=/\1>,'
                                            \ .. '<\@<=\%([^ \t>/]\+\)\%(\s\+[^/>]*\|$\):/>'
    1              0.000001 endif
                            
                            " Set 'define' to a comprehensive value
    1              0.000010 let &l:define =
                                        \ '\(^\s*(*async\s\+function\|(*function\)'
                                        \ .. '\|^\s*\(\*\|static\|async\|get\|set\|\i\+\.\)'
                                        \ .. '\|^\s*\(\ze\i\+\)\(([^)]*).*{$\|\s*[:=,]\)'
                                        \ .. '\|^\s*\(export\s\+\|export\s\+default\s\+\)*\(var\|let\|const\|function\|class\)'
                                        \ .. '\|\<as\>'
                            
    1              0.000004 let b:undo_ftplugin =
                                        \ "setl fo< ofu< com< cms< sua< su< def< pa<"
                                        \ .. "| unlet! b:browsefilter b:match_ignorecase b:match_words"
                            
    1              0.000005 let &cpo = s:cpo_save
    1              0.000002 unlet s:cpo_save
                            
                            " vim: textwidth=78 tabstop=8 shiftwidth=4 softtabstop=4 expandtab

SCRIPT  /Users/Ragglesoft/.config/nvim/autoload/plugged/vim-polyglot/after/ftplugin/javascript.vim
Sourced 1 time
Total time:   0.002521
 Self time:   0.000810

count  total (s)   self (s)
                            " Polyglot metafile
    1   0.000810   0.000151 source <sfile>:h/javascript-1.vim
    1   0.001181   0.000130 source <sfile>:h/javascript-2.vim

SCRIPT  /Users/Ragglesoft/.config/nvim/autoload/plugged/vim-polyglot/after/ftplugin/javascript-1.vim
Sourced 1 time
Total time:   0.000576
 Self time:   0.000554

count  total (s)   self (s)
    1   0.000060   0.000039 if polyglot#init#is_disabled(expand('<sfile>:p'), 'javascript', 'after/ftplugin/javascript.vim')
                              finish
    1              0.000001 endif
                            
                            " Vim filetype plugin file
                            " Language:     JavaScript
                            " Maintainer:   vim-javascript community
                            " URL:          https://github.com/pangloss/vim-javascript
                            
    1              0.000026 setlocal iskeyword+=$ suffixesadd+=.js
                            
    1              0.000003 if exists('b:undo_ftplugin')
    1              0.000003   let b:undo_ftplugin .= ' | setlocal iskeyword< suffixesadd<'
                            else
                              let b:undo_ftplugin = 'setlocal iskeyword< suffixesadd<'
    1              0.000004 endif

SCRIPT  /Users/Ragglesoft/.config/nvim/autoload/plugged/vim-polyglot/after/ftplugin/javascript-2.vim
Sourced 1 time
Total time:   0.001021
 Self time:   0.000498

count  total (s)   self (s)
    1   0.000106   0.000055 if polyglot#init#is_disabled(expand('<sfile>:p'), 'jsx', 'after/ftplugin/javascript-2.vim')
                              finish
    1              0.000001 endif
                            
    1              0.000003 if get(g:, 'vim_jsx_pretty_disable_js', 0)
                              finish
    1              0.000001 endif
                            
    1   0.000607   0.000134 source <sfile>:h/jsx.vim

SCRIPT  /Users/Ragglesoft/.config/nvim/autoload/plugged/vim-polyglot/after/ftplugin/jsx.vim
Sourced 1 time
Total time:   0.000443
 Self time:   0.000423

count  total (s)   self (s)
    1   0.000056   0.000036 if polyglot#init#is_disabled(expand('<sfile>:p'), 'jsx', 'after/ftplugin/jsx.vim')
                              finish
    1              0.000001 endif
                            
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            " Vim ftplugin file
                            "
                            " Language: javascript.jsx
                            " Maintainer: MaxMEllon <maxmellon1994@gmail.com>
                            "
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
                            " modified from html.vim
                            " For matchit plugin
    1              0.000006 if exists("loaded_matchit")
    1              0.000002   let b:match_ignorecase = 0
    1              0.000004   let b:match_words = '(:),\[:\],{:},<:>,' .
                                    \ '<\@<=\([A-z0-9.]\+\):\(</\)\@<=\1'
    1              0.000001 endif
                            
                            " For andymass/vim-matchup plugin
    1              0.000002 if exists("loaded_matchup")
                              setlocal matchpairs=(:),{:},[:],<:>
                              let b:match_words = '<\@<=\([^/][^ \t>]*\)\g{hlend}[^>]*\%(/\@<!>\|$\):<\@<=/\1>'
                              let b:match_skip = 's:comment\|string'
    1              0.000001 endif
                            
    1              0.000027 let b:jsx_pretty_old_cms = &l:commentstring
                            
    1              0.000003 augroup jsx_comment
    1              0.000007   autocmd! CursorMoved <buffer>
    1              0.000003   autocmd CursorMoved <buffer> call jsx_pretty#comment#update_commentstring(b:jsx_pretty_old_cms)
    1              0.000001 augroup end
                            
    1              0.000007 setlocal suffixesadd+=.jsx

SCRIPT  /Users/Ragglesoft/.vim/plugged/vim-jsx-pretty/after/ftplugin/javascript.vim
Sourced 1 time
Total time:   0.000153
 Self time:   0.000094

count  total (s)   self (s)
    1              0.000006 if get(g:, 'vim_jsx_pretty_disable_js', 0)
                              finish
    1              0.000001 endif
                            
    1   0.000140   0.000080 source <sfile>:h/jsx.vim

SCRIPT  /Users/Ragglesoft/.vim/plugged/vim-jsx-pretty/after/ftplugin/jsx.vim
Sourced 1 time
Total time:   0.000039
 Self time:   0.000039

count  total (s)   self (s)
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            " Vim ftplugin file
                            "
                            " Language: javascript.jsx
                            " Maintainer: MaxMEllon <maxmellon1994@gmail.com>
                            "
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
                            " modified from html.vim
                            " For matchit plugin
    1              0.000003 if exists("loaded_matchit")
    1              0.000002   let b:match_ignorecase = 0
    1              0.000003   let b:match_words = '(:),\[:\],{:},<:>,' .
                                    \ '<\@<=\([A-z0-9.]\+\):\(</\)\@<=\1'
    1              0.000001 endif
                            
                            " For andymass/vim-matchup plugin
    1              0.000002 if exists("loaded_matchup")
                              setlocal matchpairs=(:),{:},[:],<:>
                              let b:match_words = '<\@<=\([^/][^ \t>]*\)\g{hlend}[^>]*\%(/\@<!>\|$\):<\@<=/\1>'
                              let b:match_skip = 's:comment\|string'
    1              0.000001 endif
                            
    1              0.000002 let b:jsx_pretty_old_cms = &l:commentstring
                            
    1              0.000001 augroup jsx_comment
    1              0.000003   autocmd! CursorMoved <buffer>
    1              0.000003   autocmd CursorMoved <buffer> call jsx_pretty#comment#update_commentstring(b:jsx_pretty_old_cms)
    1              0.000001 augroup end
                            
    1              0.000005 setlocal suffixesadd+=.jsx

SCRIPT  /Users/Ragglesoft/.config/nvim/autoload/plugged/vim-polyglot/indent/javascript.vim
Sourced 1 time
Total time:   0.000922
 Self time:   0.000899

count  total (s)   self (s)
    1   0.000096   0.000073 if polyglot#init#is_disabled(expand('<sfile>:p'), 'javascript', 'indent/javascript.vim')
                              finish
    1              0.000001 endif
                            
                            " Vim indent file
                            " Language: Javascript
                            " Maintainer: Chris Paul ( https://github.com/bounceme )
                            " URL: https://github.com/pangloss/vim-javascript
                            " Last Change: December 4, 2017
                            
                            " Only load this indent file when no other was loaded.
    1              0.000003 if exists('b:did_indent')
                              finish
    1              0.000001 endif
    1              0.000002 let b:did_indent = 1
                            
                            " Now, set up our indentation expression and keys that trigger it.
    1              0.000007 setlocal indentexpr=GetJavascriptIndent()
    1              0.000014 setlocal autoindent nolisp nosmartindent
    1              0.000004 setlocal indentkeys+=0],0)
                            " Testable with something like:
                            " vim  -eNs "+filetype plugin indent on" "+syntax on" "+set ft=javascript" \
                            "       "+norm! gg=G" '+%print' '+:q!' testfile.js \
                            "       | diff -uBZ testfile.js -
                            
    1              0.000002 let b:undo_indent = 'setlocal indentexpr< smartindent< autoindent< indentkeys<'
                            
                            " Only define the function once.
    1              0.000003 if exists('*GetJavascriptIndent')
    1              0.000001   finish
                            endif
                            
                            let s:cpo_save = &cpo
                            set cpo&vim
                            
                            " indent correctly if inside <script>
                            " vim/vim@690afe1 for the switch from cindent
                            " overridden with b:html_indent_script1
                            call extend(g:,{'html_indent_script1': 'inc'},'keep')
                            
                            " Regex of syntax group names that are or delimit string or are comments.
                            let s:bvars = {
                                  \ 'syng_strcom': 'string\|comment\|regex\|special\|doc\|template\%(braces\)\@!',
                                  \ 'syng_str': 'string\|template\|special' }
                            " template strings may want to be excluded when editing graphql:
                            " au! Filetype javascript let b:syng_str = '^\%(.*template\)\@!.*string\|special'
                            " au! Filetype javascript let b:syng_strcom = '^\%(.*template\)\@!.*string\|comment\|regex\|special\|doc'
                            
                            function s:GetVars()
                              call extend(b:,extend(s:bvars,{'js_cache': [0,0,0]}),'keep')
                            endfunction
                            
                            " Get shiftwidth value
                            if exists('*shiftwidth')
                              function s:sw()
                                return shiftwidth()
                              endfunction
                            else
                              function s:sw()
                                return &l:shiftwidth ? &l:shiftwidth : &l:tabstop
                              endfunction
                            endif
                            
                            " Performance for forwards search(): start search at pos rather than masking
                            " matches before pos.
                            let s:z = has('patch-7.4.984') ? 'z' : ''
                            
                            " Expression used to check whether we should skip a match with searchpair().
                            let s:skip_expr = "s:SynAt(line('.'),col('.')) =~? b:syng_strcom"
                            let s:in_comm = s:skip_expr[:-14] . "'comment\\|doc'"
                            
                            let s:rel = has('reltime')
                            " searchpair() wrapper
                            if s:rel
                              function s:GetPair(start,end,flags,skip)
                                return searchpair('\m'.a:start,'','\m'.a:end,a:flags,a:skip,s:l1,a:skip ==# 's:SkipFunc()' ? 2000 : 200)
                              endfunction
                            else
                              function s:GetPair(start,end,flags,skip)
                                return searchpair('\m'.a:start,'','\m'.a:end,a:flags,a:skip,s:l1)
                              endfunction
                            endif
                            
                            function s:SynAt(l,c)
                              let byte = line2byte(a:l) + a:c - 1
                              let pos = index(s:synid_cache[0], byte)
                              if pos == -1
                                let s:synid_cache[:] += [[byte], [synIDattr(synID(a:l, a:c, 0), 'name')]]
                              endif
                              return s:synid_cache[1][pos]
                            endfunction
                            
                            function s:ParseCino(f)
                              let [s, n, divider] = [strridx(&cino, a:f)+1, '', 0]
                              while s && &cino[ s ] =~ '[^,]'
                                if &cino[ s ] == '.'
                                  let divider = 1
                                elseif &cino[ s ] ==# 's'
                                  if n !~ '\d'
                                    return n . s:sw() + 0
                                  endif
                                  let n = str2nr(n) * s:sw()
                                  break
                                else
                                  let [n, divider] .= [&cino[ s ], 0]
                                endif
                                let s += 1
                              endwhile
                              return str2nr(n) / max([divider, 1])
                            endfunction
                            
                            " Optimized {skip} expr, only callable from the search loop which
                            " GetJavascriptIndent does to find the containing [[{(] (side-effects)
                            function s:SkipFunc()
                              if s:top_col == 1
                                throw 'out of bounds'
                              elseif s:check_in
                                if eval(s:skip_expr)
                                  return 1
                                endif
                                let s:check_in = 0
                              elseif getline('.') =~ '\%<'.col('.').'c\/.\{-}\/\|\%>'.col('.').'c[''"]\|\\$'
                                if eval(s:skip_expr)
                                  return 1
                                endif
                              elseif search('\m`\|\${\|\*\/','nW'.s:z,s:looksyn)
                                if eval(s:skip_expr)
                                  let s:check_in = 1
                                  return 1
                                endif
                              else
                                let s:synid_cache[:] += [[line2byte('.') + col('.') - 1], ['']]
                              endif
                              let [s:looksyn, s:top_col] = getpos('.')[1:2]
                            endfunction
                            
                            function s:AlternatePair()
                              let [pat, l:for] = ['[][(){};]', 2]
                              while s:SearchLoop(pat,'bW','s:SkipFunc()')
                                if s:LookingAt() == ';'
                                  if !l:for
                                    if s:GetPair('{','}','bW','s:SkipFunc()')
                                      return
                                    endif
                                    break
                                  else
                                    let [pat, l:for] = ['[{}();]', l:for - 1]
                                  endif
                                else
                                  let idx = stridx('])}',s:LookingAt())
                                  if idx == -1
                                    return
                                  elseif !s:GetPair(['\[','(','{'][idx],'])}'[idx],'bW','s:SkipFunc()')
                                    break
                                  endif
                                endif
                              endwhile
                              throw 'out of bounds'
                            endfunction
                            
                            function s:Nat(int)
                              return a:int * (a:int > 0)
                            endfunction
                            
                            function s:LookingAt()
                              return getline('.')[col('.')-1]
                            endfunction
                            
                            function s:Token()
                              return s:LookingAt() =~ '\k' ? expand('<cword>') : s:LookingAt()
                            endfunction
                            
                            function s:PreviousToken(...)
                              let [l:pos, tok] = [getpos('.'), '']
                              if search('\m\k\{1,}\|\S','ebW')
                                if getline('.')[col('.')-2:col('.')-1] == '*/'
                                  if eval(s:in_comm) && !s:SearchLoop('\S\ze\_s*\/[/*]','bW',s:in_comm)
                                    call setpos('.',l:pos)
                                  else
                                    let tok = s:Token()
                                  endif
                                else
                                  let two = a:0 || line('.') != l:pos[1] ? strridx(getline('.')[:col('.')],'//') + 1 : 0
                                  if two && eval(s:in_comm)
                                    call cursor(0,two)
                                    let tok = s:PreviousToken(1)
                                    if tok is ''
                                      call setpos('.',l:pos)
                                    endif
                                  else
                                    let tok = s:Token()
                                  endif
                                endif
                              endif
                              return tok
                            endfunction
                            
                            function s:Pure(f,...)
                              return eval("[call(a:f,a:000),cursor(a:firstline,".col('.').")][0]")
                            endfunction
                            
                            function s:SearchLoop(pat,flags,expr)
                              return s:GetPair(a:pat,'\_$.',a:flags,a:expr)
                            endfunction
                            
                            function s:ExprCol()
                              if getline('.')[col('.')-2] == ':'
                                return 1
                              endif
                              let bal = 0
                              while s:SearchLoop('[{}?:]','bW',s:skip_expr)
                                if s:LookingAt() == ':'
                                  let bal -= !search('\m:\%#','bW')
                                elseif s:LookingAt() == '?'
                                  if getline('.')[col('.'):col('.')+1] =~ '^\.\d\@!'
                                    " ?. conditional chain, not ternary start
                                  elseif !bal
                                    return 1
                                  else
                                    let bal += 1
                                  endif
                                elseif s:LookingAt() == '{'
                                  return !s:IsBlock()
                                elseif !s:GetPair('{','}','bW',s:skip_expr)
                                  break
                                endif
                              endwhile
                            endfunction
                            
                            " configurable regexes that define continuation lines, not including (, {, or [.
                            let s:opfirst = '^' . get(g:,'javascript_opfirst',
                                  \ '\C\%([<>=,.?^%|/&]\|\([-:+]\)\1\@!\|\*\+\|!=\|in\%(stanceof\)\=\>\)')
                            let s:continuation = get(g:,'javascript_continuation',
                                  \ '\C\%([<=,.~!?/*^%|&:]\|+\@<!+\|-\@<!-\|=\@<!>\|\<\%(typeof\|new\|delete\|void\|in\|instanceof\|await\)\)') . '$'
                            
                            function s:Continues()
                              let tok = matchstr(strpart(getline('.'),col('.')-15,15),s:continuation)
                              if tok =~ '[a-z:]'
                                return tok == ':' ? s:ExprCol() : s:PreviousToken() != '.'
                              elseif tok !~ '[/>]'
                                return tok isnot ''
                              endif
                              return s:SynAt(line('.'),col('.')) !~? (tok == '>' ? 'jsflow\|^html' : 'regex')
                            endfunction
                            
                            " Check if line 'lnum' has a balanced amount of parentheses.
                            function s:Balanced(lnum,line)
                              let l:open = 0
                              let pos = match(a:line, '[][(){}]')
                              while pos != -1
                                if s:SynAt(a:lnum,pos + 1) !~? b:syng_strcom
                                  let l:open += matchend(a:line[pos],'[[({]')
                                  if l:open < 0
                                    return
                                  endif
                                endif
                                let pos = match(a:line, !l:open ? '[][(){}]' : '()' =~ a:line[pos] ?
                                      \ '[()]' : '{}' =~ a:line[pos] ? '[{}]' : '[][]', pos + 1)
                              endwhile
                              return !l:open
                            endfunction
                            
                            function s:OneScope()
                              if s:LookingAt() == ')' && s:GetPair('(', ')', 'bW', s:skip_expr)
                                let tok = s:PreviousToken()
                                return (count(split('for if let while with'),tok) ||
                                      \ tok =~# '^await$\|^each$' && s:PreviousToken() ==# 'for') &&
                                      \ s:Pure('s:PreviousToken') != '.' && !(tok == 'while' && s:DoWhile())
                              elseif s:Token() =~# '^else$\|^do$'
                                return s:Pure('s:PreviousToken') != '.'
                              elseif strpart(getline('.'),col('.')-2,2) == '=>'
                                call cursor(0,col('.')-1)
                                return s:PreviousToken() != ')' || s:GetPair('(', ')', 'bW', s:skip_expr)
                              endif
                            endfunction
                            
                            function s:DoWhile()
                              let cpos = searchpos('\m\<','cbW')
                              while s:SearchLoop('\C[{}]\|\<\%(do\|while\)\>','bW',s:skip_expr)
                                if s:LookingAt() =~ '\a'
                                  if s:Pure('s:IsBlock')
                                    if s:LookingAt() ==# 'd'
                                      return 1
                                    endif
                                    break
                                  endif
                                elseif s:LookingAt() != '}' || !s:GetPair('{','}','bW',s:skip_expr)
                                  break
                                endif
                              endwhile
                              call call('cursor',cpos)
                            endfunction
                            
                            " returns total offset from braceless contexts. 'num' is the lineNr which
                            " encloses the entire context, 'cont' if whether a:firstline is a continued
                            " expression, which could have started in a braceless context
                            function s:IsContOne(cont)
                              let [l:num, pind] = b:js_cache[1] ?
                                    \ [b:js_cache[1], indent(b:js_cache[1]) + s:sw()] : [1,0]
                              let [ind, b_l] = [indent('.') + !a:cont, 0]
                              while line('.') > l:num && ind > pind || line('.') == l:num
                                if indent('.') < ind && s:OneScope()
                                  let b_l += 1
                                elseif !a:cont || b_l || ind < indent(a:firstline)
                                  break
                                else
                                  call cursor(0,1)
                                endif
                                let ind = min([ind, indent('.')])
                                if s:PreviousToken() is ''
                                  break
                                endif
                              endwhile
                              return b_l
                            endfunction
                            
                            function s:IsSwitch()
                              return search(printf('\m\C\%%%dl\%%%dc%s',b:js_cache[1],b:js_cache[2],
                                    \ '{\_s*\%(\%(\/\/.*\_$\|\/\*\_.\{-}\*\/\)\@>\_s*\)*\%(case\|default\)\>'),'nW'.s:z)
                            endfunction
                            
                            " https://github.com/sweet-js/sweet.js/wiki/design#give-lookbehind-to-the-reader
                            function s:IsBlock()
                              let tok = s:PreviousToken()
                              if join(s:stack) =~? 'xml\|jsx' && s:SynAt(line('.'),col('.')-1) =~? 'xml\|jsx'
                                let s:in_jsx = 1
                                return tok != '{'
                              elseif tok =~ '\k'
                                if tok ==# 'type'
                                  return s:Pure('eval',"s:PreviousToken() !~# '^\\%(im\\|ex\\)port$' || s:PreviousToken() == '.'")
                                elseif tok ==# 'of'
                                  return s:Pure('eval',"!s:GetPair('[[({]','[])}]','bW',s:skip_expr) || s:LookingAt() != '(' ||"
                                        \ ."s:{s:PreviousToken() ==# 'await' ? 'Previous' : ''}Token() !=# 'for' || s:PreviousToken() == '.'")
                                endif
                                return index(split('return const let import export extends yield default delete var await void typeof throw case new in instanceof')
                                      \ ,tok) < (line('.') != a:firstline) || s:Pure('s:PreviousToken') == '.'
                              elseif tok == '>'
                                return getline('.')[col('.')-2] == '=' || s:SynAt(line('.'),col('.')) =~? 'jsflow\|^html'
                              elseif tok == '*'
                                return s:Pure('s:PreviousToken') == ':'
                              elseif tok == ':'
                                return s:Pure('eval',"s:PreviousToken() =~ '^\\K\\k*$' && !s:ExprCol()")
                              elseif tok == '/'
                                return s:SynAt(line('.'),col('.')) =~? 'regex'
                              elseif tok !~ '[=~!<,.?^%|&([]'
                                return tok !~ '[-+]' || line('.') != a:firstline && getline('.')[col('.')-2] == tok
                              endif
                            endfunction
                            
                            function GetJavascriptIndent()
                              call s:GetVars()
                              let s:synid_cache = [[],[]]
                              let l:line = getline(v:lnum)
                              " use synstack as it validates syn state and works in an empty line
                              let s:stack = [''] + map(synstack(v:lnum,1),"synIDattr(v:val,'name')")
                            
                              " start with strings,comments,etc.
                              if s:stack[-1] =~? 'comment\|doc'
                                if l:line !~ '^\s*\/[/*]'
                                  return l:line =~ '^\s*\*' ? cindent(v:lnum) : -1
                                endif
                              elseif s:stack[-1] =~? b:syng_str
                                if b:js_cache[0] == v:lnum - 1 && s:Balanced(v:lnum-1,getline(v:lnum-1))
                                  let b:js_cache[0] = v:lnum
                                endif
                                return -1
                              endif
                            
                              let nest = get(get(b:,'hi_indent',{}),'blocklnr')
                              let s:l1 = max([0, prevnonblank(v:lnum) - (s:rel ? 2000 : 1000), nest])
                              call cursor(v:lnum,1)
                              if s:PreviousToken() is ''
                                return
                              endif
                              let [l:lnum, lcol, pline] = getpos('.')[1:2] + [getline('.')[:col('.')-1]]
                            
                              let l:line = substitute(l:line,'^\s*','','')
                              let l:line_s = l:line[0]
                              if l:line[:1] == '/*'
                                let l:line = substitute(l:line,'^\%(\/\*.\{-}\*\/\s*\)*','','')
                              endif
                              if l:line =~ '^\/[/*]'
                                let l:line = ''
                              endif
                            
                              " the containing paren, bracket, or curly. Many hacks for performance
                              call cursor(v:lnum,1)
                              let idx = index([']',')','}'],l:line[0])
                              if b:js_cache[0] > l:lnum && b:js_cache[0] < v:lnum ||
                                    \ b:js_cache[0] == l:lnum && s:Balanced(l:lnum,pline)
                                call call('cursor',b:js_cache[1:])
                              else
                                let [s:looksyn, s:top_col, s:check_in, s:l1] = [v:lnum - 1,0,0,
                                      \ max([s:l1, &smc ? search('\m^.\{'.&smc.',}','nbW',s:l1 + 1) + 1 : 0])]
                                try
                                  if idx != -1
                                    call s:GetPair(['\[','(','{'][idx],'])}'[idx],'bW','s:SkipFunc()')
                                  elseif getline(v:lnum) !~ '^\S' && s:stack[-1] =~? 'block\|^jsobject$'
                                    if !s:GetPair('{','}','bW','s:SkipFunc()') && s:stack[-1] ==# 'jsObject'
                                      return indent(l:lnum)
                                    endif
                                  else
                                    call s:AlternatePair()
                                  endif
                                catch /^\Cout of bounds$/
                                  call cursor(v:lnum,1)
                                endtry
                                let b:js_cache[1:] = line('.') == v:lnum ? [0,0] : getpos('.')[1:2]
                              endif
                            
                              let [b:js_cache[0], num] = [v:lnum, b:js_cache[1]]
                            
                              let [num_ind, is_op, b_l, l:switch_offset, s:in_jsx] = [s:Nat(indent(num)),0,0,0,0]
                              if !num || s:LookingAt() == '{' && s:IsBlock()
                                let ilnum = line('.')
                                if num && !s:in_jsx && s:LookingAt() == ')' && s:GetPair('(',')','bW',s:skip_expr)
                                  if ilnum == num
                                    let [num, num_ind] = [line('.'), indent('.')]
                                  endif
                                  if idx == -1 && s:PreviousToken() ==# 'switch' && s:IsSwitch()
                                    let l:switch_offset = &cino !~ ':' ? s:sw() : s:ParseCino(':')
                                    if pline[-1:] != '.' && l:line =~# '^\%(default\|case\)\>'
                                      return s:Nat(num_ind + l:switch_offset)
                                    elseif &cino =~ '='
                                      let l:case_offset = s:ParseCino('=')
                                    endif
                                  endif
                                endif
                                if idx == -1 && pline[-1:] !~ '[{;]'
                                  call cursor(l:lnum, lcol)
                                  let sol = matchstr(l:line,s:opfirst)
                                  if sol is '' || sol == '/' && s:SynAt(v:lnum,
                                        \ 1 + len(getline(v:lnum)) - len(l:line)) =~? 'regex'
                                    if s:Continues()
                                      let is_op = s:sw()
                                    endif
                                  elseif num && sol =~# '^\%(in\%(stanceof\)\=\|\*\)$' &&
                                        \ s:LookingAt() == '}' && s:GetPair('{','}','bW',s:skip_expr) &&
                                        \ s:PreviousToken() == ')' && s:GetPair('(',')','bW',s:skip_expr) &&
                                        \ (s:PreviousToken() == ']' || s:LookingAt() =~ '\k' &&
                                        \ s:{s:PreviousToken() == '*' ? 'Previous' : ''}Token() !=# 'function')
                                    return num_ind + s:sw()
                                  else
                                    let is_op = s:sw()
                                  endif
                                  call cursor(l:lnum, lcol)
                                  let b_l = s:Nat(s:IsContOne(is_op) - (!is_op && l:line =~ '^{')) * s:sw()
                                endif
                              elseif idx == -1 && s:LookingAt() == '(' && &cino =~ '(' &&
                                    \ (search('\m\S','nbW',num) || s:ParseCino('U'))
                                let pval = s:ParseCino('(')
                                if !pval
                                  let [Wval, vcol] = [s:ParseCino('W'), virtcol('.')]
                                  if search('\m'.get(g:,'javascript_indent_W_pat','\S'),'W',num)
                                    return s:ParseCino('w') ? vcol : virtcol('.')-1
                                  endif
                                  return Wval ? s:Nat(num_ind + Wval) : vcol
                                endif
                                return s:Nat(num_ind + pval + searchpair('\m(','','\m)','nbrmW',s:skip_expr,num) * s:sw())
                              endif
                            
                              " main return
                              if l:line =~ '^[])}]\|^|}'
                                if l:line_s == ')'
                                  if s:ParseCino('M')
                                    return indent(l:lnum)
                                  elseif num && &cino =~# 'm' && !s:ParseCino('m')
                                    return virtcol('.') - 1
                                  endif
                                endif
                                return num_ind
                              elseif num
                                return s:Nat(num_ind + get(l:,'case_offset',s:sw()) + l:switch_offset + b_l + is_op)
                              elseif nest
                                return indent(nextnonblank(nest+1)) + b_l + is_op
                              endif
                              return b_l + is_op
                            endfunction
                            
                            let &cpo = s:cpo_save
                            unlet s:cpo_save

SCRIPT  /usr/local/Cellar/neovim/0.5.0/share/nvim/runtime/indent/javascript.vim
Sourced 1 time
Total time:   0.000553
 Self time:   0.000553

count  total (s)   self (s)
                            " Vim indent file
                            " Language: Javascript
                            " Maintainer: Chris Paul ( https://github.com/bounceme )
                            " URL: https://github.com/pangloss/vim-javascript
                            " Last Change: December 4, 2017
                            
                            " Only load this indent file when no other was loaded.
    1              0.000009 if exists('b:did_indent')
    1              0.000002   finish
                            endif
                            let b:did_indent = 1
                            
                            " Now, set up our indentation expression and keys that trigger it.
                            setlocal indentexpr=GetJavascriptIndent()
                            setlocal autoindent nolisp nosmartindent
                            setlocal indentkeys+=0],0)
                            " Testable with something like:
                            " vim  -eNs "+filetype plugin indent on" "+syntax on" "+set ft=javascript" \
                            "       "+norm! gg=G" '+%print' '+:q!' testfile.js \
                            "       | diff -uBZ testfile.js -
                            
                            let b:undo_indent = 'setlocal indentexpr< smartindent< autoindent< indentkeys<'
                            
                            " Only define the function once.
                            if exists('*GetJavascriptIndent')
                              finish
                            endif
                            
                            let s:cpo_save = &cpo
                            set cpo&vim
                            
                            " indent correctly if inside <script>
                            " vim/vim@690afe1 for the switch from cindent
                            " overridden with b:html_indent_script1
                            call extend(g:,{'html_indent_script1': 'inc'},'keep')
                            
                            " Regex of syntax group names that are or delimit string or are comments.
                            let s:bvars = {
                                  \ 'syng_strcom': 'string\|comment\|regex\|special\|doc\|template\%(braces\)\@!',
                                  \ 'syng_str': 'string\|template\|special' }
                            " template strings may want to be excluded when editing graphql:
                            " au! Filetype javascript let b:syng_str = '^\%(.*template\)\@!.*string\|special'
                            " au! Filetype javascript let b:syng_strcom = '^\%(.*template\)\@!.*string\|comment\|regex\|special\|doc'
                            
                            function s:GetVars()
                              call extend(b:,extend(s:bvars,{'js_cache': [0,0,0]}),'keep')
                            endfunction
                            
                            " Get shiftwidth value
                            if exists('*shiftwidth')
                              function s:sw()
                                return shiftwidth()
                              endfunction
                            else
                              function s:sw()
                                return &l:shiftwidth ? &l:shiftwidth : &l:tabstop
                              endfunction
                            endif
                            
                            " Performance for forwards search(): start search at pos rather than masking
                            " matches before pos.
                            let s:z = has('patch-7.4.984') ? 'z' : ''
                            
                            " Expression used to check whether we should skip a match with searchpair().
                            let s:skip_expr = "s:SynAt(line('.'),col('.')) =~? b:syng_strcom"
                            let s:in_comm = s:skip_expr[:-14] . "'comment\\|doc'"
                            
                            let s:rel = has('reltime')
                            " searchpair() wrapper
                            if s:rel
                              function s:GetPair(start,end,flags,skip)
                                return searchpair('\m'.a:start,'','\m'.a:end,a:flags,a:skip,s:l1,a:skip ==# 's:SkipFunc()' ? 2000 : 200)
                              endfunction
                            else
                              function s:GetPair(start,end,flags,skip)
                                return searchpair('\m'.a:start,'','\m'.a:end,a:flags,a:skip,s:l1)
                              endfunction
                            endif
                            
                            function s:SynAt(l,c)
                              let byte = line2byte(a:l) + a:c - 1
                              let pos = index(s:synid_cache[0], byte)
                              if pos == -1
                                let s:synid_cache[:] += [[byte], [synIDattr(synID(a:l, a:c, 0), 'name')]]
                              endif
                              return s:synid_cache[1][pos]
                            endfunction
                            
                            function s:ParseCino(f)
                              let [divider, n, cstr] = [0] + matchlist(&cino,
                                    \ '\%(.*,\)\=\%(\%d'.char2nr(a:f).'\(-\)\=\([.s0-9]*\)\)\=')[1:2]
                              for c in split(cstr,'\zs')
                                if c == '.' && !divider
                                  let divider = 1
                                elseif c ==# 's'
                                  if n !~ '\d'
                                    return n . s:sw() + 0
                                  endif
                                  let n = str2nr(n) * s:sw()
                                  break
                                else
                                  let [n, divider] .= [c, 0]
                                endif
                              endfor
                              return str2nr(n) / max([str2nr(divider),1])
                            endfunction
                            
                            " Optimized {skip} expr, only callable from the search loop which
                            " GetJavascriptIndent does to find the containing [[{(] (side-effects)
                            function s:SkipFunc()
                              if s:top_col == 1
                                throw 'out of bounds'
                              elseif s:check_in
                                if eval(s:skip_expr)
                                  return 1
                                endif
                                let s:check_in = 0
                              elseif getline('.') =~ '\%<'.col('.').'c\/.\{-}\/\|\%>'.col('.').'c[''"]\|\\$'
                                if eval(s:skip_expr)
                                  return 1
                                endif
                              elseif search('\m`\|\${\|\*\/','nW'.s:z,s:looksyn)
                                if eval(s:skip_expr)
                                  let s:check_in = 1
                                  return 1
                                endif
                              else
                                let s:synid_cache[:] += [[line2byte('.') + col('.') - 1], ['']]
                              endif
                              let [s:looksyn, s:top_col] = getpos('.')[1:2]
                            endfunction
                            
                            function s:AlternatePair()
                              let [pat, l:for] = ['[][(){};]', 2]
                              while s:SearchLoop(pat,'bW','s:SkipFunc()')
                                if s:LookingAt() == ';'
                                  if !l:for
                                    if s:GetPair('{','}','bW','s:SkipFunc()')
                                      return
                                    endif
                                    break
                                  else
                                    let [pat, l:for] = ['[{}();]', l:for - 1]
                                  endif
                                else
                                  let idx = stridx('])}',s:LookingAt())
                                  if idx == -1
                                    return
                                  elseif !s:GetPair(['\[','(','{'][idx],'])}'[idx],'bW','s:SkipFunc()')
                                    break
                                  endif
                                endif
                              endwhile
                              throw 'out of bounds'
                            endfunction
                            
                            function s:Nat(int)
                              return a:int * (a:int > 0)
                            endfunction
                            
                            function s:LookingAt()
                              return getline('.')[col('.')-1]
                            endfunction
                            
                            function s:Token()
                              return s:LookingAt() =~ '\k' ? expand('<cword>') : s:LookingAt()
                            endfunction
                            
                            function s:PreviousToken(...)
                              let [l:pos, tok] = [getpos('.'), '']
                              if search('\m\k\{1,}\|\S','ebW')
                                if getline('.')[col('.')-2:col('.')-1] == '*/'
                                  if eval(s:in_comm) && !s:SearchLoop('\S\ze\_s*\/[/*]','bW',s:in_comm)
                                    call setpos('.',l:pos)
                                  else
                                    let tok = s:Token()
                                  endif
                                else
                                  let two = a:0 || line('.') != l:pos[1] ? strridx(getline('.')[:col('.')],'//') + 1 : 0
                                  if two && eval(s:in_comm)
                                    call cursor(0,two)
                                    let tok = s:PreviousToken(1)
                                    if tok is ''
                                      call setpos('.',l:pos)
                                    endif
                                  else
                                    let tok = s:Token()
                                  endif
                                endif
                              endif
                              return tok
                            endfunction
                            
                            function s:Pure(f,...)
                              return eval("[call(a:f,a:000),cursor(a:firstline,".col('.').")][0]")
                            endfunction
                            
                            function s:SearchLoop(pat,flags,expr)
                              return s:GetPair(a:pat,'\_$.',a:flags,a:expr)
                            endfunction
                            
                            function s:ExprCol()
                              if getline('.')[col('.')-2] == ':'
                                return 1
                              endif
                              let bal = 0
                              while s:SearchLoop('[{}?:]','bW',s:skip_expr)
                                if s:LookingAt() == ':'
                                  if getline('.')[col('.')-2] == ':'
                                    call cursor(0,col('.')-1)
                                    continue
                                  endif
                                  let bal -= 1
                                elseif s:LookingAt() == '?'
                                  if getline('.')[col('.'):col('.')+1] =~ '^\.\d\@!'
                                    continue
                                  elseif !bal
                                    return 1
                                  endif
                                  let bal += 1
                                elseif s:LookingAt() == '{'
                                  return !s:IsBlock()
                                elseif !s:GetPair('{','}','bW',s:skip_expr)
                                  break
                                endif
                              endwhile
                            endfunction
                            
                            " configurable regexes that define continuation lines, not including (, {, or [.
                            let s:opfirst = '^' . get(g:,'javascript_opfirst',
                                  \ '\C\%([<>=,.?^%|/&]\|\([-:+]\)\1\@!\|\*\+\|!=\|in\%(stanceof\)\=\>\)')
                            let s:continuation = get(g:,'javascript_continuation',
                                  \ '\C\%([<=,.~!?/*^%|&:]\|+\@<!+\|-\@<!-\|=\@<!>\|\<\%(typeof\|new\|delete\|void\|in\|instanceof\|await\)\)') . '$'
                            
                            function s:Continues()
                              let tok = matchstr(strpart(getline('.'),col('.')-15,15),s:continuation)
                              if tok =~ '[a-z:]'
                                return tok == ':' ? s:ExprCol() : s:PreviousToken() != '.'
                              elseif tok !~ '[/>]'
                                return tok isnot ''
                              endif
                              return s:SynAt(line('.'),col('.')) !~? (tok == '>' ? 'jsflow\|^html' : 'regex')
                            endfunction
                            
                            " Check if line 'lnum' has a balanced amount of parentheses.
                            function s:Balanced(lnum,line)
                              let l:open = 0
                              let pos = match(a:line, '[][(){}]')
                              while pos != -1
                                if s:SynAt(a:lnum,pos + 1) !~? b:syng_strcom
                                  let l:open += match(' ' . a:line[pos],'[[({]')
                                  if l:open < 0
                                    return
                                  endif
                                endif
                                let pos = match(a:line, !l:open ? '[][(){}]' : '()' =~ a:line[pos] ?
                                      \ '[()]' : '{}' =~ a:line[pos] ? '[{}]' : '[][]', pos + 1)
                              endwhile
                              return !l:open
                            endfunction
                            
                            function s:OneScope()
                              if s:LookingAt() == ')' && s:GetPair('(', ')', 'bW', s:skip_expr)
                                let tok = s:PreviousToken()
                                return (count(split('for if let while with'),tok) ||
                                      \ tok =~# '^await$\|^each$' && s:PreviousToken() ==# 'for') &&
                                      \ s:Pure('s:PreviousToken') != '.' && !(tok == 'while' && s:DoWhile())
                              elseif s:Token() =~# '^else$\|^do$'
                                return s:Pure('s:PreviousToken') != '.'
                              elseif strpart(getline('.'),col('.')-2,2) == '=>'
                                call cursor(0,col('.')-1)
                                if s:PreviousToken() == ')'
                                  return s:GetPair('(', ')', 'bW', s:skip_expr)
                                endif
                                return 1
                              endif
                            endfunction
                            
                            function s:DoWhile()
                              let cpos = searchpos('\m\<','cbW')
                              while s:SearchLoop('\C[{}]\|\<\%(do\|while\)\>','bW',s:skip_expr)
                                if s:LookingAt() =~ '\a'
                                  if s:Pure('s:IsBlock')
                                    if s:LookingAt() ==# 'd'
                                      return 1
                                    endif
                                    break
                                  endif
                                elseif s:LookingAt() != '}' || !s:GetPair('{','}','bW',s:skip_expr)
                                  break
                                endif
                              endwhile
                              call call('cursor',cpos)
                            endfunction
                            
                            " returns total offset from braceless contexts. 'num' is the lineNr which
                            " encloses the entire context, 'cont' if whether a:firstline is a continued
                            " expression, which could have started in a braceless context
                            function s:IsContOne(cont)
                              let [l:num, b_l] = [b:js_cache[1] + !b:js_cache[1], 0]
                              let pind = b:js_cache[1] ? indent(b:js_cache[1]) + s:sw() : 0
                              let ind = indent('.') + !a:cont
                              while line('.') > l:num && ind > pind || line('.') == l:num
                                if indent('.') < ind && s:OneScope()
                                  let b_l += 1
                                elseif !a:cont || b_l || ind < indent(a:firstline)
                                  break
                                else
                                  call cursor(0,1)
                                endif
                                let ind = min([ind, indent('.')])
                                if s:PreviousToken() is ''
                                  break
                                endif
                              endwhile
                              return b_l
                            endfunction
                            
                            function s:IsSwitch()
                              call call('cursor',b:js_cache[1:])
                              return search('\m\C\%#.\_s*\%(\%(\/\/.*\_$\|\/\*\_.\{-}\*\/\)\@>\_s*\)*\%(case\|default\)\>','nWc'.s:z)
                            endfunction
                            
                            " https://github.com/sweet-js/sweet.js/wiki/design#give-lookbehind-to-the-reader
                            function s:IsBlock()
                              let tok = s:PreviousToken()
                              if join(s:stack) =~? 'xml\|jsx' && s:SynAt(line('.'),col('.')-1) =~? 'xml\|jsx'
                                let s:in_jsx = 1
                                return tok != '{'
                              elseif tok =~ '\k'
                                if tok ==# 'type'
                                  return s:Pure('eval',"s:PreviousToken() !~# '^\\%(im\\|ex\\)port$' || s:PreviousToken() == '.'")
                                elseif tok ==# 'of'
                                  return s:Pure('eval',"!s:GetPair('[[({]','[])}]','bW',s:skip_expr) || s:LookingAt() != '(' ||"
                                        \ ."s:{s:PreviousToken() ==# 'await' ? 'Previous' : ''}Token() !=# 'for' || s:PreviousToken() == '.'")
                                endif
                                return index(split('return const let import export extends yield default delete var await void typeof throw case new in instanceof')
                                      \ ,tok) < (line('.') != a:firstline) || s:Pure('s:PreviousToken') == '.'
                              elseif tok == '>'
                                return getline('.')[col('.')-2] == '=' || s:SynAt(line('.'),col('.')) =~? 'jsflow\|^html'
                              elseif tok == '*'
                                return s:Pure('s:PreviousToken') == ':'
                              elseif tok == ':'
                                return s:Pure('eval',"s:PreviousToken() =~ '^\\K\\k*$' && !s:ExprCol()")
                              elseif tok == '/'
                                return s:SynAt(line('.'),col('.')) =~? 'regex'
                              elseif tok !~ '[=~!<,.?^%|&([]'
                                return tok !~ '[-+]' || line('.') != a:firstline && getline('.')[col('.')-2] == tok
                              endif
                            endfunction
                            
                            function GetJavascriptIndent()
                              call s:GetVars()
                              let s:synid_cache = [[],[]]
                              let l:line = getline(v:lnum)
                              " use synstack as it validates syn state and works in an empty line
                              let s:stack = [''] + map(synstack(v:lnum,1),"synIDattr(v:val,'name')")
                            
                              " start with strings,comments,etc.
                              if s:stack[-1] =~? 'comment\|doc'
                                if l:line =~ '^\s*\*'
                                  return cindent(v:lnum)
                                elseif l:line !~ '^\s*\/[/*]'
                                  return -1
                                endif
                              elseif s:stack[-1] =~? b:syng_str
                                if b:js_cache[0] == v:lnum - 1 && s:Balanced(v:lnum-1,getline(v:lnum-1))
                                  let b:js_cache[0] = v:lnum
                                endif
                                return -1
                              endif
                            
                              let s:l1 = max([0,prevnonblank(v:lnum) - (s:rel ? 2000 : 1000),
                                    \ get(get(b:,'hi_indent',{}),'blocklnr')])
                              call cursor(v:lnum,1)
                              if s:PreviousToken() is ''
                                return
                              endif
                              let [l:lnum, pline] = [line('.'), getline('.')[:col('.')-1]]
                            
                              let l:line = substitute(l:line,'^\s*','','')
                              let l:line_raw = l:line
                              if l:line[:1] == '/*'
                                let l:line = substitute(l:line,'^\%(\/\*.\{-}\*\/\s*\)*','','')
                              endif
                              if l:line =~ '^\/[/*]'
                                let l:line = ''
                              endif
                            
                              " the containing paren, bracket, or curly. Many hacks for performance
                              call cursor(v:lnum,1)
                              let idx = index([']',')','}'],l:line[0])
                              if b:js_cache[0] > l:lnum && b:js_cache[0] < v:lnum ||
                                    \ b:js_cache[0] == l:lnum && s:Balanced(l:lnum,pline)
                                call call('cursor',b:js_cache[1:])
                              else
                                let [s:looksyn, s:top_col, s:check_in, s:l1] = [v:lnum - 1,0,0,
                                      \ max([s:l1, &smc ? search('\m^.\{'.&smc.',}','nbW',s:l1 + 1) + 1 : 0])]
                                try
                                  if idx != -1
                                    call s:GetPair(['\[','(','{'][idx],'])}'[idx],'bW','s:SkipFunc()')
                                  elseif getline(v:lnum) !~ '^\S' && s:stack[-1] =~? 'block\|^jsobject$'
                                    call s:GetPair('{','}','bW','s:SkipFunc()')
                                  else
                                    call s:AlternatePair()
                                  endif
                                catch /^\Cout of bounds$/
                                  call cursor(v:lnum,1)
                                endtry
                                let b:js_cache[1:] = line('.') == v:lnum ? [0,0] : getpos('.')[1:2]
                              endif
                            
                              let [b:js_cache[0], num] = [v:lnum, b:js_cache[1]]
                            
                              let [num_ind, is_op, b_l, l:switch_offset, s:in_jsx] = [s:Nat(indent(num)),0,0,0,0]
                              if !num || s:LookingAt() == '{' && s:IsBlock()
                                let ilnum = line('.')
                                if num && !s:in_jsx && s:LookingAt() == ')' && s:GetPair('(',')','bW',s:skip_expr)
                                  if ilnum == num
                                    let [num, num_ind] = [line('.'), indent('.')]
                                  endif
                                  if idx == -1 && s:PreviousToken() ==# 'switch' && s:IsSwitch()
                                    let l:switch_offset = &cino !~ ':' ? s:sw() : s:ParseCino(':')
                                    if pline[-1:] != '.' && l:line =~# '^\%(default\|case\)\>'
                                      return s:Nat(num_ind + l:switch_offset)
                                    elseif &cino =~ '='
                                      let l:case_offset = s:ParseCino('=')
                                    endif
                                  endif
                                endif
                                if idx == -1 && pline[-1:] !~ '[{;]'
                                  call cursor(l:lnum, len(pline))
                                  let sol = matchstr(l:line,s:opfirst)
                                  if sol is '' || sol == '/' && s:SynAt(v:lnum,
                                        \ 1 + len(getline(v:lnum)) - len(l:line)) =~? 'regex'
                                    if s:Continues()
                                      let is_op = s:sw()
                                    endif
                                  elseif num && sol =~# '^\%(in\%(stanceof\)\=\|\*\)$' &&
                                        \ s:LookingAt() == '}' && s:GetPair('{','}','bW',s:skip_expr) &&
                                        \ s:PreviousToken() == ')' && s:GetPair('(',')','bW',s:skip_expr) &&
                                        \ (s:PreviousToken() == ']' || s:LookingAt() =~ '\k' &&
                                        \ s:{s:PreviousToken() == '*' ? 'Previous' : ''}Token() !=# 'function')
                                    return num_ind + s:sw()
                                  else
                                    let is_op = s:sw()
                                  endif
                                  call cursor(l:lnum, len(pline))
                                  let b_l = s:Nat(s:IsContOne(is_op) - (!is_op && l:line =~ '^{')) * s:sw()
                                endif
                              elseif idx.s:LookingAt().&cino =~ '^-1(.*(' && (search('\m\S','nbW',num) || s:ParseCino('U'))
                                let pval = s:ParseCino('(')
                                if !pval
                                  let [Wval, vcol] = [s:ParseCino('W'), virtcol('.')]
                                  if search('\m\S','W',num)
                                    return s:ParseCino('w') ? vcol : virtcol('.')-1
                                  endif
                                  return Wval ? s:Nat(num_ind + Wval) : vcol
                                endif
                                return s:Nat(num_ind + pval + searchpair('\m(','','\m)','nbrmW',s:skip_expr,num) * s:sw())
                              endif
                            
                              " main return
                              if l:line =~ '^[])}]\|^|}'
                                if l:line_raw[0] == ')'
                                  if s:ParseCino('M')
                                    return indent(l:lnum)
                                  elseif num && &cino =~# 'm' && !s:ParseCino('m')
                                    return virtcol('.') - 1
                                  endif
                                endif
                                return num_ind
                              elseif num
                                return s:Nat(num_ind + get(l:,'case_offset',s:sw()) + l:switch_offset + b_l + is_op)
                              endif
                              return b_l + is_op
                            endfunction
                            
                            let &cpo = s:cpo_save
                            unlet s:cpo_save

SCRIPT  /Users/Ragglesoft/.config/nvim/autoload/plugged/vim-polyglot/after/indent/javascript.vim
Sourced 1 time
Total time:   0.002333
 Self time:   0.000598

count  total (s)   self (s)
                            " Polyglot metafile
    1   0.001325   0.000169 source <sfile>:h/javascript-1.vim
    1   0.000768   0.000188 source <sfile>:h/javascript-2.vim

SCRIPT  /Users/Ragglesoft/.config/nvim/autoload/plugged/vim-polyglot/after/indent/javascript-1.vim
Sourced 1 time
Total time:   0.001126
 Self time:   0.000506

count  total (s)   self (s)
    1   0.000070   0.000049 if polyglot#init#is_disabled(expand('<sfile>:p'), 'jsx', 'after/indent/javascript.vim')
                              finish
    1              0.000001 endif
                            
    1              0.000003 if get(g:, 'vim_jsx_pretty_disable_js', 0)
                              finish
    1              0.000000 endif
                            
    1   0.000759   0.000160 source <sfile>:h/jsx.vim

SCRIPT  /Users/Ragglesoft/.config/nvim/autoload/plugged/vim-polyglot/after/indent/jsx.vim
Sourced 1 time
Total time:   0.000514
 Self time:   0.000490

count  total (s)   self (s)
    1   0.000107   0.000083 if polyglot#init#is_disabled(expand('<sfile>:p'), 'jsx', 'after/indent/jsx.vim')
                              finish
    1              0.000001 endif
                            
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            " Vim indent file
                            "
                            " Language: javascript.jsx
                            " Maintainer: MaxMellon <maxmellon1994@gmail.com>
                            "
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
    1              0.000004 if exists('b:did_indent')
    1              0.000012   let s:did_indent = b:did_indent
    1              0.000003   unlet b:did_indent
    1              0.000001 endif
                            
    1              0.000008 let s:keepcpo = &cpo
    1              0.000009 set cpo&vim
                            
    1              0.000003 if exists('s:did_indent')
    1              0.000002   let b:did_indent = s:did_indent
    1              0.000001 endif
                            
    1              0.000004 setlocal indentexpr=GetJsxIndent()
    1              0.000004 setlocal indentkeys=0.,0{,0},0),0],0?,0\*,0\,,!^F,:,<:>,o,O,e,<>>,=*/
                            
    1              0.000002 function! GetJsxIndent()
                              return jsx_pretty#indent#get(function('GetJavascriptIndent'))
                            endfunction
                            
    1              0.000006 let &cpo = s:keepcpo
    1              0.000009 unlet s:keepcpo

SCRIPT  /Users/Ragglesoft/.config/nvim/autoload/plugged/vim-polyglot/after/indent/javascript-2.vim
Sourced 1 time
Total time:   0.000373
 Self time:   0.000348

count  total (s)   self (s)
    1   0.000098   0.000073 if polyglot#init#is_disabled(expand('<sfile>:p'), 'graphql', 'after/indent/javascript-2.vim')
                              finish
    1              0.000001 endif
                            
                            " Copyright (c) 2016-2021 Jon Parise <jon@indelible.org>
                            "
                            " Permission is hereby granted, free of charge, to any person obtaining a copy
                            " of this software and associated documentation files (the "Software"), to
                            " deal in the Software without restriction, including without limitation the
                            " rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
                            " sell copies of the Software, and to permit persons to whom the Software is
                            " furnished to do so, subject to the following conditions:
                            "
                            " The above copyright notice and this permission notice shall be included in
                            " all copies or substantial portions of the Software.
                            "
                            " THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
                            " IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
                            " FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
                            " AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
                            " LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
                            " FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
                            " IN THE SOFTWARE.
                            "
                            " Language: GraphQL
                            " Maintainer: Jon Parise <jon@indelible.org>
                            
    1              0.000027 if exists('*GetJavascriptGraphQLIndent') && !empty(&indentexpr)
    1              0.000001   finish
                            endif
                            
                            runtime! indent/graphql.vim
                            
                            " Set the indentexpr with our own version that will call GetGraphQLIndent when
                            " we're inside of a GraphQL string and otherwise defer to the base function.
                            let b:indentexpr_base = &indentexpr
                            setlocal indentexpr=GetJavascriptGraphQLIndent()
                            
                            function GetJavascriptGraphQLIndent()
                              let l:stack = map(synstack(v:lnum, 1), "synIDattr(v:val, 'name')")
                              if get(l:stack, 0, '') ==# 'graphqlTemplateString'
                                return GetGraphQLIndent()
                              endif
                            
                              return eval(b:indentexpr_base)
                            endfunction

SCRIPT  /Users/Ragglesoft/.vim/plugged/vim-jsx-pretty/after/indent/javascript.vim
Sourced 1 time
Total time:   0.000315
 Self time:   0.000125

count  total (s)   self (s)
    1              0.000008 if get(g:, 'vim_jsx_pretty_disable_js', 0)
                              finish
    1              0.000001 endif
                            
    1   0.000293   0.000104 source <sfile>:h/jsx.vim

SCRIPT  /Users/Ragglesoft/.vim/plugged/vim-jsx-pretty/after/indent/jsx.vim
Sourced 1 time
Total time:   0.000144
 Self time:   0.000144

count  total (s)   self (s)
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            " Vim indent file
                            "
                            " Language: javascript.jsx
                            " Maintainer: MaxMellon <maxmellon1994@gmail.com>
                            "
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
    1              0.000005 if exists('b:did_indent')
    1              0.000007   let s:did_indent = b:did_indent
    1              0.000002   unlet b:did_indent
    1              0.000001 endif
                            
    1              0.000006 let s:keepcpo = &cpo
    1              0.000008 set cpo&vim
                            
    1              0.000002 if exists('s:did_indent')
    1              0.000002   let b:did_indent = s:did_indent
    1              0.000001 endif
                            
    1              0.000003 setlocal indentexpr=GetJsxIndent()
    1              0.000003 setlocal indentkeys=0.,0{,0},0),0],0?,0\*,0\,,!^F,:,<:>,o,O,e,<>>,=*/
                            
    1              0.000002 function! GetJsxIndent()
                              return jsx_pretty#indent#get(function('GetJavascriptIndent'))
                            endfunction
                            
    1              0.000004 let &cpo = s:keepcpo
    1              0.000002 unlet s:keepcpo

SCRIPT  /Users/Ragglesoft/.vim/plugged/vim-js/syntax/javascript.vim
Sourced 27 times
Total time:   0.203548
 Self time:   0.139062

count  total (s)   self (s)
   27              0.000234 if !exists("main_syntax")
   27              0.000049   if version < 600
                                syntax clear
   27              0.000076   elseif exists("b:current_syntax")
                                finish
   27              0.000018   endif
   27              0.000133   let main_syntax = 'javascript'
   27              0.000020 endif
                            
                            " Dollar sign is permitted anywhere in an identifier
   27              0.000111 if (v:version > 704 || v:version == 704 && has('patch1142')) && main_syntax == 'javascript'
   27              0.000165   syntax iskeyword @,48-57,_,192-255,$
                            else
                              setlocal iskeyword+=$
   27              0.000017 endif
                            
   27              0.000077 syntax sync fromstart
   27              0.000025 syntax case match
                            
                            " Basic tokens
   27              0.000474 syntax keyword jsDebugger debugger
   27              0.000262 syntax match   jsSemicolon +;+
   27              0.000136 syntax match   jsComma +,+ contained
   27              0.000191 syntax match   jsAssignmentColon +:+ contained skipwhite skipempty nextgroup=@jsExpression
   27              0.000154 syntax match   jsAssignmentEqual +=+ contained skipwhite skipempty nextgroup=@jsExpression
   27              0.000424 syntax match   jsPrivateIdentifier +#+ contained nextgroup=jsIdentifierProp,jsFunctionCall
   27              0.000601 syntax match   jsDot +\.+ contained skipwhite skipempty nextgroup=jsPrivateIdentifier,jsIdentifierProp,jsFunctionCall
   27              0.000224 syntax match   jsSpread +\.\.\.+ contained skipwhite skipempty nextgroup=@jsExpression
   27              0.000163 syntax match   jsParensError +[)}\]]+
                            
                            " Code blocks
   27              0.000354 syntax region  jsBlock matchgroup=jsBraces start=+{+ end=+}+ contains=@jsTop extend fold
   27              0.001854 syntax region  jsParen matchgroup=jsParens start=+(+ end=+)+ contains=@jsExpression,jsComma,jsSpread extend fold skipwhite skipempty nextgroup=jsArrow,jsFunctionCallArgs,jsAccessor,jsDot,@jsOperators,jsFlowColon
                            
                            " Operators
                            " REFERENCE: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Expressions_and_Operators
   27              0.000242 syntax keyword jsUnaryOperator delete void typeof skipwhite skipempty nextgroup=@jsExpression
   27              0.000162 syntax keyword jsRelationalOperator in instanceof contained skipwhite skipempty nextgroup=@jsExpression
                            " REFERENCE: https://github.com/tc39/proposal-bind-operator
   27              0.000178 syntax match   jsBindOperator +::+ contained skipwhite skipempty nextgroup=@jsExpression
                            " Arithmetic operators (**, *, %, /)
   27              0.000246 syntax match   jsOperator +\%(\*\*\|[*%]\|/\%([/*]\)\@!\)+ contained skipwhite skipempty nextgroup=@jsExpression
                            " Arithmetic operators (+, ++, -, --)
   27              0.000240 syntax match   jsTopOperator +\%([+-]\{1,2}\)+ skipwhite skipempty nextgroup=@jsExpression
                            " Comparison operators (==, !=, ===, !==, >, >=, <, <=)
   27              0.000189 syntax match   jsOperator +\%([=!]==\?\|[<>]=\?\)+ contained skipwhite skipempty nextgroup=@jsExpression
                            " Bitwise operators (&, |, ^, <<, >>, >>>)
   27              0.000192 syntax match   jsOperator +\%([&^|]\|<<\|>>>\?\)+ contained skipwhite skipempty nextgroup=@jsExpression
                            " Bitwise operators (~)
   27              0.000163 syntax match   jsTopOperator +[~]+ skipwhite skipempty nextgroup=@jsExpression
                            " Logical operators (&&, ||)
   27              0.000174 syntax match   jsOperator +[|&]\{2}+ contained skipwhite skipempty nextgroup=@jsExpression
                            " Logical operators (!)
   27              0.000185 syntax match   jsTopOperator +!+ skipwhite skipempty nextgroup=@jsExpression
                            " Assignment operators (*=, /=, %=, +=, -=, <<=, >>=, >>>=, &=, ^=, |=, **=)
   27              0.000218 syntax match   jsOperator +\%([-/%+&|^]\|<<\|>>>\?\|\*\*\?\)=+ contained skipwhite skipempty nextgroup=@jsExpression
                            " Ternary expression
   27              0.000321 syntax region  jsTernary matchgroup=jsTernaryOperator start=+?+ end=+:+ contained contains=@jsExpression skipwhite skipempty nextgroup=@jsExpression
                            " Optional chaining operator: https://github.com/TC39/proposal-optional-chaining
   27              0.000815 syntax match   jsOptionalOperator +?\.+ contained skipwhite skipempty nextgroup=jsIdentifierProp,jsAccessor,jsFunctionCall,jsFunctionCallArgs 
                            " Nullish coalescing operator: https://github.com/tc39/proposal-nullish-coalescing
   27              0.000180 syntax match   jsOperator +??+ contained skipwhite skipwhite nextgroup=@jsExpression
                            
   27              0.000394 syntax cluster jsTopOperators contains=jsTopOperator,jsUnaryOperator
   27              0.000921 syntax cluster jsOperators contains=jsRelationalOperator,jsTernary,jsOperator,jsTopOperator,jsBindOperator
                            
                            " Modules
                            " REFERENCE:
                            "   - https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import
                            "   - https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/export
   27              0.003093 syntax keyword jsImport import skipwhite skipempty nextgroup=jsModuleName,jsModuleAsterisk,jsModuleBlock,jsString,jsDecoratorName,jsFlowModuleType,jsFlowModuleTypeof
   27              0.001217 syntax keyword jsExport export skipwhite skipempty nextgroup=jsVariableType,jsFunction,jsClass,jsDecorator,jsModuleBlock,jsModuleDefault,jsModuleAsterisk
   27              0.000271 syntax keyword jsFrom from contained skipwhite skipempty nextgroup=jsString
   27              0.000141 syntax keyword jsModuleDefault default contained skipwhite skipempty nextgroup=@jsExpression
   27              0.000477 syntax match   jsModuleAsterisk +\*+ contained skipwhite skipempty nextgroup=jsModuleAs,jsFrom
   27              0.000289 syntax keyword jsModuleAs as contained skipwhite skipempty nextgroup=jsModuleName
   27              0.001032 syntax region  jsModuleBlock matchgroup=jsModuleBraces start=+{+ end=+}+ contained contains=jsModuleName,jsModuleComma,jsComment,jsDecoratorName skipwhite skipempty nextgroup=jsFrom
   27              0.000757 syntax match   jsModuleName +\<\K\k*\>+ contained contains=jsModuleDefault skipwhite skipempty nextgroup=jsFrom,jsModuleComma,jsModuleAs
   27              0.000597 syntax match   jsModuleComma +,+ contained skipwhite skipempty nextgroup=jsModuleBlock,jsModuleName,jsModuleAsterisk
                            
                            " RegExp
   27              0.000807 syntax region  jsRegexp matchgroup=jsRegexpSlashes start=+/+ end=+\%([^\\]\%(\\\\\)*\\\)\@<!/+ contains=@jsRegexpTokens,jsRegexpError nextgroup=jsRegexpFlags
   27              0.000206 syntax match   jsRegexpFlags +[gimsuy]\++ contained
   27              0.000125 syntax match   jsRegexpChars +.+ contained
   27              0.000115 syntax match   jsRegexpError +)+ contained
                            
                            " Escape token
   27              0.000296 syntax match   jsRegexpEscape +\\+ contained nextgroup=jsRegexpChars
                            " Or
   27              0.000126 syntax match   jsRegexpOr +|+ contained
                            " Quantifier tokens (x*, x+, x?, x{n}, x{n,}, x{n,m}, x*?, x+?, x??, x{n}?, x{n,}?, x{n,m}?)
   27              0.000188 syntax match   jsRegexpQuantifier +[*?+]\|{\d\+\%(,\d*\)\?}+ contained
                            " Group back reference (\n)
   27              0.000160 syntax match   jsRegexpGroupReference +\\[1-9]\d*+ contained
                            " Match hyphen (-) inside the range. [a-z], [0-9], but don't match [-a] and [a-]
   27              0.000234 syntax match   jsRegexpRangeHyphen +\[\@1<!-]\@!+ contained
                            " Match caret (^) at the start of the range. [^a-z], don't match [a-z^]
   27              0.000159 syntax match   jsRegexpRangeCaret +\[\@1<=\^+ contained
                            " Match the dot
   27              0.000132 syntax match   jsRegexpDot +\.+ contained
                            " Match all the character classes
   27              0.000318 syntax match   jsRegexpCharClass +\\[bBdDwWsStrnvf0]\|\\c\u\|\\x\x\{2}\|\\u\x\{4}\|\\u{\x\{4,5}}+ contained
                            " Match the boundaries
   27              0.000155 syntax match   jsRegexpBoundaries +[$^]\|\\[Bb]+ contained
                            " Match The unicode range
   27              0.000530 syntax region  jsRegexpUnicode matchgroup=jsRegexpUnicodeBraces start=+\\p{+ end=+}+ contained contains=jsRegexpUnicodeName
   27              0.000376 syntax match   jsRegexpUnicodeName +\K\k*+ contained nextgroup=jsRegexpUnicodeEqual
   27              0.000280 syntax match   jsRegexpUnicodeEqual +=+ contained nextgroup=jsRegexpUnicodeValue
   27              0.000166 syntax match   jsRegexpUnicodeValue +\K\k*+ contained
                            
                            " Match the groups. (x), (?<Name>x), (?:x)
                            " skip=+\\)+ seems not work, so I have to write a complex end pattern
   27              0.000504 syntax region  jsRegexpGroup matchgroup=jsRegexpParens start=+(?<\K\k*>+ start=+(?:+ start=+(+ end=+\%([^\\]\%(\\\\\)*\\\)\@<!)+ contained contains=@jsRegexpTokens
                            " Match the range. [a-b]
   27              0.001080 syntax region  jsRegexpRange matchgroup=jsRegexpBrackets start=+\[+ end=+\%([^\\]\%(\\\\\)*\\\)\@<!]+ contained contains=jsRegexpEscape,jsRegexpChars,jsRegexpCharClass,jsRegexpRangeHyphen,jsRegexpRangeCaret
                            " Match the assertions. x(?=y), x(?!y), (?<=y)x, (?<!y)x
   27              0.000355 syntax region  jsRegexpAssertion matchgroup=jsRegexpAssertionParens start=+(?<\?[=!]+ end=+\%([^\\]\%(\\\\\)*\\\)\@<!)+ contained contains=@jsRegexpTokens
                            
   27              0.001868 syntax cluster jsRegexpTokens contains=jsRegexpChars,jsRegexpGroup,jsRegexpGroupReference,jsRegexpOr,jsRegexpRange,jsRegexpAssertion,jsRegexpBoundaries,jsRegexpQuantifier,jsRegexpEscape,jsRegexpDot,jsRegexpCharClass,jsRegexpUnicode
                            
                            " Comments
                            " Comments can be treat as a special expression which produces nothing, so I added it to the expression cluster
   27              0.000196 syntax keyword jsCommentTodo contained TODO FIXME XXX TBD
   27              0.000447 syntax region  jsComment start=+//+ end=/$/ contains=jsCommentTodo,@Spell extend keepend
   27              0.000706 syntax region  jsComment start=+/\*+  end=+\*/+ contains=jsCommentTodo,@Spell,jsDocTags,jsDocInline fold keepend skipwhite skipempty nextgroup=@jsOperators
   27              0.000199 syntax region  jsHashbangComment start=+^#!+ end=+$+
                            
                            " Declaration
   27              0.000857 syntax keyword jsVariableType const let var skipwhite skipempty nextgroup=jsIdentifier,jsObjectDestructuring,jsArrayDestructuring
                            " Match the top level identifier, e.g., `foo` inside `foo.bar`
   27              0.001558 syntax match   jsIdentifier +\<\K\k*\>+ contains=@jsGlobals,jsTemplateStringTag skipwhite skipempty nextgroup=jsAssignmentEqual,jsComma,jsArrow,jsAccessor,jsDot,jsOptionalOperator,@jsOperators,jsFlowColon
                            " Match the prop identifier, e.g., `bar` inside `foo.bar`
   27              0.001156 syntax match   jsIdentifierProp +\<\K\k*\>+ contained contains=jsTemplateStringTag skipwhite skipempty nextgroup=jsAssignmentEqual,jsComma,jsAccessor,jsDot,jsOptionalOperator,@jsOperators
                            
                            " Strings
   27              0.001079 syntax region  jsString start=+\z(["']\)+ skip=+\\\\\|\\\z1\|\\\n+ end=+\z1+ contains=@Spell skipwhite skipempty nextgroup=jsAccessor,jsDot,@jsOperators,jsFlowColon
   27              0.000399 syntax match   jsTemplateStringTag +\<\K\k*\>\%(\_s*`\)\@=+ skipwhite skipempty nextgroup=jsTemplateString
   27              0.000964 syntax region  jsTemplateString start=+`+ skip=+\\\\\|\\`\|\\\n+ end=+`+ contains=jsTemplateExpression,@Spell skipwhite skipempty nextgroup=jsAccessor,jsDot,@jsOperators,jsFlowColon
   27              0.000369 syntax region  jsTemplateExpression matchgroup=jsTemplateBrace start=+\%([^\\]\%(\\\\\)*\)\@<=${+ end=+}+ contained contains=@jsExpression
                            
                            " Built-in values
                            " REFERENCE: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects
   27              0.000170 syntax keyword jsBuiltinValues undefined null NaN true false Infinity globalThis global contained
   27              0.000144 syntax keyword jsBuiltinValues window document module exports require console arguments contained
                            
                            " Built-in objects
   27              0.000284 syntax keyword jsBuiltinObjects Object Function Boolean Symbol Error EvalError InternalError RangeError ReferenceError SyntaxError TypeError URIError contained
   27              0.000239 syntax keyword jsBuiltinObjects Number BigInt Math Date String RegExp contained
   27              0.000202 syntax keyword jsBuiltinObjects Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array BigInt64Array BigUint64Array contained
   27              0.000138 syntax keyword jsBuiltinObjects Map Set WeakMap WeakSet contained
   27              0.000269 syntax keyword jsBuiltinObjects ArrayBuffer SharedArrayBuffer Atomics DataView JSON contained
   27              0.000154 syntax keyword jsBuiltinObjects Promise Generator GeneratorFunction AsyncFunction Reflect Proxy Intl WebAssembly contained
                            
                            " Built-in functions
   27              0.000197 syntax keyword jsBuiltinFunctions eval uneval isFinite isNaN parseFloat parseInt decodeURI decodeURIComponent encodeURI encodeURIComponent escape unescape require contained
                            
                            " Numbers
                            " REFERENCE: http://www.ecma-international.org/ecma-262/10.0/index.html#prod-NumericLiteral
   27              0.001161 syntax match   jsNumber +\c[+-]\?\%(0b[01]\%(_\?[01]\)*\|0o\o\%(_\?\o\)*\|0x\x\%(_\?\x\)*\|\%(\%(\%(0\|[1-9]\%(_\?\d\%(_\?\d\)*\)\?\)\.\%(\d\%(_\?\d\)*\)\?\|\.\d\%(_\?\d\)*\|\%(0\|[1-9]\%(_\?\d\%(_\?\d\)*\)\?\)\)\%(e[+-]\?\d\%(_\?\d\)*\)\?\)\)+ contains=jsNumberDot,jsNumberSeparator skipwhite skipempty nextgroup=jsAccessor,@jsOperators,jsFlowColon
   27              0.000144 syntax match   jsNumberDot +\.+ contained
   27              0.000189 syntax match   jsNumberSeparator +_+ contained
                            
                            " Array
   27              0.001179 syntax region  jsArray matchgroup=jsBrackets start=+\[+ end=+]+ contains=@jsExpression,jsComma,jsSpread skipwhite skipempty nextgroup=jsAccessor,jsDot,@jsOperators,jsFlowColon
                            
                            " Object
   27              0.002938 syntax region  jsObject matchgroup=jsObjectBraces start=+{+ end=+}+ contained contains=jsComment,jsIdentifier,jsObjectKey,jsObjectKeyString,jsMethod,jsComputed,jsGeneratorAsterisk,jsAsync,jsMethodType,jsComma,jsSpread skipwhite skipempty nextgroup=jsFlowColon
   27              0.000508 syntax match   jsObjectKey +\<\k\+\>\ze\s*:+ contained skipwhite skipempty nextgroup=jsAssignmentColon
   27              0.000583 syntax region  jsObjectKeyString start=+\z(["']\)+ skip=+\\\\\|\\\z1\|\\\n+ end=+\z1+ contained contains=@Spell skipwhite skipempty nextgroup=jsAssignmentColon
                            
                            " Property accessor, e.g., arr[1] or obj["prop"]
   27              0.001117 syntax region  jsAccessor matchgroup=jsAccessorBrackets start=+\[+ end=+]+ contained contains=@jsExpression skipwhite skipempty nextgroup=jsAccessor,jsFunctionCallArgs,jsDot,jsOptionalOperator,@jsOperators,jsFlowColon
                            
                            " Array Destructuring
                            " Cases like [a, b] = [1, 2] and the array destructuring in the arrow function arguments cannot be highlighted
                            " as array destructuring, they are highlighted as Array, but it doesn't break the syntax
   27              0.001533 syntax region  jsArrayDestructuring matchgroup=jsDestructuringBrackets start=+\[+ end=+]+ contained contains=jsComment,jsIdentifier,jsComma,jsSpread,jsObjectDestructuring,jsArrayDestructuring skipwhite skipempty nextgroup=jsAssignmentEqual,jsFlowColon
                            
                            " Object Destructuring
                            " Cases like ({a, b} = {a: 1, b: 2}) and the object destructuring in the arrow function arguments cannot be highlighted
                            " as object destructuring, they are highlighted as Object, but it doesn't break the syntax
   27              0.001638 syntax region  jsObjectDestructuring matchgroup=jsDestructuringBraces start=+{+ end=+}+ contained contains=jsComment,jsObjectDestructuringKey,jsIdentifier,jsComma,jsObjectDestructuring,jsArrayDestructuring,jsSpread skipwhite skipempty nextgroup=jsAssignmentEqual,jsFlowColon
   27              0.000333 syntax match   jsObjectDestructuringKey +\<\K\k*\>\ze\s*:+ contained skipwhite skipempty nextgroup=jsObjectDestructuringColon
   27              0.000662 syntax match   jsObjectDestructuringColon +:+ contained skipwhite skipempty nextgroup=jsIdentifier,jsObjectDestructuring,jsArrayDestructuring
                            
                            " Class
   27              0.000420 syntax keyword jsClass class skipwhite skipempty nextgroup=jsClassName,jsClassBody
   27              0.000269 syntax keyword jsExtends extends contained skipwhite skipempty nextgroup=jsClassName
   27              0.000104 syntax keyword jsConstructor constructor contained
   27              0.000176 syntax keyword jsSuper super contained
   27              0.000636 syntax keyword jsStatic static contained skipwhite skipempty nextgroup=jsClassProp,jsMethod,jsGeneratorAsterisk
   27              0.000756 syntax match   jsClassName +\<\K\k*\%(\.\K\k*\)*\>+ contained skipwhite skipempty nextgroup=jsExtends,jsClassBody,jsFlowGenericDeclare,jsFlowImplments
   27              0.001859 syntax region  jsClassBody matchgroup=jsClassBraces start=+{+ end=+}+ contained contains=jsComment,jsAsync,jsStatic,jsMethodType,jsClassPrivate,jsClassProp,jsMethod,jsGeneratorAsterisk,jsComputed,jsDecoratorName,jsDecoratorParams,jsSemicolon fold
   27              0.000450 syntax match   jsClassProp +\<\K\k*\>+ contained skipwhite skipempty nextgroup=jsAssignmentEqual,jsFlowColon
   27              0.000466 syntax match   jsClassPrivate +#+ contained nextgroup=jsClassProp,jsMethod
                            
   27              0.000333 syntax keyword jsNew new skipwhite skipempty nextgroup=jsNewClassName
   27              0.000596 syntax match   jsNewClassName +\K\k*\%(\.\K\k*\)*+ contained contains=jsNewDot,@jsGlobals skipwhite skipempty nextgroup=jsNewClassArgs,jsFlowGenericCall
   27              0.001216 syntax region  jsNewClassArgs matchgroup=jsNewClassParens start=+(+ end=+)+ contained contains=@jsExpression,jsComma,jsSpread skipwhite skipempty nextgroup=jsAccessor,jsFunctionCallArgs,jsDot,jsOptionalOperator,@jsOperators
   27              0.000114 syntax match   jsNewDot +\.+ contained
                            
                            " Decorator
                            " REFERENCE: https://github.com/tc39/proposal-decorators
   27              0.000286 syntax keyword jsDecorator decorator skipwhite skipempty nextgroup=jsDecoratorName
   27              0.000565 syntax match   jsDecoratorName +@\K\k*\>+ skipwhite skipempty nextgroup=jsDecoratorBlock,jsDecoratorParams,jsFrom
   27              0.000691 syntax region  jsDecoratorBlock matchgroup=jsDecoratorBraces start=+{+ end=+}+ contained contains=jsComment,jsDecoratorName,jsDecoratorParams
   27              0.000690 syntax region  jsDecoratorParams matchgroup=jsDecoratorParens start=+(+ end=+)+ contained contains=@jsExpression,jsComma,jsSpread nextgroup=jsDecoratorBlock
                            
                            " Function
   27              0.000920 syntax keyword jsAsync async skipwhite skipempty nextgroup=jsFunction,jsFunctionArgs,jsGeneratorAsterisk,jsComputed,jsIdentifier,jsMethod
   27              0.000150 syntax keyword jsAwait await skipwhite skipempty nextgroup=@jsExpression
   27              0.000444 syntax keyword jsThis this contained
   27              0.000185 syntax keyword jsReturn return skipwhite skipempty nextgroup=@jsExpression
   27              0.000661 syntax keyword jsFunction function skipwhite skipempty nextgroup=jsGeneratorAsterisk,jsFunctionName,jsFunctionArgs,jsFlowGenericDeclare
   27              0.000560 syntax match   jsFunctionName +\<\K\k*\>+ contained skipwhite skipempty nextgroup=jsFunctionArgs,jsFlowGenericDeclare
   27              0.001577 syntax region  jsFunctionArgs matchgroup=jsFunctionParens start=+(+ end=+)+ contained contains=jsComment,jsIdentifier,jsComma,jsSpread,jsObjectDestructuring,jsArrayDestructuring skipwhite skipempty nextgroup=jsArrow,jsFunctionBody,jsFlowColon fold
   27              0.000307 syntax region  jsFunctionBody matchgroup=jsFunctionBraces start=+{+ end=+}+ contained contains=@jsTop fold
                            
                            " Arrow Function
   27              0.000321 syntax match   jsArrow +=>+ contained skipwhite skipempty nextgroup=@jsExpression,jsFunctionBody
                            
                            " Object method
   27              0.000524 syntax match   jsMethod +\<\K\k*\>\%(\_s*(\)\@=+ contained contains=jsConstructor skipwhite skipempty nextgroup=jsFunctionArgs
   27              0.000303 syntax match   jsMethodType +\<[sg]et\>+ contained skipwhite skipempty nextgroup=jsMethod
                            
                            " Computed property
   27              0.000735 syntax region  jsComputed matchgroup=jsComputedBrackets start=+\[+ end=+]+ contained contains=@jsExpression skipwhite skipempty nextgroup=jsAssignmentEqual,jsFunctionArgs,jsAssignmentColon
                            
                            " Generator
   27              0.000565 syntax match   jsGeneratorAsterisk +\*+ contained skipwhite skipempty nextgroup=jsFunctionName,jsMethod,jsComputed
   27              0.000293 syntax keyword jsYield yield skipwhite skipempty nextgroup=@jsExpression,jsYieldAsterisk
   27              0.000148 syntax match   jsYieldAsterisk +\*+ contained skipwhite skipempty nextgroup=@jsExpression
                            
                            " Function Call
                            " Matches: func(), obj.func(), obj.func?.(), obj.func<Array<number | string>>() etc.
   27              0.001395 syntax match   jsFunctionCall +\<\K\k*\>\%(\_s*<\%(\_[^&|)]\{-1,}\%([&|]\_[^&|)]\{-1,}\)*\)>\)\?\%(\_s*\%(?\.\)\?\_s*(\)\@=+ contains=jsImport,jsSuper,jsBuiltinFunctions,jsFlowGenericCall skipwhite skipempty nextgroup=jsOptionalOperator,jsFunctionCallArgs
   27              0.001729 syntax region  jsFunctionCallArgs matchgroup=jsFunctionParens start=+(+ end=+)+ contained contains=@jsExpression,jsComma,jsSpread skipwhite skipempty nextgroup=jsAccessor,jsFunctionCallArgs,jsDot,jsOptionalOperator,@jsOperators
                            
                            " Loops
   27              0.000518 syntax keyword jsFor for skipwhite skipempty nextgroup=jsLoopCondition,jsForAwait
   27              0.000271 syntax keyword jsForAwait await contained skipwhite skipempty nextgroup=jsLoopCondition
   27              0.000163 syntax keyword jsOf of contained skipwhite skipempty nextgroup=@jsExpression
   27              0.000595 syntax region  jsLoopBlock matchgroup=jsLoopBraces start=+{+ end=+}+ contained contains=@jsTop skipwhite skipempty nextgroup=jsWhile
   27              0.001066 syntax region  jsLoopCondition matchgroup=jsLoopParens start=+(+ end=+)+ contained contains=@jsExpression,jsOf,jsVariableType,jsSemicolon,jsComma skipwhite skipempty nextgroup=jsLoopBlock
                            
   27              0.000267 syntax keyword jsDo do skipwhite skipempty nextgroup=jsLoopBlock
   27              0.000297 syntax keyword jsWhile while skipwhite skipempty nextgroup=jsLoopCondition
                            
   27              0.000282 syntax keyword jsBreak break skipwhite skipempty nextgroup=jsLabelText
   27              0.000308 syntax keyword jsContinue continue skipwhite skipempty nextgroup=jsLabelText
                            
   27              0.000975 syntax match   jsLabel +\<\K\k*\>\_s*:+ contains=jsLabelText skipwhite skipempty nextgroup=jsBlock,jsFor,jsDo,jsWhile
   27              0.000315 syntax match   jsLabelText +\<\K\k*\>+ contained skipwhite skipempty nextgroup=jsLabelColon
   27              0.000130 syntax match   jsLabelColon +:+ contained
                            
                            " Control flow
                            " If statement
   27              0.000534 syntax keyword jsIf if skipwhite skipempty nextgroup=jsIfCondition,jsIfBlock
   27              0.000453 syntax keyword jsElse else contained skipwhite skipempty nextgroup=jsIf,jsIfBlock
   27              0.000433 syntax region  jsIfBlock matchgroup=jsIfBraces start=+{+ end=+}+ contained contains=@jsTop skipwhite skipempty nextgroup=jsElse
   27              0.000715 syntax region  jsIfCondition matchgroup=jsIfParens start=+(+ end=+)+ contained contains=@jsExpression,jsVariableType,jsComma skipwhite skipempty nextgroup=jsIfBlock
                            
                            " Switch statements
   27              0.000297 syntax keyword jsSwitch switch skipwhite skipempty nextgroup=jsSwitchCondition
   27              0.000457 syntax region  jsSwitchBlock matchgroup=jsSwitchBraces start=+{+ end=+}+ contained contains=jsCaseStatement,@jsTop
   27              0.001587 syntax region  jsSwitchCondition matchgroup=jsSwitchParens start=+(+ end=+)+ contained contains=@jsExpression,jsVariableType,jsComma skipwhite skipempty nextgroup=jsSwitchBlock
   27              0.000449 syntax region  jsCaseStatement matchgroup=jsSwitchCase start=+\<\%(case\|default\)\>+ matchgroup=jsSwitchColon end=+:+ contained contains=@jsExpression
                            
                            " Exceptions
   27              0.000260 syntax keyword jsTry try skipwhite skipempty nextgroup=jsExceptionBlock
   27              0.000493 syntax region  jsExceptionBlock matchgroup=jsExceptionBraces start=+{+ end=+}+ contained contains=@jsTop skipwhite skipempty nextgroup=jsCatch,jsFinally
   27              0.000386 syntax keyword jsCatch catch skipwhite skipempty nextgroup=jsExceptionBlock,jsExceptionParams
   27              0.000467 syntax region  jsExceptionParams matchgroup=jsExceptionParens start=+(+ end=+)+ contained contains=@jsExpression skipwhite skipempty nextgroup=jsExceptionBlock
   27              0.000541 syntax keyword jsFinally finally contained skipwhite skipempty nextgroup=jsExceptionBlock
   27              0.000168 syntax keyword jsThrow throw skipwhite skipempty nextgroup=@jsExpression
                            
                            " with statement
   27              0.000259 syntax keyword jsWith with skipwhite skipempty nextgroup=jsWithExpression
   27              0.000862 syntax region  jsWithExpression matchgroup=jsWithParens start=+(+ end=+)+ contained contains=@jsExpression,jsVariableType,jsComma skipwhite skipempty nextgroup=jsBlock
                            
                            " Tokens that appear at the top-level
   27              0.006396 syntax cluster jsTop contains=jsDebugger,jsSemicolon,jsParensError,jsBlock,jsParen,@jsTopOperators,jsImport,jsExport,jsRegexp,jsComment,jsVariableType,jsIdentifier,jsString,jsTemplateString,jsTemplateStringTag,jsNumber,jsArray,jsClass,jsNew,jsDecorator,jsDecoratorName,jsAsync,jsAwait,jsReturn,jsFunction,jsYield,jsFunctionCall,jsFor,jsDo,jsWhile,jsBreak,jsContinue,jsLabel,jsIf,jsSwitch,jsTry,jsThrow,jsWith
                            " Tokens that produce a value
   27              0.003052 syntax cluster jsExpression contains=jsRegexp,jsComment,jsString,jsTemplateString,jsTemplateStringTag,jsNumber,jsArray,jsObject,jsIdentifier,jsAsync,jsAwait,jsYield,jsFunction,jsFunctionCall,jsClass,jsParen,@jsTopOperators,jsBindOperator,jsNew
                            " Tokens that are globally used by JavaScript
   27              0.000840 syntax cluster jsGlobals contains=jsBuiltinValues,jsThis,jsSuper,jsBuiltinObjects
                            
                            " Highlight flow syntax
   27   0.051033   0.005401 silent! source <sfile>:h/extras/flow.vim
                            " Highlight jsodc
   27   0.022939   0.004085 silent! source <sfile>:h/extras/jsdoc.vim
                            
                            " Basics
   27              0.000354 highlight default link jsDebugger Error
   27              0.000310 highlight default link jsSemicolon Operator
   27              0.000273 highlight default link jsComma Operator
   27              0.000281 highlight default link jsAssignmentColon Operator
   27              0.000276 highlight default link jsAssignmentEqual Operator
   27              0.000280 highlight default link jsPrivateIdentifier Type
   27              0.000259 highlight default link jsSpread Operator
   27              0.000263 highlight default link jsParensError Error
   27              0.000256 highlight default link jsBraces Special
   27              0.000243 highlight default link jsParens Special
   27              0.000248 highlight default link jsBrackets Special
                            
                            " Operators
   27              0.000254 highlight default link jsUnaryOperator Keyword
   27              0.000248 highlight default link jsRelationalOperator Keyword
   27              0.000300 highlight default link jsBindOperator Keyword
   27              0.000350 highlight default link jsOperator Operator
   27              0.000164 highlight default link jsTopOperator jsOperator
   27              0.000172 highlight default link jsTernaryOperator jsOperator
   27              0.000154 highlight default link jsDot jsOperator
   27              0.000151 highlight default link jsOptionalOperator jsOperator
                            
                            " Modules
   27              0.000268 highlight default link jsImport PreProc
   27              0.000153 highlight default link jsExport jsImport
   27              0.000147 highlight default link jsFrom jsImport
   27              0.000272 highlight default link jsModuleDefault Keyword
   27              0.000163 highlight default link jsModuleAsterisk jsOperator
   27              0.000144 highlight default link jsModuleAs jsImport
   27              0.000143 highlight default link jsModuleName jsIdentifier
   27              0.000149 highlight default link jsModuleComma jsComma
   27              0.000151 highlight default link jsModuleBraces jsBraces
                            
                            " RegExp
   27              0.000287 highlight default link jsRegexpError Error
   27              0.000246 highlight default link jsRegexpSlashes Special
   27              0.000253 highlight default link jsRegexpFlags Type
   27              0.000258 highlight default link jsRegexpChars String
   27              0.000335 highlight default link jsRegexpQuantifier Keyword
   27              0.000252 highlight default link jsRegexpOr Keyword
   27              0.000265 highlight default link jsRegexpEscape Keyword
   27              0.000271 highlight default link jsRegexpRangeHyphen Keyword
   27              0.000253 highlight default link jsRegexpRangeCaret Keyword
   27              0.000247 highlight default link jsRegexpBoundaries Keyword
   27              0.000296 highlight default link jsRegexpDot Character
   27              0.000261 highlight default link jsRegexpCharClass Type
   27              0.000291 highlight default link jsRegexpUnicodeBraces Keyword
   27              0.000280 highlight default link jsRegexpUnicodeName Type
   27              0.000283 highlight default link jsRegexpUnicodeEqual Special
   27              0.000274 highlight default link jsRegexpUnicodeValue Constant
   27              0.000280 highlight default link jsRegexpParens Type
   27              0.000272 highlight default link jsRegexpGroupReference Keyword
   27              0.000331 highlight default link jsRegexpBrackets Type
   27              0.000280 highlight default link jsRegexpAssertionParens Type
                            
                            " Comments
   27              0.000261 highlight default link jsComment Comment
   27              0.000252 highlight default link jsHashbangComment PreProc
   27              0.000249 highlight default link jsCommentTodo Todo
                            
                            " Declaration
   27              0.000272 highlight default link jsVariableType Type
                            
                            " Strings and Values
   27              0.000260 highlight default link jsString String
   27              0.000362 highlight default link jsTemplateStringTag Identifier
   27              0.000266 highlight default link jsTemplateString String
   27              0.000265 highlight default link jsTemplateBrace Special
   27              0.000246 highlight default link jsBuiltinValues Constant
   27              0.000274 highlight default link jsBuiltinObjects Type
   27              0.000338 highlight default link jsBuiltinFunctions jsFunction
   27              0.000273 highlight default link jsNumber Number
   27              0.000315 highlight default link jsNumberDot Special
   27              0.000291 highlight default link jsNumberSeparator Number
                            
                            " Object
   27              0.000153 highlight default link jsObjectBraces jsBraces
   27              0.000333 highlight default link jsObjectKey Identifier
   27              0.000250 highlight default link jsObjectKeyString String
   27              0.000143 highlight default link jsAccessorBrackets jsBrackets
                            
                            " Destructuring
   27              0.000139 highlight default link jsDestructuringBrackets jsBrackets
   27              0.000148 highlight default link jsDestructuringBraces jsBraces
   27              0.000313 highlight default link jsObjectDestructuringColon Operator
                            
                            " Class
   27              0.000409 highlight default link jsClass Keyword
   27              0.000298 highlight default link jsExtends Keyword
   27              0.000264 highlight default link jsConstructor Keyword
   27              0.000272 highlight default link jsSuper Keyword
   27              0.000397 highlight default link jsStatic Keyword
   27              0.000279 highlight default link jsClassName Identifier
   27              0.000276 highlight default link jsClassProp Identifier
   27              0.000260 highlight default link jsClassPrivate Type
   27              0.000160 highlight default link jsClassBraces jsBraces
   27              0.000243 highlight default link jsNew Keyword
   27              0.000305 highlight default link jsNewClassName Identifier
   27              0.000191 highlight default link jsNewClassParens jsParens
   27              0.000149 highlight default link jsNewDot jsDot
                            
                            " Decorator
   27              0.000271 highlight default link jsDecorator Keyword
   27              0.000291 highlight default link jsDecoratorName Type
   27              0.000158 highlight default link jsDecoratorBraces jsBraces
   27              0.000146 highlight default link jsDecoratorParens jsParens
                            
                            " Function
   27              0.000239 highlight default link jsAsync Keyword
   27              0.000242 highlight default link jsAwait Keyword
   27              0.000238 highlight default link jsYield Keyword
   27              0.000343 highlight default link jsThis Keyword
   27              0.000256 highlight default link jsReturn Keyword
   27              0.000248 highlight default link jsFunction Keyword
   27              0.000276 highlight default link jsFunctionName Function
   27              0.000266 highlight default link jsFunctionParens jsParens
   27              0.000149 highlight default link jsFunctionBraces jsBraces
   27              0.000253 highlight default link jsArrow Keyword
   27              0.000268 highlight default link jsMethodType Type
   27              0.000147 highlight default link jsMethod jsFunctionName
                            
   27              0.000148 highlight default link jsComputedBrackets jsBrackets
                            
                            " Generator
   27              0.000154 highlight default link jsGeneratorAsterisk jsOperator
   27              0.000148 highlight default link jsYieldAsterisk jsOperator
                            
                            " Function call
   27              0.000411 highlight default link jsFunctionCall Function
                            
                            " Loops
   27              0.000269 highlight default link jsFor Keyword
   27              0.000140 highlight default link jsForAwait jsAwait
   27              0.000275 highlight default link jsOf Keyword
   27              0.000251 highlight default link jsDo Keyword
   27              0.000291 highlight default link jsWhile Keyword
   27              0.000168 highlight default link jsLoopParens jsParens
   27              0.000139 highlight default link jsLoopBraces jsBraces
   27              0.000261 highlight default link jsLabelText Identifier
   27              0.000180 highlight default link jsLabelColon jsOperator
   27              0.000278 highlight default link jsBreak Keyword
   27              0.000248 highlight default link jsContinue Keyword
                            
                            " Conditional Statements
   27              0.000241 highlight default link jsIf Keyword
   27              0.000254 highlight default link jsElse Keyword
   27              0.000157 highlight default link jsIfParens jsParens
   27              0.000140 highlight default link jsIfBraces jsBraces
   27              0.000331 highlight default link jsSwitch Keyword
   27              0.000152 highlight default link jsSwitchParens jsParens
   27              0.000141 highlight default link jsSwitchBraces jsBraces
   27              0.000239 highlight default link jsSwitchCase Keyword
   27              0.000159 highlight default link jsSwitchColon jsOperator
                            
                            " Exceptions
   27              0.000307 highlight default link jsTry Keyword
   27              0.000345 highlight default link jsCatch Keyword
   27              0.000256 highlight default link jsFinally Keyword
   27              0.000240 highlight default link jsThrow Keyword
   27              0.000185 highlight default link jsExceptionParens jsParens
   27              0.000139 highlight default link jsExceptionBraces jsBraces
                            
                            " with statement
   27              0.000258 highlight default link jsWith Keyword
   27              0.000143 highlight default link jsWithParens jsParens
                            
   27              0.000177 let b:current_syntax = "javascript"
   27              0.000137 if main_syntax == 'javascript'
   27              0.000188   unlet main_syntax
   27              0.000147 endif

SCRIPT  /Users/Ragglesoft/.vim/plugged/vim-js/syntax/extras/flow.vim
Sourced 27 times
Total time:   0.044950
 Self time:   0.044950

count  total (s)   self (s)
                            " Flow syntax highlighting
                            " Syntax groups for flow module
   27              0.000826 syntax keyword jsFlowModuleType type contained skipwhite skipempty nextgroup=jsFlowModuleTypeName,jsFlowModuleBlock
   27              0.000747 syntax match   jsFlowModuleTypeName +\<\K\k*\>+ contained skipwhite skipempty nextgroup=jsFlowModuleComma,jsFrom
   27              0.000409 syntax match   jsFlowModuleComma +,+ contained skipwhite skipempty nextgroup=jsFlowModuleBlock,jsFlowModuleTypeName
   27              0.000678 syntax region  jsFlowModuleBlock matchgroup=jsFlowModuleBraces start=+{+ end=+}+ contained contains=jsFlowModuleTypeName,jsFlowModuleComma skipwhite skipempty nextgroup=jsFrom
   27              0.000537 syntax keyword jsFlowModuleTypeof typeof contained skipwhite skipempty nextgroup=jsModuleName,jsModuleBlock,jsFlowModuleAsterisk
   27              0.000258 syntax match   jsFlowModuleAsterisk +\*+ contained skipwhite skipempty nextgroup=jsFlowModuleAs
   27              0.000276 syntax keyword jsFlowModuleAs as contained skipwhite skipempty nextgroup=jsFlowModuleTypeName
                            
   27              0.000730 syntax match   jsFlowColon +?\?:+ contained skipwhite skipempty nextgroup=@jsFlowTypes,jsFlowMaybe,jsFlowArrayShorthand,jsFlowChecks,jsFlowGenericContained
   27              0.000162 syntax match   jsFlowMaybe +?+ contained skipwhite skipempty nextgroup=@jsFlowTypes
   27              0.000183 syntax match   jsFlowUnion +|+ contained skipwhite skipempty nextgroup=@jsFlowTypes
   27              0.000143 syntax match   jsFlowIntersection +&+ contained skipwhite skipempty nextgroup=@jsFlowTypes
   27              0.000265 syntax match   jsFlowChecks +%checks+ contained skipwhite skipempty nextgroup=jsFunctionBody
   27              0.000174 syntax match   jsFlowArrow +=>+ contained skipwhite skipempty nextgroup=@jsFlowTypes
   27              0.000379 syntax match   jsFlowModifier +[+-]+ contained skipwhite skipempty nextgroup=jsFlowKey,jsFlowIndexer
   27              0.000153 syntax keyword jsFlowTypeof typeof contained skipwhite skipempty nextgroup=@jsExpression
                            
                            " Tokens that can appear after a flow type
   27              0.000499 syntax cluster jsFlowTokensAfterType contains=jsAssignmentEqual,jsFlowUnion,jsFlowIntersection
                            
   27              0.001351 syntax match   jsFlowType +\<\K\k*\>+ contained contains=jsFlowPrimitives,jsFlowSpecialType,jsFlowUtility skipwhite skipempty nextgroup=@jsFlowTokensAfterType,jsFunctionBody,jsArrow,jsFlowGenericContained,jsFlowArrayShorthand,jsFlowChecks,jsFlowColon
   27              0.000189 syntax keyword jsFlowPrimitives boolean Boolean number Number string String null void contained
   27              0.000151 syntax keyword jsFlowSpecialType mixed any Object Function contained
   27              0.000163 syntax match   jsFlowUtility +$\K\k*+ contained
                            
   27              0.000149 syntax keyword jsFlowBoolean true false contained skipwhite skipempty nextgroup=@jsFlowTokensAfterType
   27              0.000344 syntax region  jsFlowString start=+\z(["']\)+ skip=+\\\\\|\\\z1\|\\\n+ end=+\z1+ contained skipwhite skipempty nextgroup=@jsFlowTokensAfterType
   27              0.000787 syntax match   jsFlowNumber +\c-\?\%(0b[01]\%(_\?[01]\)*\|0o\o\%(_\?\o\)*\|0x\x\%(_\?\x\)*\|\%(\%(\%(0\|[1-9]\%(_\?\d\%(_\?\d\)*\)\?\)\.\%(\d\%(_\?\d\)*\)\?\|\.\d\%(_\?\d\)*\|\%(0\|[1-9]\%(_\?\d\%(_\?\d\)*\)\?\)\)\%(e[+-]\?\d\%(_\?\d\)*\)\?\)\)+ contained contains=jsNumberDot,jsNumberSeparator skipwhite skipempty nextgroup=@jsFlowTokensAfterType
                            
                            " Generic used after function name or class name
   27              0.001118 syntax region  jsFlowGenericDeclare matchgroup=jsFlowAngleBrackets start=+<+ end=+>+ contained contains=@jsFlowTypes,jsFlowMaybe,jsComma skipwhite skipempty nextgroup=jsFunctionArgs,jsClassBody,jsExtends,jsFlowImplments
                            " Generic used after new Class or function call
   27              0.000718 syntax region  jsFlowGenericCall matchgroup=jsFlowAngleBrackets start=+<+ end=+>+ contained contains=@jsFlowTypes,jsFlowMaybe,jsComma skipwhite skipempty nextgroup=jsNewClassArgs
                            " Generic used elsewhere
   27              0.001044 syntax region  jsFlowGenericContained matchgroup=jsFlowAngleBrackets start=+<+ end=+>+ contained contains=@jsFlowTypes,jsFlowMaybe,jsComma,jsFlowGenericContained skipwhite skipempty nextgroup=@jsFlowTokensAfterType,jsFlowParen,jsFlowChecks
                            
   27              0.000252 syntax keyword jsFlowArray Array contained skipwhite skipempty nextgroup=jsFlowGenericContained
   27              0.000318 syntax match   jsFlowArrayShorthand contained +\[\_s*]+ skipwhite skipempty nextgroup=@jsFlowTokensAfterType,jsFlowChecks
   27              0.000740 syntax region  jsFlowTuple matchgroup=jsFlowBrackets start=+\[+ end=+]+ contained contains=jsComma,jsComment,@jsFlowTypes skipwhite skipempty nextgroup=@jsFlowTokensAfterType,jsFlowChecks
                            
   27              0.001336 syntax region  jsFlowObject matchgroup=jsFlowBraces start=+{|\?+ end=+|\?}+ contained contains=jsFlowModifier,jsFlowKey,jsComma,jsSemicolon,@jsFlowTypes,jsFlowIndexer,jsComment,jsFlowSpread skipwhite skipempty nextgroup=@jsFlowTokensAfterType,jsFlowChecks
   27              0.000576 syntax match   jsFlowKey +\<\K\k*\>+ contained skipwhite skipempty nextgroup=jsFlowColon,jsFlowGenericContained,jsFlowParen
   27              0.000574 syntax region  jsFlowIndexer matchgroup=jsFlowBrackets start=+\[+ end=+]+ contained contains=jsFlowIndexerKey,@jsFlowTypes skipwhite skipempty nextgroup=jsFlowColon
   27              0.000298 syntax match   jsFlowIndexerKey +\<\K\k*\>\ze\s*?\?:+ contained skipwhite skipempty nextgroup=jsFlowColon
   27              0.000236 syntax match   jsFlowSpread +\.\.\.+ contained skipwhite skipempty nextgroup=jsFlowType
                            
   27              0.001235 syntax region  jsFlowParen matchgroup=jsFlowParens start=+(+ end=+)+ contained contains=jsFlowMaybe,@jsFlowTypes,jsFlowParameter,jsSpread,jsComment skipwhite skipempty nextgroup=jsFlowArrayShorthand,jsFlowArrow,jsFlowColon
   27              0.000307 syntax match   jsFlowParameter +\<\K\k*\>\ze\s*?\?:+ contained skipwhite skipempty nextgroup=jsFlowColon
                            
   27              0.000938 syntax keyword jsFlowDeclare declare skipwhite skipempty nextgroup=jsFlowModuleDeclare,jsClass,jsFunction,jsVariableType,jsExport
   27              0.000281 syntax keyword jsFlowModuleDeclare module contained skipwhite skipempty nextgroup=jsFlowModuleName
   27              0.000413 syntax region  jsFlowModuleName start=+\z(["']\)+  skip=+\\\%(\z1\|$\)+  end=+\z1+ contained skipwhite skipempty nextgroup=jsFlowModuleBody
   27              0.000443 syntax region  jsFlowModuleBody matchgroup=jsFlowBraces start=+{+ end=+}+ contained contains=jsComment,@jsFlowTop
                            
   27              0.000284 syntax keyword jsFlowOpaque opaque skipwhite skipempty nextgroup=jsFlowAliasType
   27              0.000247 syntax keyword jsFlowAliasType type skipwhite skipempty nextgroup=jsFlowAliasName
   27              0.000540 syntax match   jsFlowAliasName +\<\K\k*\>+ contained skipwhite skipempty nextgroup=jsFlowAliasEqual,jsFlowGenericAlias,jsFlowAliasSubtyping
   27              0.000642 syntax region  jsFlowGenericAlias matchgroup=jsFlowAngleBrackets start=+<+ end=+>+ contained contains=@jsFlowTypes,jsFlowMaybe skipwhite skipempty nextgroup=jsFlowAliasEqual,jsFlowAliasSubtyping
   27              0.000475 syntax region  jsFlowAliasSubtyping matchgroup=jsFlowColon start=+:+ matchgroup=jsFlowAliasEqual end=+=+ end=+\ze\%(;\|$\)+ contained contains=@jsFlowTypes skipwhite skipempty nextgroup=@jsFlowTypes
   27              0.000633 syntax match   jsFlowAliasEqual +=+ contained skipwhite skipempty nextgroup=@jsFlowTypes,jsFlowUnion,jsFlowIntersection,jsFlowMaybe,jsFlowGenericContained
                            
   27              0.000434 syntax keyword jsFlowInterface interface skipwhite skipempty nextgroup=jsFlowInterfaceName,jsFlowGenericInterface
   27              0.000373 syntax match   jsFlowInterfaceName +\<\K\k*\>+ contained skipwhite skipempty nextgroup=jsFlowInterfaceBody,jsFlowGenericInterface
   27              0.000622 syntax region  jsFlowGenericInterface matchgroup=jsFlowAngleBrackets start=+<+ end=+>+ contained contains=@jsFlowTypes,jsFlowMaybe skipwhite skipempty nextgroup=jsFlowInterfaceBody
   27              0.000998 syntax region  jsFlowInterfaceBody matchgroup=jsFlowBraces start=+{+ end=+}+ contained contains=jsFlowKey,jsFlowIndexer,jsFlowGenericContained,jsSemicolon,jsComment,jsFlowModifier
                            
   27              0.000254 syntax keyword jsFlowImplments implements contained skipwhite skipempty nextgroup=jsFlowImplmentsName
   27              0.000381 syntax match   jsFlowImplmentsName +\<\K\k*\>+ contained skipwhite skipempty nextgroup=jsFlowImplmentsComma,jsClassBody
   27              0.000227 syntax match   jsFlowImplmentsComma +,+ contained skipwhite skipempty nextgroup=jsFlowImplmentsName
                            
   27              0.000353 syntax region  jsComment matchgroup=jsFlowComment start=+/\*:+  end=+\*/+ contains=@jsFlowTypes fold
   27              0.000800 syntax region  jsComment matchgroup=jsFlowComment start=+/\*\%(::\|flow-include\)+  end=+\*/+ contains=@jsFlowTop,jsFlowColon,jsSemicolon,jsFlowParameter fold
                            
   27              0.000534 syntax cluster jsFlowTop contains=jsFlowDeclare,jsFlowAliasType,jsFlowOpaque,jsFlowInterface
   27              0.001168 syntax cluster jsFlowTypes contains=jsFlowType,jsFlowBoolean,jsFlowString,jsFlowNumber,jsFlowObject,jsFlowArray,jsFlowTuple,jsFlowParen,jsFlowTypeof
   27              0.000244 syntax cluster jsTop add=@jsFlowTop
                            
                            " Flow syntax
   27              0.000807 highlight default link jsFlowColon Operator
   27              0.000475 highlight default link jsFlowMaybe Operator
   27              0.000455 highlight default link jsFlowUnion Operator
   27              0.000423 highlight default link jsFlowIntersection Operator
                            
   27              0.000612 highlight default link jsFlowType Type
   27              0.000323 highlight default link jsFlowPrimitives Type
   27              0.000274 highlight default link jsFlowSpecialType Type
   27              0.000275 highlight default link jsFlowUtility PreProc
   27              0.000319 highlight default link jsFlowBoolean Constant
   27              0.000362 highlight default link jsFlowString String
   27              0.000414 highlight default link jsFlowNumber Number
                            
   27              0.000289 highlight default link jsFlowKey Identifier
   27              0.000326 highlight default link jsFlowSpread Special
   27              0.000328 highlight default link jsFlowIndexerKey Identifier
   27              0.000295 highlight default link jsFlowArray Type
   27              0.000282 highlight default link jsFlowArrayShorthand Special
   27              0.000264 highlight default link jsFlowAngleBrackets Special
   27              0.000271 highlight default link jsFlowBrackets Special
   27              0.000268 highlight default link jsFlowBraces Special
   27              0.000258 highlight default link jsFlowParens Special
   27              0.000257 highlight default link jsFlowArrow Special
   27              0.000266 highlight default link jsFlowChecks Special
   27              0.000247 highlight default link jsFlowTypeof Keyword
                            
   27              0.000325 highlight default link jsFlowDeclare Keyword
   27              0.000256 highlight default link jsFlowModuleDeclare Keyword
   27              0.000277 highlight default link jsFlowModuleName String
   27              0.000269 highlight default link jsFlowOpaque PreProc
   27              0.000264 highlight default link jsFlowAliasType Keyword
   27              0.000268 highlight default link jsFlowAliasName Type
   27              0.000308 highlight default link jsFlowAliasEqual Operator
                            
   27              0.000265 highlight default link jsFlowInterface Keyword
   27              0.000270 highlight default link jsFlowInterfaceName Type
   27              0.000293 highlight default link jsFlowImplments Keyword
   27              0.000266 highlight default link jsFlowImplmentsName Type
   27              0.000272 highlight default link jsFlowImplmentsComma Operator
   27              0.000272 highlight default link jsFlowModifier Operator
                            
   27              0.000274 highlight default link jsFlowModuleType Keyword
   27              0.000360 highlight default link jsFlowModuleTypeName Type
   27              0.000166 highlight default link jsFlowModuleComma jsComma
   27              0.000131 highlight default link jsFlowModuleBraces jsModuleBrace
   27              0.000302 highlight default link jsFlowModuleTypeof Keyword
   27              0.000281 highlight default link jsFlowModuleAsterisk Operator
   27              0.000275 highlight default link jsFlowModuleAs Keyword
   27              0.000359 highlight default link jsFlowComment Comment

SCRIPT  /Users/Ragglesoft/.vim/plugged/vim-js/syntax/extras/jsdoc.vim
Sourced 27 times
Total time:   0.018249
 Self time:   0.018249

count  total (s)   self (s)
                            " JSDoc
   27              0.000673 syntax match   jsDocTags +@\%(abstract\|virtual\|async\|classdesc\|description\|desc\|file\|fileoverview\|overview\|generator\|global\|hideconstructor\|ignore\|inheritdoc\|inner\|instance\|override\|readonly\|static\|summary\|todo\)\>+ contained
   27              0.000399 syntax match   jsDocTags +@access\>+ contained skipwhite nextgroup=jsDocAccessTypes
   27              0.000133 syntax keyword jsDocAccessTypes package private protected public contained
                            
   27              0.000433 syntax match   jsDocTags +@\%(alias\|augments\|extends\|borrows\|callback\|constructs\|external\|function\|func\|method\|interface\|mixin\|host\|lends\|memberof!\?\|mixes\|name\|this\|tutorial\)+ contained skipwhite nextgroup=jsDocNamepath
   27              0.000258 syntax match   jsDocNamepath +[^[:blank:]*]\++ contained skipwhite nextgroup=jsDocAs
   27              0.000226 syntax keyword jsDocAs as contained skipwhite nextgroup=jsDocNamepath
                            
   27              0.000279 syntax match   jsDocTags +@author\>+ contained skipwhite nextgroup=jsDocAuthorName
   27              0.000225 syntax match   jsDocAuthorName +[^<>]\++ contained skipwhite nextgroup=jsDocAuthorMail
   27              0.000228 syntax region  jsDocAuthorMail matchgroup=jsDocAngleBrackets start=+<+ end=+>+ contained
                            
   27              0.000484 syntax match   jsDocTags +@\%(class\|constructor\|constant\|const\|enum\|implements\|member\|var\|package\|private\|protected\|public\|type\)\>+ contained skipwhite nextgroup=jsDocTypeBlock,jsDocIdentifier
                            
   27              0.000331 syntax match   jsDocTags +@\%(copyright\|deprecated\|license\|since\|variation\|version\)\>+ contained skipwhite nextgroup=jsDocImportant
   27              0.000118 syntax match   jsDocImportant +.\++ contained
                            
   27              0.000260 syntax match   jsDocTags +@\%(default\|defaultValue\)\>+ contained skipwhite nextgroup=jsDocValue
   27              0.000582 syntax match   jsDocValue +.\++ contained
                            
   27              0.000332 syntax match   jsDocTags +@\%(event\|fires\|emits\|listens\)\>+ contained skipwhite nextgroup=jsDocEvent
   27              0.000119 syntax match   jsDocEvent +[^[:blank:]*]\++ contained
                            
   27              0.000343 syntax match   jsDocTags +@example\>+ contained skipwhite skipempty nextgroup=jsDocExample,jsDocCaption
   27              0.000372 syntax region  jsDocCaption matchgroup=jsDocCaptionTag start=+<caption>+ end=+</caption>+ contained skipwhite skipempty nextgroup=jsDocExample
   27              0.000440 syntax region  jsDocExample matchgroup=jsDocExampleBoundary start=+\*\%([*/]\|\s*@\)\@!+ end=+$+ contained contains=TOP keepend skipwhite skipempty nextgroup=jsDocExample
                            
   27              0.000314 syntax match   jsDocTags +@\%(exports\|requires\)\>+ contained skipwhite nextgroup=jsDocModuleName
   27              0.000170 syntax match   jsDocModuleName +\%(module:\)\?\K\k*\%([/.#]\K\k*\)*+ contained
                            
   27              0.000245 syntax match   jsDocTags +@kind\>+ contained skipwhite nextgroup=jsDocKinds
   27              0.000195 syntax keyword jsDocKinds class constant event external file function member mixin module namespace typedef contained
                            
   27              0.000509 syntax match   jsDocTags +@\%(module\|namespace\|param\|arg\|argument\|prop\|property\|typedef\)\>+ contained skipwhite nextgroup=jsDocTypeBlock,jsDocModuleName
   27              0.000369 syntax match   jsDocTags +@\%(returns\|return\|throws\|exception\|yields\|yield\)\>+ contained skipwhite nextgroup=jsDocReturnTypeBlock
   27              0.000451 syntax match   jsDocTags +@\%(see\)\>+ contained skipwhite nextgroup=jsDocNamepath,jsDocInline
                            
   27              0.000455 syntax region  jsDocTypeBlock matchgroup=jsDocBraces start=+{+ end=+}+ contained keepend contains=jsDocType skipwhite nextgroup=jsDocIdentifier
   27              0.000359 syntax region  jsDocReturnTypeBlock matchgroup=jsDocBraces start=+{+ end=+}+ contained keepend contains=jsDocType
   27              0.000150 syntax match   jsDocType +[^[:blank:]*]\++ contained
   27              0.000306 syntax match   jsDocIdentifier +\[\?\K\k*\%(\%(\[]\)\?\.\K\k*\)*\%(=[^]]\+\)\?]\?+ contained skipwhite nextgroup=jsDocHyphen
   27              0.000097 syntax match   jsDocHyphen +-+ contained
                            
   27              0.000412 syntax region  jsDocInline matchgroup=jsDocBraces start=+{@\@=+ end=+}+ contained contains=jsDocTagsInline keepend
   27              0.000288 syntax match   jsDocTagsInline +@\%(link\|linkcode\|linkplain\|tutorial\)\>+ contained skipwhite nextgroup=jsDocLinkPath
   27              0.000233 syntax match   jsDocLinkPath +[^[:blank:]|]\++ contained skipwhite nextgroup=jsDocLinkSeparator
   27              0.000216 syntax match   jsDocLinkSeparator +[[:blank:]|]+ contained skipwhite nextgroup=jsDocLinkText
   27              0.000120 syntax match   jsDocLinkText +[^|]\++ contained
                            
   27              0.000540 highlight default link jsDocBraces Special
   27              0.000333 highlight default link jsDocTags Keyword
   27              0.000280 highlight default link jsDocAccessTypes Type
   27              0.000647 highlight default link jsDocAuthorName String
   27              0.000276 highlight default link jsDocAuthorMail String
   27              0.000257 highlight default link jsDocImportant String
   27              0.000253 highlight default link jsDocValue Constant
   27              0.000240 highlight default link jsDocCaption String
   27              0.000244 highlight default link jsDocCaptionTag Type
   27              0.000235 highlight default link jsDocKinds Keyword
   27              0.000172 highlight default link jsDocExampleBoundary jsComment
   27              0.000242 highlight default link jsDocNamepath Identifier
   27              0.000305 highlight default link jsDocIdentifier Identifier
   27              0.000272 highlight default link jsDocModuleName Identifier
   27              0.000242 highlight default link jsDocEvent Identifier
                            
   27              0.000234 highlight default link jsDocAngleBrackets Special
   27              0.000222 highlight default link jsDocHyphen Special
                            
   27              0.000207 highlight default link jsDocTagsInline jsDocTags
   27              0.000283 highlight default link jsDocLinkPath String
   27              0.000121 highlight default link jsDocLinkSeparator jsDocBraces
   27              0.000231 highlight default link jsDocLinkText Identifier
                            
   27              0.000219 highlight default link jsDocAs Keyword
   27              0.000365 highlight default link jsDocType Type

SCRIPT  /Users/Ragglesoft/.config/nvim/autoload/plugged/vim-polyglot/syntax/javascript.vim
Sourced 27 times
Total time:   0.003128
 Self time:   0.002414

count  total (s)   self (s)
   27   0.001654   0.000941 if polyglot#init#is_disabled(expand('<sfile>:p'), 'javascript', 'syntax/javascript.vim')
                              finish
   27              0.000018 endif
                            
                            " Vim syntax file
                            " Language:     JavaScript
                            " Maintainer:   vim-javascript community
                            " URL:          https://github.com/pangloss/vim-javascript
                            
   27              0.000112 if !exists("main_syntax")
   27              0.000059   if version < 600
                                syntax clear
   27              0.000076   elseif exists("b:current_syntax")
   27              0.000025     finish
                              endif
                              let main_syntax = 'javascript'
                            endif
                            
                            " Dollar sign is permitted anywhere in an identifier
                            if (v:version > 704 || v:version == 704 && has('patch1142')) && main_syntax == 'javascript'
                              syntax iskeyword @,48-57,_,192-255,$
                            else
                              setlocal iskeyword+=$
                            endif
                            
                            syntax sync fromstart
                            " TODO: Figure out what type of casing I need
                            " syntax case ignore
                            syntax case match
                            
                            syntax match   jsNoise          /[:,;]/
                            syntax match   jsDot            /\./ skipwhite skipempty nextgroup=jsObjectProp,jsFuncCall,jsPrototype,jsTaggedTemplate
                            syntax match   jsObjectProp     contained /\<\K\k*/
                            syntax match   jsFuncCall       /\<\K\k*\ze\s*(/
                            syntax match   jsParensError    /[)}\]]/
                            
                            " Program Keywords
                            syntax keyword jsStorageClass   const var let skipwhite skipempty nextgroup=jsDestructuringBlock,jsDestructuringArray,jsVariableDef
                            syntax match   jsVariableDef    contained /\<\K\k*/ skipwhite skipempty nextgroup=jsFlowDefinition
                            syntax keyword jsOperatorKeyword delete instanceof typeof void new in of skipwhite skipempty nextgroup=@jsExpression
                            syntax match   jsOperator       "[-!|&+<>=%/*~^]" skipwhite skipempty nextgroup=@jsExpression
                            syntax match   jsOperator       /::/ skipwhite skipempty nextgroup=@jsExpression
                            syntax keyword jsBooleanTrue    true
                            syntax keyword jsBooleanFalse   false
                            
                            " Modules
                            syntax keyword jsImport                       import skipwhite skipempty nextgroup=jsModuleAsterisk,jsModuleKeyword,jsModuleGroup,jsFlowImportType
                            syntax keyword jsExport                       export skipwhite skipempty nextgroup=@jsAll,jsModuleGroup,jsExportDefault,jsModuleAsterisk,jsModuleKeyword,jsFlowTypeStatement
                            syntax match   jsModuleKeyword      contained /\<\K\k*/ skipwhite skipempty nextgroup=jsModuleAs,jsFrom,jsModuleComma
                            syntax keyword jsExportDefault      contained default skipwhite skipempty nextgroup=@jsExpression
                            syntax keyword jsExportDefaultGroup contained default skipwhite skipempty nextgroup=jsModuleAs,jsFrom,jsModuleComma
                            syntax match   jsModuleAsterisk     contained /\*/ skipwhite skipempty nextgroup=jsModuleKeyword,jsModuleAs,jsFrom
                            syntax keyword jsModuleAs           contained as skipwhite skipempty nextgroup=jsModuleKeyword,jsExportDefaultGroup
                            syntax keyword jsFrom               contained from skipwhite skipempty nextgroup=jsString
                            syntax match   jsModuleComma        contained /,/ skipwhite skipempty nextgroup=jsModuleKeyword,jsModuleAsterisk,jsModuleGroup,jsFlowTypeKeyword
                            
                            " Strings, Templates, Numbers
                            syntax region  jsString           start=+\z(["']\)+  skip=+\\\%(\z1\|$\)+  end=+\z1+ end=+$+  contains=jsSpecial extend
                            syntax region  jsTemplateString   start=+`+  skip=+\\`+  end=+`+     contains=jsTemplateExpression,jsSpecial extend
                            syntax match   jsTaggedTemplate   /\<\K\k*\ze`/ nextgroup=jsTemplateString
                            syntax match   jsNumber           /\c\<\%(\d\+\%(e[+-]\=\d\+\)\=\|0b[01]\+\|0o\o\+\|0x\%(\x\|_\)\+\)n\=\>/
                            syntax keyword jsNumber           Infinity
                            syntax match   jsFloat            /\c\<\%(\d\+\.\d\+\|\d\+\.\|\.\d\+\)\%(e[+-]\=\d\+\)\=\>/
                            
                            " Regular Expressions
                            syntax match   jsSpecial            contained "\v\\%(x\x\x|u%(\x{4}|\{\x{4,5}})|c\u|.)"
                            syntax region  jsTemplateExpression contained matchgroup=jsTemplateBraces start=+${+ end=+}+ contains=@jsExpression keepend
                            syntax region  jsRegexpCharClass    contained start=+\[+ skip=+\\.+ end=+\]+ contains=jsSpecial extend
                            syntax match   jsRegexpBoundary     contained "\v\c[$^]|\\b"
                            syntax match   jsRegexpBackRef      contained "\v\\[1-9]\d*"
                            syntax match   jsRegexpQuantifier   contained "\v[^\\]%([?*+]|\{\d+%(,\d*)?})\??"lc=1
                            syntax match   jsRegexpOr           contained "|"
                            syntax match   jsRegexpMod          contained "\v\(\?[:=!>]"lc=1
                            syntax region  jsRegexpGroup        contained start="[^\\]("lc=1 skip="\\.\|\[\(\\.\|[^]]\+\)\]" end=")" contains=jsRegexpCharClass,@jsRegexpSpecial keepend
                            syntax region  jsRegexpString   start=+\%(\%(\<return\|\<typeof\|\_[^)\]'"[:blank:][:alnum:]_$]\)\s*\)\@<=/\ze[^*/]+ skip=+\\.\|\[[^]]\{1,}\]+ end=+/[gimyus]\{,6}+ contains=jsRegexpCharClass,jsRegexpGroup,@jsRegexpSpecial oneline keepend extend
                            syntax cluster jsRegexpSpecial    contains=jsSpecial,jsRegexpBoundary,jsRegexpBackRef,jsRegexpQuantifier,jsRegexpOr,jsRegexpMod
                            
                            " Objects
                            syntax match   jsObjectShorthandProp contained /\<\k*\ze\s*/ skipwhite skipempty nextgroup=jsObjectSeparator
                            syntax match   jsObjectKey         contained /\<\k*\ze\s*:/ contains=jsFunctionKey skipwhite skipempty nextgroup=jsObjectValue
                            syntax region  jsObjectKeyString   contained start=+\z(["']\)+  skip=+\\\%(\z1\|$\)+  end=+\z1\|$+  contains=jsSpecial skipwhite skipempty nextgroup=jsObjectValue
                            syntax region  jsObjectKeyComputed contained matchgroup=jsBrackets start=/\[/ end=/]/ contains=@jsExpression skipwhite skipempty nextgroup=jsObjectValue,jsFuncArgs extend
                            syntax match   jsObjectSeparator   contained /,/
                            syntax region  jsObjectValue       contained matchgroup=jsObjectColon start=/:/ end=/[,}]\@=/ contains=@jsExpression extend
                            syntax match   jsObjectFuncName    contained /\<\K\k*\ze\_s*(/ skipwhite skipempty nextgroup=jsFuncArgs
                            syntax match   jsFunctionKey       contained /\<\K\k*\ze\s*:\s*function\>/
                            syntax match   jsObjectMethodType  contained /\<[gs]et\ze\s\+\K\k*/ skipwhite skipempty nextgroup=jsObjectFuncName
                            syntax region  jsObjectStringKey   contained start=+\z(["']\)+  skip=+\\\%(\z1\|$\)+  end=+\z1\|$+  contains=jsSpecial extend skipwhite skipempty nextgroup=jsFuncArgs,jsObjectValue
                            
                            exe 'syntax keyword jsNull      null             '.(exists('g:javascript_conceal_null')      ? 'conceal cchar='.g:javascript_conceal_null       : '')
                            exe 'syntax keyword jsReturn    return contained '.(exists('g:javascript_conceal_return')    ? 'conceal cchar='.g:javascript_conceal_return     : '').' skipwhite nextgroup=@jsExpression'
                            exe 'syntax keyword jsUndefined undefined        '.(exists('g:javascript_conceal_undefined') ? 'conceal cchar='.g:javascript_conceal_undefined  : '')
                            exe 'syntax keyword jsNan       NaN              '.(exists('g:javascript_conceal_NaN')       ? 'conceal cchar='.g:javascript_conceal_NaN        : '')
                            exe 'syntax keyword jsPrototype prototype        '.(exists('g:javascript_conceal_prototype') ? 'conceal cchar='.g:javascript_conceal_prototype  : '')
                            exe 'syntax keyword jsThis      this             '.(exists('g:javascript_conceal_this')      ? 'conceal cchar='.g:javascript_conceal_this       : '')
                            exe 'syntax keyword jsSuper     super  contained '.(exists('g:javascript_conceal_super')     ? 'conceal cchar='.g:javascript_conceal_super      : '')
                            
                            " Statement Keywords
                            syntax match   jsBlockLabel              /\<\K\k*\s*::\@!/    contains=jsNoise skipwhite skipempty nextgroup=jsBlock
                            syntax match   jsBlockLabelKey contained /\<\K\k*\ze\s*\_[;]/
                            syntax keyword jsStatement     contained with yield debugger
                            syntax keyword jsStatement     contained break continue skipwhite skipempty nextgroup=jsBlockLabelKey
                            syntax keyword jsConditional            if              skipwhite skipempty nextgroup=jsParenIfElse
                            syntax keyword jsConditional            else            skipwhite skipempty nextgroup=jsCommentIfElse,jsIfElseBlock
                            syntax keyword jsConditional            switch          skipwhite skipempty nextgroup=jsParenSwitch
                            syntax keyword jsRepeat                 while for       skipwhite skipempty nextgroup=jsParenRepeat,jsForAwait
                            syntax keyword jsDo                     do              skipwhite skipempty nextgroup=jsRepeatBlock
                            syntax region  jsSwitchCase   contained matchgroup=jsLabel start=/\<\%(case\|default\)\>/ end=/:\@=/ contains=@jsExpression,jsLabel skipwhite skipempty nextgroup=jsSwitchColon keepend
                            syntax keyword jsTry                    try             skipwhite skipempty nextgroup=jsTryCatchBlock
                            syntax keyword jsFinally      contained finally         skipwhite skipempty nextgroup=jsFinallyBlock
                            syntax keyword jsCatch        contained catch           skipwhite skipempty nextgroup=jsParenCatch,jsTryCatchBlock
                            syntax keyword jsException              throw
                            syntax keyword jsAsyncKeyword           async await
                            syntax match   jsSwitchColon   contained /::\@!/        skipwhite skipempty nextgroup=jsSwitchBlock
                            
                            " Keywords
                            syntax keyword jsGlobalObjects     ArrayBuffer Array BigInt BigInt64Array BigUint64Array Float32Array Float64Array Int16Array Int32Array Int8Array Uint16Array Uint32Array Uint8Array Uint8ClampedArray Boolean Buffer Collator DataView Date DateTimeFormat Function Intl Iterator JSON Map Set WeakMap WeakRef WeakSet Math Number NumberFormat Object ParallelArray Promise Proxy Reflect RegExp String Symbol Uint8ClampedArray WebAssembly console document fetch window
                            syntax keyword jsGlobalNodeObjects  module exports global process __dirname __filename
                            syntax match   jsGlobalNodeObjects  /\<require\>/ containedin=jsFuncCall
                            syntax keyword jsExceptions         Error EvalError InternalError RangeError ReferenceError StopIteration SyntaxError TypeError URIError
                            syntax keyword jsBuiltins           decodeURI decodeURIComponent encodeURI encodeURIComponent eval isFinite isNaN parseFloat parseInt uneval
                            " DISCUSS: How imporant is this, really? Perhaps it should be linked to an error because I assume the keywords are reserved?
                            syntax keyword jsFutureKeys         abstract enum int short boolean interface byte long char final native synchronized float package throws goto private transient implements protected volatile double public
                            
                            " DISCUSS: Should we really be matching stuff like this?
                            " DOM2 Objects
                            syntax keyword jsGlobalObjects  DOMImplementation DocumentFragment Document Node NodeList NamedNodeMap CharacterData Attr Element Text Comment CDATASection DocumentType Notation Entity EntityReference ProcessingInstruction
                            syntax keyword jsExceptions     DOMException
                            
                            " DISCUSS: Should we really be matching stuff like this?
                            " DOM2 CONSTANT
                            syntax keyword jsDomErrNo       INDEX_SIZE_ERR DOMSTRING_SIZE_ERR HIERARCHY_REQUEST_ERR WRONG_DOCUMENT_ERR INVALID_CHARACTER_ERR NO_DATA_ALLOWED_ERR NO_MODIFICATION_ALLOWED_ERR NOT_FOUND_ERR NOT_SUPPORTED_ERR INUSE_ATTRIBUTE_ERR INVALID_STATE_ERR SYNTAX_ERR INVALID_MODIFICATION_ERR NAMESPACE_ERR INVALID_ACCESS_ERR
                            syntax keyword jsDomNodeConsts  ELEMENT_NODE ATTRIBUTE_NODE TEXT_NODE CDATA_SECTION_NODE ENTITY_REFERENCE_NODE ENTITY_NODE PROCESSING_INSTRUCTION_NODE COMMENT_NODE DOCUMENT_NODE DOCUMENT_TYPE_NODE DOCUMENT_FRAGMENT_NODE NOTATION_NODE
                            
                            " DISCUSS: Should we really be special matching on these props?
                            " HTML events and internal variables
                            syntax keyword jsHtmlEvents     onblur onclick oncontextmenu ondblclick onfocus onkeydown onkeypress onkeyup onmousedown onmousemove onmouseout onmouseover onmouseup onresize
                            
                            " Code blocks
                            syntax region  jsBracket                      matchgroup=jsBrackets            start=/\[/ end=/\]/ contains=@jsExpression,jsSpreadExpression extend fold
                            syntax region  jsParen                        matchgroup=jsParens              start=/(/  end=/)/  contains=@jsExpression extend fold nextgroup=jsFlowDefinition
                            syntax region  jsParenDecorator     contained matchgroup=jsParensDecorator     start=/(/  end=/)/  contains=@jsAll extend fold
                            syntax region  jsParenIfElse        contained matchgroup=jsParensIfElse        start=/(/  end=/)/  contains=@jsAll skipwhite skipempty nextgroup=jsCommentIfElse,jsIfElseBlock,jsReturn extend fold
                            syntax region  jsParenRepeat        contained matchgroup=jsParensRepeat        start=/(/  end=/)/  contains=@jsAll skipwhite skipempty nextgroup=jsCommentRepeat,jsRepeatBlock,jsReturn extend fold
                            syntax region  jsParenSwitch        contained matchgroup=jsParensSwitch        start=/(/  end=/)/  contains=@jsAll skipwhite skipempty nextgroup=jsSwitchBlock extend fold
                            syntax region  jsParenCatch         contained matchgroup=jsParensCatch         start=/(/  end=/)/  skipwhite skipempty nextgroup=jsTryCatchBlock extend fold
                            syntax region  jsFuncArgs           contained matchgroup=jsFuncParens          start=/(/  end=/)/  contains=jsFuncArgCommas,jsComment,jsFuncArgExpression,jsDestructuringBlock,jsDestructuringArray,jsRestExpression,jsFlowArgumentDef skipwhite skipempty nextgroup=jsCommentFunction,jsFuncBlock,jsFlowReturn extend fold
                            syntax region  jsClassBlock         contained matchgroup=jsClassBraces         start=/{/  end=/}/  contains=jsClassFuncName,jsClassMethodType,jsArrowFunction,jsArrowFuncArgs,jsComment,jsGenerator,jsDecorator,jsClassProperty,jsClassPropertyComputed,jsClassStringKey,jsAsyncKeyword,jsNoise extend fold
                            syntax region  jsFuncBlock          contained matchgroup=jsFuncBraces          start=/{/  end=/}/  contains=@jsAll,jsBlock extend fold
                            syntax region  jsIfElseBlock        contained matchgroup=jsIfElseBraces        start=/{/  end=/}/  contains=@jsAll,jsBlock extend fold
                            syntax region  jsTryCatchBlock      contained matchgroup=jsTryCatchBraces      start=/{/  end=/}/  contains=@jsAll,jsBlock skipwhite skipempty nextgroup=jsCatch,jsFinally extend fold
                            syntax region  jsFinallyBlock       contained matchgroup=jsFinallyBraces       start=/{/  end=/}/  contains=@jsAll,jsBlock extend fold
                            syntax region  jsSwitchBlock        contained matchgroup=jsSwitchBraces        start=/{/  end=/}/  contains=@jsAll,jsBlock,jsSwitchCase extend fold
                            syntax region  jsRepeatBlock        contained matchgroup=jsRepeatBraces        start=/{/  end=/}/  contains=@jsAll,jsBlock extend fold
                            syntax region  jsDestructuringBlock contained matchgroup=jsDestructuringBraces start=/{/  end=/}/  contains=jsDestructuringProperty,jsDestructuringAssignment,jsDestructuringNoise,jsDestructuringPropertyComputed,jsSpreadExpression,jsComment nextgroup=jsFlowDefinition extend fold
                            syntax region  jsDestructuringArray contained matchgroup=jsDestructuringBraces start=/\[/ end=/\]/ contains=jsDestructuringPropertyValue,jsDestructuringNoise,jsDestructuringProperty,jsSpreadExpression,jsDestructuringBlock,jsDestructuringArray,jsComment nextgroup=jsFlowDefinition extend fold
                            syntax region  jsObject             contained matchgroup=jsObjectBraces        start=/{/  end=/}/  contains=jsObjectKey,jsObjectKeyString,jsObjectKeyComputed,jsObjectShorthandProp,jsObjectSeparator,jsObjectFuncName,jsObjectMethodType,jsGenerator,jsComment,jsObjectStringKey,jsSpreadExpression,jsDecorator,jsAsyncKeyword,jsTemplateString extend fold
                            syntax region  jsBlock                        matchgroup=jsBraces              start=/{/  end=/}/  contains=@jsAll,jsSpreadExpression extend fold
                            syntax region  jsModuleGroup        contained matchgroup=jsModuleBraces        start=/{/ end=/}/   contains=jsModuleKeyword,jsModuleComma,jsModuleAs,jsComment,jsFlowTypeKeyword skipwhite skipempty nextgroup=jsFrom fold
                            syntax region  jsSpreadExpression   contained matchgroup=jsSpreadOperator      start=/\.\.\./ end=/[,}\]]\@=/ contains=@jsExpression
                            syntax region  jsRestExpression     contained matchgroup=jsRestOperator        start=/\.\.\./ end=/[,)]\@=/
                            syntax region  jsTernaryIf                    matchgroup=jsTernaryIfOperator   start=/?:\@!/  end=/\%(:\|}\@=\)/  contains=@jsExpression extend skipwhite skipempty nextgroup=@jsExpression
                            " These must occur here or they will be override by jsTernaryIf
                            syntax match   jsOperator           /?\.\ze\_D/
                            syntax match   jsOperator           /??/ skipwhite skipempty nextgroup=@jsExpression
                            
                            syntax match   jsGenerator            contained /\*/ skipwhite skipempty nextgroup=jsFuncName,jsFuncArgs,jsFlowFunctionGroup
                            syntax match   jsFuncName             contained /\<\K\k*/ skipwhite skipempty nextgroup=jsFuncArgs,jsFlowFunctionGroup
                            syntax region  jsFuncArgExpression    contained matchgroup=jsFuncArgOperator start=/=/ end=/[,)]\@=/ contains=@jsExpression extend
                            syntax match   jsFuncArgCommas        contained ','
                            syntax keyword jsArguments            contained arguments
                            syntax keyword jsForAwait             contained await skipwhite skipempty nextgroup=jsParenRepeat
                            
                            " Matches a single keyword argument with no parens
                            syntax match   jsArrowFuncArgs  /\<\K\k*\ze\s*=>/ skipwhite contains=jsFuncArgs skipwhite skipempty nextgroup=jsArrowFunction extend
                            " Matches a series of arguments surrounded in parens
                            syntax match   jsArrowFuncArgs  /([^()]*)\ze\s*=>/ contains=jsFuncArgs skipempty skipwhite nextgroup=jsArrowFunction extend
                            
                            exe 'syntax match jsFunction /\<function\>/      skipwhite skipempty nextgroup=jsGenerator,jsFuncName,jsFuncArgs,jsFlowFunctionGroup skipwhite '.(exists('g:javascript_conceal_function') ? 'conceal cchar='.g:javascript_conceal_function : '')
                            exe 'syntax match jsArrowFunction /=>/           skipwhite skipempty nextgroup=jsFuncBlock,jsCommentFunction '.(exists('g:javascript_conceal_arrow_function') ? 'conceal cchar='.g:javascript_conceal_arrow_function : '')
                            exe 'syntax match jsArrowFunction /()\ze\s*=>/   skipwhite skipempty nextgroup=jsArrowFunction '.(exists('g:javascript_conceal_noarg_arrow_function') ? 'conceal cchar='.g:javascript_conceal_noarg_arrow_function : '')
                            exe 'syntax match jsArrowFunction /_\ze\s*=>/    skipwhite skipempty nextgroup=jsArrowFunction '.(exists('g:javascript_conceal_underscore_arrow_function') ? 'conceal cchar='.g:javascript_conceal_underscore_arrow_function : '')
                            
                            " Classes
                            syntax keyword jsClassKeyword           contained class
                            syntax keyword jsExtendsKeyword         contained extends skipwhite skipempty nextgroup=@jsExpression
                            syntax match   jsClassNoise             contained /\./
                            syntax match   jsClassFuncName          contained /\<\K\k*\ze\s*[(<]/ skipwhite skipempty nextgroup=jsFuncArgs,jsFlowClassFunctionGroup
                            syntax match   jsClassMethodType        contained /\<\%([gs]et\|static\)\ze\s\+\K\k*/ skipwhite skipempty nextgroup=jsAsyncKeyword,jsClassFuncName,jsClassProperty
                            syntax region  jsClassDefinition                  start=/\<class\>/ end=/\(\<extends\>\s\+\)\@<!{\@=/ contains=jsClassKeyword,jsExtendsKeyword,jsClassNoise,@jsExpression,jsFlowClassGroup skipwhite skipempty nextgroup=jsCommentClass,jsClassBlock,jsFlowClassGroup
                            syntax match   jsClassProperty          contained /\<\K\k*\ze\s*[=;]/ skipwhite skipempty nextgroup=jsClassValue,jsFlowClassDef
                            syntax region  jsClassValue             contained start=/=/ end=/\_[;}]\@=/ contains=@jsExpression
                            syntax region  jsClassPropertyComputed  contained matchgroup=jsBrackets start=/\[/ end=/]/ contains=@jsExpression skipwhite skipempty nextgroup=jsFuncArgs,jsClassValue extend
                            syntax region  jsClassStringKey         contained start=+\z(["']\)+  skip=+\\\%(\z1\|$\)+  end=+\z1\|$+  contains=jsSpecial extend skipwhite skipempty nextgroup=jsFuncArgs
                            
                            " Destructuring
                            syntax match   jsDestructuringPropertyValue     contained /\k\+/
                            syntax match   jsDestructuringProperty          contained /\k\+\ze\s*=/ skipwhite skipempty nextgroup=jsDestructuringValue
                            syntax match   jsDestructuringAssignment        contained /\k\+\ze\s*:/ skipwhite skipempty nextgroup=jsDestructuringValueAssignment
                            syntax region  jsDestructuringValue             contained start=/=/ end=/[,}\]]\@=/ contains=@jsExpression extend
                            syntax region  jsDestructuringValueAssignment   contained start=/:/ end=/[,}=]\@=/ contains=jsDestructuringPropertyValue,jsDestructuringBlock,jsNoise,jsDestructuringNoise skipwhite skipempty nextgroup=jsDestructuringValue extend
                            syntax match   jsDestructuringNoise             contained /[,[\]]/
                            syntax region  jsDestructuringPropertyComputed  contained matchgroup=jsDestructuringBraces start=/\[/ end=/]/ contains=@jsExpression skipwhite skipempty nextgroup=jsDestructuringValue,jsDestructuringValueAssignment,jsDestructuringNoise extend fold
                            
                            " Comments
                            syntax keyword jsCommentTodo    contained TODO FIXME XXX TBD NOTE
                            syntax region  jsComment        start=+//+ end=/$/ contains=jsCommentTodo,@Spell extend keepend
                            syntax region  jsComment        start=+/\*+  end=+\*/+ contains=jsCommentTodo,@Spell fold extend keepend
                            syntax region  jsEnvComment     start=/\%^#!/ end=/$/ display
                            
                            " Specialized Comments - These are special comment regexes that are used in
                            " odd places that maintain the proper nextgroup functionality. It sucks we
                            " can't make jsComment a skippable type of group for nextgroup
                            syntax region  jsCommentFunction    contained start=+//+ end=/$/    contains=jsCommentTodo,@Spell skipwhite skipempty nextgroup=jsFuncBlock,jsFlowReturn extend keepend
                            syntax region  jsCommentFunction    contained start=+/\*+ end=+\*/+ contains=jsCommentTodo,@Spell skipwhite skipempty nextgroup=jsFuncBlock,jsFlowReturn fold extend keepend
                            syntax region  jsCommentClass       contained start=+//+ end=/$/    contains=jsCommentTodo,@Spell skipwhite skipempty nextgroup=jsClassBlock,jsFlowClassGroup extend keepend
                            syntax region  jsCommentClass       contained start=+/\*+ end=+\*/+ contains=jsCommentTodo,@Spell skipwhite skipempty nextgroup=jsClassBlock,jsFlowClassGroup fold extend keepend
                            syntax region  jsCommentIfElse      contained start=+//+ end=/$/    contains=jsCommentTodo,@Spell skipwhite skipempty nextgroup=jsIfElseBlock extend keepend
                            syntax region  jsCommentIfElse      contained start=+/\*+ end=+\*/+ contains=jsCommentTodo,@Spell skipwhite skipempty nextgroup=jsIfElseBlock fold extend keepend
                            syntax region  jsCommentRepeat      contained start=+//+ end=/$/    contains=jsCommentTodo,@Spell skipwhite skipempty nextgroup=jsRepeatBlock extend keepend
                            syntax region  jsCommentRepeat      contained start=+/\*+ end=+\*/+ contains=jsCommentTodo,@Spell skipwhite skipempty nextgroup=jsRepeatBlock fold extend keepend
                            
                            " Decorators
                            syntax match   jsDecorator                    /^\s*@/ nextgroup=jsDecoratorFunction
                            syntax match   jsDecoratorFunction  contained /\h[a-zA-Z0-9_.]*/ nextgroup=jsParenDecorator
                            
                            if exists("javascript_plugin_jsdoc")
                              runtime extras/jsdoc.vim
                              " NGDoc requires JSDoc
                              if exists("javascript_plugin_ngdoc")
                                runtime extras/ngdoc.vim
                              endif
                            endif
                            
                            if exists("javascript_plugin_flow")
                              runtime extras/flow.vim
                            endif
                            
                            syntax cluster jsExpression  contains=jsBracket,jsParen,jsObject,jsTernaryIf,jsTaggedTemplate,jsTemplateString,jsString,jsRegexpString,jsNumber,jsFloat,jsOperator,jsOperatorKeyword,jsBooleanTrue,jsBooleanFalse,jsNull,jsFunction,jsArrowFunction,jsGlobalObjects,jsExceptions,jsFutureKeys,jsDomErrNo,jsDomNodeConsts,jsHtmlEvents,jsFuncCall,jsUndefined,jsNan,jsPrototype,jsBuiltins,jsNoise,jsClassDefinition,jsArrowFunction,jsArrowFuncArgs,jsParensError,jsComment,jsArguments,jsThis,jsSuper,jsDo,jsForAwait,jsAsyncKeyword,jsStatement,jsDot
                            syntax cluster jsAll         contains=@jsExpression,jsStorageClass,jsConditional,jsRepeat,jsReturn,jsException,jsTry,jsNoise,jsBlockLabel
                            
                            " Define the default highlighting.
                            " For version 5.7 and earlier: only when not done already
                            " For version 5.8 and later: only when an item doesn't have highlighting yet
                            if version >= 508 || !exists("did_javascript_syn_inits")
                              if version < 508
                                let did_javascript_syn_inits = 1
                                command -nargs=+ HiLink hi link <args>
                              else
                                command -nargs=+ HiLink hi def link <args>
                              endif
                              HiLink jsComment              Comment
                              HiLink jsEnvComment           PreProc
                              HiLink jsParensIfElse         jsParens
                              HiLink jsParensRepeat         jsParens
                              HiLink jsParensSwitch         jsParens
                              HiLink jsParensCatch          jsParens
                              HiLink jsCommentTodo          Todo
                              HiLink jsString               String
                              HiLink jsObjectKeyString      String
                              HiLink jsTemplateString       String
                              HiLink jsObjectStringKey      String
                              HiLink jsClassStringKey       String
                              HiLink jsTaggedTemplate       StorageClass
                              HiLink jsTernaryIfOperator    Operator
                              HiLink jsRegexpString         String
                              HiLink jsRegexpBoundary       SpecialChar
                              HiLink jsRegexpQuantifier     SpecialChar
                              HiLink jsRegexpOr             Conditional
                              HiLink jsRegexpMod            SpecialChar
                              HiLink jsRegexpBackRef        SpecialChar
                              HiLink jsRegexpGroup          jsRegexpString
                              HiLink jsRegexpCharClass      Character
                              HiLink jsCharacter            Character
                              HiLink jsPrototype            Special
                              HiLink jsConditional          Conditional
                              HiLink jsBranch               Conditional
                              HiLink jsLabel                Label
                              HiLink jsReturn               Statement
                              HiLink jsRepeat               Repeat
                              HiLink jsDo                   Repeat
                              HiLink jsStatement            Statement
                              HiLink jsException            Exception
                              HiLink jsTry                  Exception
                              HiLink jsFinally              Exception
                              HiLink jsCatch                Exception
                              HiLink jsAsyncKeyword         Keyword
                              HiLink jsForAwait             Keyword
                              HiLink jsArrowFunction        Type
                              HiLink jsFunction             Type
                              HiLink jsGenerator            jsFunction
                              HiLink jsArrowFuncArgs        jsFuncArgs
                              HiLink jsFuncName             Function
                              HiLink jsFuncCall             Function
                              HiLink jsClassFuncName        jsFuncName
                              HiLink jsObjectFuncName       Function
                              HiLink jsArguments            Special
                              HiLink jsError                Error
                              HiLink jsParensError          Error
                              HiLink jsOperatorKeyword      jsOperator
                              HiLink jsOperator             Operator
                              HiLink jsOf                   Operator
                              HiLink jsStorageClass         StorageClass
                              HiLink jsClassKeyword         Keyword
                              HiLink jsExtendsKeyword       Keyword
                              HiLink jsThis                 Special
                              HiLink jsSuper                Constant
                              HiLink jsNan                  Number
                              HiLink jsNull                 Type
                              HiLink jsUndefined            Type
                              HiLink jsNumber               Number
                              HiLink jsFloat                Float
                              HiLink jsBooleanTrue          Boolean
                              HiLink jsBooleanFalse         Boolean
                              HiLink jsObjectColon          jsNoise
                              HiLink jsNoise                Noise
                              HiLink jsDot                  Noise
                              HiLink jsBrackets             Noise
                              HiLink jsParens               Noise
                              HiLink jsBraces               Noise
                              HiLink jsFuncBraces           Noise
                              HiLink jsFuncParens           Noise
                              HiLink jsClassBraces          Noise
                              HiLink jsClassNoise           Noise
                              HiLink jsIfElseBraces         Noise
                              HiLink jsTryCatchBraces       Noise
                              HiLink jsModuleBraces         Noise
                              HiLink jsObjectBraces         Noise
                              HiLink jsObjectSeparator      Noise
                              HiLink jsFinallyBraces        Noise
                              HiLink jsRepeatBraces         Noise
                              HiLink jsSwitchBraces         Noise
                              HiLink jsSpecial              Special
                              HiLink jsTemplateBraces       Noise
                              HiLink jsGlobalObjects        Constant
                              HiLink jsGlobalNodeObjects    Constant
                              HiLink jsExceptions           Constant
                              HiLink jsBuiltins             Constant
                              HiLink jsImport               Include
                              HiLink jsExport               Include
                              HiLink jsExportDefault        StorageClass
                              HiLink jsExportDefaultGroup   jsExportDefault
                              HiLink jsModuleAs             Include
                              HiLink jsModuleComma          jsNoise
                              HiLink jsModuleAsterisk       Noise
                              HiLink jsFrom                 Include
                              HiLink jsDecorator            Special
                              HiLink jsDecoratorFunction    Function
                              HiLink jsParensDecorator      jsParens
                              HiLink jsFuncArgOperator      jsFuncArgs
                              HiLink jsClassProperty        jsObjectKey
                              HiLink jsObjectShorthandProp  jsObjectKey
                              HiLink jsSpreadOperator       Operator
                              HiLink jsRestOperator         Operator
                              HiLink jsRestExpression       jsFuncArgs
                              HiLink jsSwitchColon          Noise
                              HiLink jsClassMethodType      Type
                              HiLink jsObjectMethodType     Type
                              HiLink jsClassDefinition      jsFuncName
                              HiLink jsBlockLabel           Identifier
                              HiLink jsBlockLabelKey        jsBlockLabel
                            
                              HiLink jsDestructuringBraces     Noise
                              HiLink jsDestructuringProperty   jsFuncArgs
                              HiLink jsDestructuringAssignment jsObjectKey
                              HiLink jsDestructuringNoise      Noise
                            
                              HiLink jsCommentFunction      jsComment
                              HiLink jsCommentClass         jsComment
                              HiLink jsCommentIfElse        jsComment
                              HiLink jsCommentRepeat        jsComment
                            
                              HiLink jsDomErrNo             Constant
                              HiLink jsDomNodeConsts        Constant
                              HiLink jsDomElemAttrs         Label
                              HiLink jsDomElemFuncs         PreProc
                            
                              HiLink jsHtmlEvents           Special
                              HiLink jsHtmlElemAttrs        Label
                              HiLink jsHtmlElemFuncs        PreProc
                            
                              HiLink jsCssStyles            Label
                            
                              delcommand HiLink
                            endif
                            
                            " Define the htmlJavaScript for HTML syntax html.vim
                            syntax cluster  htmlJavaScript       contains=@jsAll,jsImport,jsExport
                            syntax cluster  javaScriptExpression contains=@jsAll
                            
                            " Vim's default html.vim highlights all javascript as 'Special'
                            hi! def link javaScript              NONE
                            
                            let b:current_syntax = "javascript"
                            if main_syntax == 'javascript'
                              unlet main_syntax
                            endif

SCRIPT  /Users/Ragglesoft/.config/nvim/autoload/plugged/vim-polyglot/syntax/javascript/html5.vim
Sourced 1 time
Total time:   0.000900
 Self time:   0.000878

count  total (s)   self (s)
    1   0.000134   0.000112 if polyglot#init#is_disabled(expand('<sfile>:p'), 'html5', 'syntax/javascript/html5.vim')
                              finish
    1              0.000001 endif
                            
                            " Vim syntax file
                            " Language:	    HTML5 New Stuff
                            " Maintainer:	othree <othree@gmail.com>
                            " URL:		    http://github.com/othree/html5-syntax.vim
                            " Last Change:  2011-05-27
                            " License:      MIT
                            " Changes:      
                            
    1              0.000017 syn keyword javascriptHtmlEvents onabort onblur oncanplay oncanplaythrough onchange 
    1              0.000006 syn keyword javascriptHtmlEvents onclick oncontextmenu ondblclick ondrag ondragend ondragenter ondragleave ondragover 
    1              0.000004 syn keyword javascriptHtmlEvents ondragstart ondrop ondurationchange onemptied onended onerror onfocus onformchange 
    1              0.000004 syn keyword javascriptHtmlEvents onforminput oninput oninvalid onkeydown onkeypress onkeyup onload onloadeddata 
    1              0.000029 syn keyword javascriptHtmlEvents onloadedmetadata onloadstart onmousedown onmousemove onmouseout onmouseover onmouseup
    1              0.000017 syn keyword javascriptHtmlEvents onmousewheel onpause onplay onplaying onprogress onratechange onreadystatechange 
    1              0.000019 syn keyword javascriptHtmlEvents onscroll onseeked onseeking onselect onshow onstalled onsubmit onsuspend ontimeupdate 
    1              0.000007 syn keyword javascriptHtmlEvents onvolumechange onwaiting
                            
                            " <body>
    1              0.000011 syn keyword javascriptHtmlEvents onafterprint onbeforeprint onbeforeunload onblur onerror onfocus onhashchange onload 
    1              0.000012 syn keyword javascriptHtmlEvents onmessage onoffline ononline onpopstate onredo onresize onstorage onundo onunload
                            
                            " Media Controller
    1              0.000004 syn keyword javascriptDomElemAttrs buffered seekable duration currentTime paused
    1              0.000005 syn keyword javascriptDomElemAttrs played defaultPlaybackRate playbackRate volume muted
    1              0.000003 syn keyword javascriptDomElemAttrs mediaGroup
    1              0.000003 syn keyword javascriptDomElemFuncs load play pause 
                            
    1              0.000004 syn keyword javascriptHtmlEvents oncanplay oncanplaythrough ondurationchange onemptied 
    1              0.000004 syn keyword javascriptHtmlEvents onloadeddata onloadedmetadata onloadstart onpause onplay onplaying onratechange 
    1              0.000003 syn keyword javascriptHtmlEvents ontimeupdate onvolumechange onwaiting
                            
                            " <audio>/<video>
    1              0.000005 syn keyword javascriptDomElemAttrs error src currentSrc networkState preload buffered readyState seeking 
    1              0.000005 syn keyword javascriptDomElemAttrs currentTime initialTime duration startOffsetTime paused defaultPlaybackRate playbackRate played
    1              0.000005 syn keyword javascriptDomElemAttrs seekable ended autoplay loop controls volume muted defaltMuted audioTracks videoTracks textTracks
    1              0.000003 syn keyword javascriptDomElemFuncs load addTextTrack
                            
                            " <video>
                            " syn keyword javascriptDomElemAttrs width height
    1              0.000003 syn keyword javascriptDomElemAttrs videoWidth videoHeight poster
                            
                            " drag and drop
    1              0.000005 syn keyword javascriptDomElemAttrs ondragstart ondragend ondragenter ondragleave ondragover ondrag ondrop draggable dropzone
                            
                            " <checkbox>
    1              0.000003 syn keyword javascriptDomElemAttrs indeterminate
                            
                            " select https://w3c.github.io/selection-api/#extensions-to-globaleventhandlers
    1              0.000008 syn keyword javascriptDomElemAttrs onselectstart onselectchange

SCRIPT  /usr/local/Cellar/neovim/0.5.0/share/nvim/runtime/syntax/javascript.vim
Sourced 27 times
Total time:   0.001922
 Self time:   0.001922

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:	JavaScript
                            " Maintainer:	Claudio Fleiner <claudio@fleiner.com>
                            " Updaters:	Scott Shattuck (ss) <ss@technicalpursuit.com>
                            " URL:		http://www.fleiner.com/vim/syntax/javascript.vim
                            " Changes:	(ss) added keywords, reserved words, and other identifiers
                            "		(ss) repaired several quoting and grouping glitches
                            "		(ss) fixed regex parsing issue with multiple qualifiers [gi]
                            "		(ss) additional factoring of keywords, globals, and members
                            " Last Change:	2021 Mar 30
                            " 		2013 Jun 12: adjusted javaScriptRegexpString (Kevin Locke)
                            " 		2018 Apr 14: adjusted javaScriptRegexpString (LongJohnCoder)
                            
                            " tuning parameters:
                            " unlet javaScript_fold
                            
   27              0.000183 if !exists("main_syntax")
                              " quit when a syntax file was already loaded
   27              0.000075   if exists("b:current_syntax")
   27              0.000033     finish
                              endif
                              let main_syntax = 'javascript'
                            elseif exists("b:current_syntax") && b:current_syntax == "javascript"
                              finish
                            endif
                            
                            let s:cpo_save = &cpo
                            set cpo&vim
                            
                            
                            syn keyword javaScriptCommentTodo      TODO FIXME XXX TBD contained
                            syn match   javaScriptLineComment      "\/\/.*" contains=@Spell,javaScriptCommentTodo
                            syn match   javaScriptCommentSkip      "^[ \t]*\*\($\|[ \t]\+\)"
                            syn region  javaScriptComment	       start="/\*"  end="\*/" contains=@Spell,javaScriptCommentTodo
                            syn match   javaScriptSpecial	       "\\\d\d\d\|\\."
                            syn region  javaScriptStringD	       start=+"+  skip=+\\\\\|\\"+  end=+"\|$+	contains=javaScriptSpecial,@htmlPreproc
                            syn region  javaScriptStringS	       start=+'+  skip=+\\\\\|\\'+  end=+'\|$+	contains=javaScriptSpecial,@htmlPreproc
                            syn region  javaScriptStringT	       start=+`+  skip=+\\\\\|\\`+  end=+`+	contains=javaScriptSpecial,javaScriptEmbed,@htmlPreproc
                            
                            syn region  javaScriptEmbed	       start=+${+  end=+}+	contains=@javaScriptEmbededExpr
                            
                            syn match   javaScriptSpecialCharacter "'\\.'"
                            syn match   javaScriptNumber	       "-\=\<\d\+L\=\>\|0[xX][0-9a-fA-F]\+\>"
                            syn match   javaScriptNumber	       "-\=\<\d\+\%(_\d\+\)*\>"
                            syn region  javaScriptRegexpString     start=+[,(=+]\s*/[^/*]+ms=e-1,me=e-1 skip=+\\\\\|\\/+ end=+/[gimuys]\{0,2\}\s*$+ end=+/[gimuys]\{0,2\}\s*[+;.,)\]}]+me=e-1 end=+/[gimuys]\{0,2\}\s\+\/+me=e-1 contains=@htmlPreproc,javaScriptComment oneline
                            
                            syn keyword javaScriptConditional	if else switch
                            syn keyword javaScriptRepeat		while for do in
                            syn keyword javaScriptBranch		break continue
                            syn keyword javaScriptOperator		new delete instanceof typeof
                            syn keyword javaScriptType		Array Boolean Date Function Number Object String RegExp
                            syn keyword javaScriptStatement		return with await
                            syn keyword javaScriptBoolean		true false
                            syn keyword javaScriptNull		null undefined
                            syn keyword javaScriptIdentifier	arguments this var let
                            syn keyword javaScriptLabel		case default
                            syn keyword javaScriptException		try catch finally throw
                            syn keyword javaScriptMessage		alert confirm prompt status
                            syn keyword javaScriptGlobal		self window top parent
                            syn keyword javaScriptMember		document event location 
                            syn keyword javaScriptDeprecated	escape unescape
                            syn keyword javaScriptReserved		abstract boolean byte char class const debugger double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile async
                            
                            syn cluster  javaScriptEmbededExpr	contains=javaScriptBoolean,javaScriptNull,javaScriptIdentifier,javaScriptStringD,javaScriptStringS,javaScriptStringT
                            
                            if exists("javaScript_fold")
                                syn match	javaScriptFunction	"\<function\>"
                                syn region	javaScriptFunctionFold	start="\<function\>.*[^};]$" end="^\z1}.*$" transparent fold keepend
                            
                                syn sync match javaScriptSync	grouphere javaScriptFunctionFold "\<function\>"
                                syn sync match javaScriptSync	grouphere NONE "^}"
                            
                                setlocal foldmethod=syntax
                                setlocal foldtext=getline(v:foldstart)
                            else
                                syn keyword javaScriptFunction	function
                                syn match	javaScriptBraces	   "[{}\[\]]"
                                syn match	javaScriptParens	   "[()]"
                            endif
                            
                            if main_syntax == "javascript"
                              syn sync fromstart
                              syn sync maxlines=100
                            
                              syn sync ccomment javaScriptComment
                            endif
                            
                            " Define the default highlighting.
                            " Only when an item doesn't have highlighting yet
                            hi def link javaScriptComment		Comment
                            hi def link javaScriptLineComment		Comment
                            hi def link javaScriptCommentTodo		Todo
                            hi def link javaScriptSpecial		Special
                            hi def link javaScriptStringS		String
                            hi def link javaScriptStringD		String
                            hi def link javaScriptStringT		String
                            hi def link javaScriptCharacter		Character
                            hi def link javaScriptSpecialCharacter	javaScriptSpecial
                            hi def link javaScriptNumber		javaScriptValue
                            hi def link javaScriptConditional		Conditional
                            hi def link javaScriptRepeat		Repeat
                            hi def link javaScriptBranch		Conditional
                            hi def link javaScriptOperator		Operator
                            hi def link javaScriptType			Type
                            hi def link javaScriptStatement		Statement
                            hi def link javaScriptFunction		Function
                            hi def link javaScriptBraces		Function
                            hi def link javaScriptError		Error
                            hi def link javaScrParenError		javaScriptError
                            hi def link javaScriptNull			Keyword
                            hi def link javaScriptBoolean		Boolean
                            hi def link javaScriptRegexpString		String
                            
                            hi def link javaScriptIdentifier		Identifier
                            hi def link javaScriptLabel		Label
                            hi def link javaScriptException		Exception
                            hi def link javaScriptMessage		Keyword
                            hi def link javaScriptGlobal		Keyword
                            hi def link javaScriptMember		Keyword
                            hi def link javaScriptDeprecated		Exception 
                            hi def link javaScriptReserved		Keyword
                            hi def link javaScriptDebug		Debug
                            hi def link javaScriptConstant		Label
                            hi def link javaScriptEmbed		Special
                            
                            
                            
                            let b:current_syntax = "javascript"
                            if main_syntax == 'javascript'
                              unlet main_syntax
                            endif
                            let &cpo = s:cpo_save
                            unlet s:cpo_save
                            
                            " vim: ts=8

SCRIPT  /Users/Ragglesoft/.config/nvim/autoload/plugged/vim-polyglot/after/syntax/javascript.vim
Sourced 27 times
Total time:   0.071580
 Self time:   0.005026

count  total (s)   self (s)
   27   0.001582   0.000868 if polyglot#init#is_disabled(expand('<sfile>:p'), 'jsx', 'after/syntax/javascript.vim')
                              finish
   27              0.000018 endif
                            
   27              0.000108 if get(g:, 'vim_jsx_pretty_disable_js', 0)
                              finish
   27              0.000014 endif
                            
   27   0.068759   0.002919 source <sfile>:h/jsx.vim

SCRIPT  /Users/Ragglesoft/.config/nvim/autoload/plugged/vim-polyglot/after/syntax/jsx.vim
Sourced 27 times
Total time:   0.065331
 Self time:   0.041203

count  total (s)   self (s)
   27   0.000993   0.000599 if polyglot#init#is_disabled(expand('<sfile>:p'), 'jsx', 'after/syntax/jsx.vim')
                              finish
   27              0.000017 endif
                            
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            " Vim syntax file
                            "
                            " Language: javascript.jsx
                            " Maintainer: MaxMellon <maxmellon1994@gmail.com>
                            "
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
   27              0.000266 let s:jsx_cpo = &cpo
   27   0.000401   0.000347 set cpo&vim
                            
   27              0.000046 syntax case match
                            
   27              0.000109 if exists('b:current_syntax')
   27              0.000063   let s:current_syntax = b:current_syntax
   27              0.000056   unlet b:current_syntax
   27              0.000018 endif
                            
   27              0.000058 if exists('s:current_syntax')
   27              0.000043   let b:current_syntax = s:current_syntax
   27              0.000014 endif
                            
   27              0.000522 if hlexists("jsDebugger") || hlexists("jsNoise")    " yuezk/vim-js or pangloss/vim-javascript
   27              0.000302   syntax cluster jsExpression add=jsxRegion
                            elseif hlexists("javascriptOpSymbols")    " othree/yajs.vim
                              " refine the javascript line comment
                              syntax region javascriptLineComment start=+//+ end=/$/ contains=@Spell,javascriptCommentTodo extend keepend
                              syntax cluster javascriptValue add=jsxRegion
                              syntax cluster javascriptNoReserved add=jsxElement,jsxTag
                            else    " build-in javascript syntax
                              " refine the javascript line comment
                              syntax region javaScriptLineComment start=+//+ end=/$/ contains=@Spell,javascriptCommentTodo extend keepend
                            
                              " refine the template string syntax
                              syntax region javaScriptEmbed matchgroup=javaScriptEmbedBraces start=+\${+ end=+}+ contained contains=@javaScriptEmbededExpr
                            
                              " add a javaScriptBlock group for build-in syntax
                              syntax region javaScriptBlock
                                    \ matchgroup=javaScriptBraces
                                    \ start="{"
                                    \ end="}"
                                    \ contained
                                    \ extend
                                    \ contains=javaScriptBlock,@javaScriptEmbededExpr,javaScript.*
                                    \ fold
                            
                              syntax cluster javaScriptEmbededExpr add=jsxRegion,javaScript.*
   27              0.000087 endif
                            
   27   0.034471   0.010885 runtime syntax/jsx_pretty.vim
                            
   27              0.000059 let b:current_syntax = 'javascript.jsx'
                            
   27   0.000412   0.000318 let &cpo = s:jsx_cpo
   27              0.000116 unlet s:jsx_cpo

SCRIPT  /Users/Ragglesoft/.config/nvim/autoload/plugged/vim-polyglot/after/syntax/jsx_pretty.vim
Sourced 54 times
Total time:   0.045154
 Self time:   0.043820

count  total (s)   self (s)
   54   0.003088   0.001753 if polyglot#init#is_disabled(expand('<sfile>:p'), 'jsx', 'after/syntax/jsx_pretty.vim')
                              finish
   54              0.000052 endif
                            
   54              0.000367 let s:highlight_close_tag = get(g:, 'vim_jsx_pretty_highlight_close_tag', 0)
                            
                            " detect jsx region
   54              0.002296 syntax region jsxRegion
                                  \ start=+\%(\%(\_[([,?:=+\-*/>{}]\|<\s\+\|&&\|||\|=>\|\<return\|\<default\|\<await\|\<yield\)\_s*\)\@<=<\_s*\%(>\|\z(\%(script\|\s*\<T\>\)\@!\<[_$A-Za-z][-:._$A-Za-z0-9]*\>\)\%(\_s*\%([-+*)\]}&|?,]\|/\%([/*]\|\_s*>\)\@!\)\)\@!\)+
                                  \ end=++
                                  \ contains=jsxElement
                            
                            " <tag id="sample">
                            " ~~~~~~~~~~~~~~~~~
                            " and self close tag
                            " <tag id="sample"   />
                            " ~~~~~~~~~~~~~~~~~~~
   54              0.003252 syntax region jsxTag
                                  \ start=+<+
                                  \ matchgroup=jsxOpenPunct
                                  \ end=+>+
                                  \ matchgroup=NONE
                                  \ end=+\%(/\_s*>\)\@=+
                                  \ contained
                                  \ contains=jsxOpenTag,jsxAttrib,jsxExpressionBlock,jsxSpreadOperator,jsComment,@javascriptComments,javaScriptLineComment,javaScriptComment,typescriptLineComment,typescriptComment
                                  \ keepend
                                  \ extend
                                  \ skipwhite
                                  \ skipempty
                                  \ nextgroup=jsxCloseString
                            
                            " <tag></tag>
                            " ~~~~~~~~~~~
                            " and fragment
                            " <></>
                            " ~~~~~
                            " and self close tag
                            " <tag />
                            " ~~~~~~~
   54              0.002025 syntax region jsxElement
                                  \ start=+<\_s*\%(>\|\${\|\z(\<[-:._$A-Za-z0-9]\+\>\)\)+
                                  \ end=+/\_s*>+
                                  \ end=+<\_s*/\_s*\z1\_s*>+
                                  \ contains=jsxElement,jsxTag,jsxExpressionBlock,jsxComment,jsxCloseTag,@Spell
                                  \ keepend
                                  \ extend
                                  \ contained
                                  \ fold
                            
                            " <tag key={this.props.key}>
                            " ~~~~
                            " and fragment start tag
                            " <>
                            " ~~
   54              0.001615 exe 'syntax region jsxOpenTag
                                  \ matchgroup=jsxOpenPunct
                                  \ start=+<+
                                  \ end=+>+
                                  \ matchgroup=NONE
                                  \ end=+\>+
                                  \ contained
                                  \ contains=jsxTagName
                                  \ nextgroup=jsxAttrib
                                  \ skipwhite
                                  \ skipempty
                                  \ ' .(s:highlight_close_tag ? 'transparent' : '')
                            
                            
                            " <tag key={this.props.key}>
                            "          ~~~~~~~~~~~~~~~~
   54              0.003964 syntax region jsxExpressionBlock
                                  \ matchgroup=jsxBraces
                                  \ start=+{+
                                  \ end=+}+
                                  \ contained
                                  \ extend
                                  \ contains=@jsExpression,jsSpreadExpression,@javascriptExpression,javascriptSpreadOp,@javaScriptEmbededExpr,@typescriptExpression,typescriptObjectSpread,jsComment,@javascriptComments,javaScriptLineComment,javaScriptComment,typescriptLineComment,typescriptComment
                            
                            " <foo.bar>
                            "     ~
   54              0.000271 syntax match jsxDot +\.+ contained
                            
                            " <foo:bar>
                            "     ~
   54              0.000220 syntax match jsxNamespace +:+ contained
                            
                            " <tag id="sample">
                            "        ~
   54              0.000873 syntax match jsxEqual +=+ contained skipwhite skipempty nextgroup=jsxString,jsxExpressionBlock,jsxRegion
                            
                            " <tag />
                            "      ~~
   54              0.000260 syntax match jsxCloseString +/\_s*>+ contained
                            
                            " </tag>
                            " ~~~~~~
                            " and fragment close tag
                            " </>
                            " ~~~
   54              0.000769 syntax region jsxCloseTag
                                  \ matchgroup=jsxClosePunct
                                  \ start=+<\_s*/+
                                  \ end=+>+
                                  \ contained
                                  \ contains=jsxTagName
                            
                            " <tag key={this.props.key}>
                            "      ~~~
   54              0.001146 syntax match jsxAttrib
                                  \ +\<[_$A-Za-z][-:_$A-Za-z0-9]*\>+
                                  \ contained
                                  \ nextgroup=jsxEqual
                                  \ skipwhite
                                  \ skipempty
                                  \ contains=jsxAttribKeyword,jsxNamespace
                            
                            " <MyComponent ...>
                            "  ~~~~~~~~~~~
                            " NOT
                            " <someCamel ...>
                            "      ~~~~~
   54              0.000628 exe 'syntax match jsxComponentName
                                  \ +\<[_$]\?[A-Z][-_$A-Za-z0-9]*\>+
                                  \ contained
                                  \ ' .(s:highlight_close_tag ? 'transparent' : '')
                            
                            " <tag key={this.props.key}>
                            "  ~~~
   54              0.001599 exe 'syntax match jsxTagName
                                  \ +\<[-:._$A-Za-z0-9]\+\>+
                                  \ contained
                                  \ contains=jsxComponentName,jsxDot,jsxNamespace
                                  \ nextgroup=jsxAttrib
                                  \ skipempty
                                  \ skipwhite
                                  \ ' .(s:highlight_close_tag ? 'transparent' : '')
                            
                            " <tag id="sample">
                            "         ~~~~~~~~
                            " and
                            " <tag id='sample'>
                            "         ~~~~~~~~
   54              0.000691 syntax region jsxString start=+\z(["']\)+  skip=+\\\\\|\\\z1\|\\\n+  end=+\z1+ extend contained contains=@Spell
                            
   54              0.000439 let s:tags = get(g:, 'vim_jsx_pretty_template_tags', ['html', 'jsx'])
   54              0.000177 let s:enable_tagged_jsx = !empty(s:tags)
                            
                            " add support to JSX inside the tagged template string
                            " https://github.com/developit/htm
   54              0.000912 if s:enable_tagged_jsx
   54              0.002078   exe 'syntax match jsxRegion +\%(' . join(s:tags, '\|') . '\)\%(\_s*`\)\@=+ contains=jsTemplateStringTag,jsTaggedTemplate,javascriptTagRef skipwhite skipempty nextgroup=jsxTaggedRegion'
                            
   54              0.001114   syntax region jsxTaggedRegion
                                    \ matchgroup=jsxBackticks
                                    \ start=+`+
                                    \ end=+`+
                                    \ extend
                                    \ contained
                                    \ contains=jsxElement,jsxExpressionBlock
                                    \ transparent
                            
   54              0.002303   syntax region jsxExpressionBlock
                                    \ matchgroup=jsxBraces
                                    \ start=+\${+
                                    \ end=+}+
                                    \ extend
                                    \ contained
                                    \ contains=@jsExpression,jsSpreadExpression,@javascriptExpression,javascriptSpreadOp,@javaScriptEmbededExpr,@typescriptExpression,typescriptObjectSpread
                            
   54              0.001386   syntax region jsxOpenTag
                                    \ matchgroup=jsxOpenPunct
                                    \ start=+<\%(\${\)\@=+
                                    \ matchgroup=NONE
                                    \ end=+}\@1<=+
                                    \ contained
                                    \ contains=jsxExpressionBlock
                                    \ skipwhite
                                    \ skipempty
                                    \ nextgroup=jsxAttrib,jsxSpreadOperator
                            
   54              0.000297   syntax keyword jsxAttribKeyword class contained
                            
   54              0.000528   syntax match jsxSpreadOperator +\.\.\.+ contained nextgroup=jsxExpressionBlock skipwhite
                            
   54              0.000230   syntax match jsxCloseTag +<//>+ contained
                            
   54              0.000397   syntax match jsxComment +<!--\_.\{-}-->+
   54              0.000053 endif
                            
                            " Highlight the tag name
   54              0.000731 highlight def link jsxTag Function
   54              0.000610 highlight def link jsxTagName Identifier
   54              0.000499 highlight def link jsxComponentName Function
                            
   54              0.000511 highlight def link jsxAttrib Type
   54              0.000252 highlight def link jsxAttribKeyword jsxAttrib
   54              0.000519 highlight def link jsxString String
   54              0.000494 highlight def link jsxComment Comment
                            
   54              0.000539 highlight def link jsxDot Operator
   54              0.000586 highlight def link jsxNamespace Operator
   54              0.000511 highlight def link jsxEqual Operator
   54              0.000548 highlight def link jsxSpreadOperator Operator
   54              0.000529 highlight def link jsxBraces Special
                            
   54              0.000112 if s:highlight_close_tag
                              highlight def link jsxCloseString Identifier
                              highlight def link jsxOpenPunct jsxTag
   54              0.000053 else
                              " Highlight the jsxCloseString (i.e. />), jsxPunct (i.e. <,>) and jsxCloseTag (i.e. <//>)
   54              0.000602   highlight def link jsxCloseString Comment
   54              0.000302   highlight def link jsxOpenPunct jsxPunct
   54              0.000039 endif
                            
   54              0.000217 highlight def link jsxPunct jsxCloseString
   54              0.000236 highlight def link jsxClosePunct jsxPunct
   54              0.000259 highlight def link jsxCloseTag jsxCloseString
                            
   54              0.000264 let s:vim_jsx_pretty_colorful_config = get(g:, 'vim_jsx_pretty_colorful_config', 0)
                            
   54              0.000139 if s:vim_jsx_pretty_colorful_config == 1
                              highlight def link jsObjectKey Label
                              highlight def link jsArrowFuncArgs Type
                              highlight def link jsFuncArgs Type
   54              0.000201 endif

SCRIPT  /Users/Ragglesoft/.config/nvim/autoload/plugged/vim-polyglot/after/syntax/javascript/graphql.vim
Sourced 1 time
Total time:   0.004629
 Self time:   0.002695

count  total (s)   self (s)
    1   0.000099   0.000076 if polyglot#init#is_disabled(expand('<sfile>:p'), 'graphql', 'after/syntax/javascript/graphql.vim')
                              finish
    1              0.000001 endif
                            
                            " Copyright (c) 2016-2021 Jon Parise <jon@indelible.org>
                            "
                            " Permission is hereby granted, free of charge, to any person obtaining a copy
                            " of this software and associated documentation files (the "Software"), to
                            " deal in the Software without restriction, including without limitation the
                            " rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
                            " sell copies of the Software, and to permit persons to whom the Software is
                            " furnished to do so, subject to the following conditions:
                            "
                            " The above copyright notice and this permission notice shall be included in
                            " all copies or substantial portions of the Software.
                            "
                            " THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
                            " IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
                            " FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
                            " AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
                            " LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
                            " FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
                            " IN THE SOFTWARE.
                            "
                            " Language: GraphQL
                            " Maintainer: Jon Parise <jon@indelible.org>
                            
    1              0.000004 if exists('b:current_syntax')
    1              0.000010   let s:current_syntax = b:current_syntax
    1              0.000003   unlet b:current_syntax
    1              0.000001 endif
                            
    1              0.000002 let b:graphql_nested_syntax = 1
    1   0.003474   0.001594 syn include @GraphQLSyntax syntax/graphql.vim
    1              0.000004 unlet b:graphql_nested_syntax
                            
    1              0.000005 if exists('s:current_syntax')
    1              0.000002   let b:current_syntax = s:current_syntax
    1              0.000001 endif
                            
    1   0.000035   0.000028 let s:tags = '\%(' . join(graphql#javascript_tags(), '\|') . '\)'
                            
    1   0.000033   0.000008 if graphql#has_syntax_group('jsTemplateExpression')
                              " pangloss/vim-javascript
    1              0.000039   exec 'syntax region graphqlTemplateString matchgroup=jsTemplateString start=+' . s:tags . '\@20<=`+ skip=+\\\\\|\\`+ end=+`+ contains=@GraphQLSyntax,jsTemplateExpression,jsSpecial extend'
    1              0.000014   exec 'syntax match graphqlTaggedTemplate +' . s:tags . '\ze`+ nextgroup=graphqlTemplateString'
    1              0.000016   syntax region graphqlTemplateExpression start=+${+ end=+}+ contained contains=jsTemplateExpression containedin=graphqlFold keepend
                            
    1              0.000022   syntax region graphqlTemplateString matchgroup=jsTemplateString start=+`#\s\{,4\}gql\>\s*$+ skip=+\\\\\|\\`+ end=+`+ contains=@GraphQLSyntax,jsTemplateExpression,jsSpecial extend
                            
    1              0.000005   hi def link graphqlTemplateString jsTemplateString
    1              0.000004   hi def link graphqlTaggedTemplate jsTaggedTemplate
    1              0.000004   hi def link graphqlTemplateExpression jsTemplateExpression
                            
    1              0.000010   syn cluster jsExpression add=graphqlTemplateString,graphqlTaggedTemplate
    1              0.000005   syn cluster graphqlTaggedTemplate add=graphqlTemplateString
                            elseif graphql#has_syntax_group('javaScriptStringT')
                              " runtime/syntax/javascript.vim
                              exec 'syntax region graphqlTemplateString matchgroup=javaScriptStringT start=+' . s:tags . '\@20<=`+ skip=+\\\\\|\\`+ end=+`+ contains=@GraphQLSyntax,javaScriptSpecial,javaScriptEmbed,@htmlPreproc extend'
                              exec 'syntax match graphqlTaggedTemplate +' . s:tags . '\ze`+ nextgroup=graphqlTemplateString'
                              syntax region graphqlTemplateExpression start=+${+ end=+}+ contained contains=@javaScriptEmbededExpr containedin=graphqlFold keepend
                            
                              syntax region graphqlTemplateString matchgroup=javaScriptStringT start=+`#\s\{,4\}gql\>\s*$+ skip=+\\\\\|\\`+ end=+`+ contains=@GraphQLSyntax,javaScriptSpecial,javaScriptEmbed,@htmlPreproc extend
                            
                              hi def link graphqlTemplateString javaScriptStringT
                              hi def link graphqlTaggedTemplate javaScriptEmbed
                              hi def link graphqlTemplateExpression javaScriptEmbed
                            
                              syn cluster htmlJavaScript add=graphqlTaggedTemplate
                              syn cluster javaScriptEmbededExpr add=graphqlTaggedTemplate
                              syn cluster graphqlTaggedTemplate add=graphqlTemplateString
    1              0.000005 endif

SCRIPT  /Users/Ragglesoft/.config/nvim/autoload/plugged/vim-polyglot/syntax/graphql.vim
Sourced 1 time
Total time:   0.001726
 Self time:   0.001703

count  total (s)   self (s)
    1   0.000089   0.000066 if polyglot#init#is_disabled(expand('<sfile>:p'), 'graphql', 'syntax/graphql.vim')
                              finish
    1              0.000001 endif
                            
                            " Copyright (c) 2016-2021 Jon Parise <jon@indelible.org>
                            "
                            " Permission is hereby granted, free of charge, to any person obtaining a copy
                            " of this software and associated documentation files (the "Software"), to
                            " deal in the Software without restriction, including without limitation the
                            " rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
                            " sell copies of the Software, and to permit persons to whom the Software is
                            " furnished to do so, subject to the following conditions:
                            "
                            " The above copyright notice and this permission notice shall be included in
                            " all copies or substantial portions of the Software.
                            "
                            " THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
                            " IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
                            " FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
                            " AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
                            " LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
                            " FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
                            " IN THE SOFTWARE.
                            "
                            " Language: GraphQL
                            " Maintainer: Jon Parise <jon@indelible.org>
                            
    1              0.000003 if exists('b:current_syntax')
                              finish
    1              0.000000 endif
                            
    1              0.000002 syn case match
                            
    1              0.000021 syn match graphqlComment    "#.*$" contains=@Spell
                            
    1              0.000006 syn match graphqlOperator   "=" display
    1              0.000004 syn match graphqlOperator   "!" display
    1              0.000003 syn match graphqlOperator   "|" display
    1              0.000003 syn match graphqlOperator   "&" display
    1              0.000004 syn match graphqlOperator   "\M..." display
                            
    1              0.000004 syn keyword graphqlBoolean  true false
    1              0.000003 syn keyword graphqlNull     null
    1              0.000009 syn match   graphqlNumber   "-\=\<\%(0\|[1-9]\d*\)\%(\.\d\+\)\=\%([eE][-+]\=\d\+\)\=\>" display
    1              0.000009 syn region  graphqlString   start=+"+  skip=+\\\\\|\\"+  end=+"\|$+
    1              0.000007 syn region  graphqlString   start=+"""+ skip=+\\"""+ end=+"""+
                            
    1              0.000011 syn keyword graphqlKeyword on nextgroup=graphqlType,graphqlDirectiveLocation skipwhite
                            
    1              0.000008 syn keyword graphqlStructure enum scalar type union nextgroup=graphqlType skipwhite
    1              0.000008 syn keyword graphqlStructure input interface subscription nextgroup=graphqlType skipwhite
    1              0.000006 syn keyword graphqlStructure implements nextgroup=graphqlType skipwhite
    1              0.000007 syn keyword graphqlStructure query mutation fragment nextgroup=graphqlName skipwhite
    1              0.000007 syn keyword graphqlStructure directive nextgroup=graphqlDirective skipwhite
    1              0.000006 syn keyword graphqlStructure extend nextgroup=graphqlStructure skipwhite
    1              0.000006 syn keyword graphqlStructure schema nextgroup=graphqlFold skipwhite
                            
    1              0.000005 syn match graphqlDirective  "\<@\h\w*\>"   display
    1              0.000004 syn match graphqlVariable   "\<\$\h\w*\>"  display
    1              0.000004 syn match graphqlName       "\<\h\w*\>"    display
    1              0.000004 syn match graphqlType       "\<_*\u\w*\>"  display
                            
                            " https://graphql.github.io/graphql-spec/June2018/#ExecutableDirectiveLocation
    1              0.000004 syn keyword graphqlDirectiveLocation QUERY MUTATION SUBSCRIPTION FIELD
    1              0.000004 syn keyword graphqlDirectiveLocation FRAGMENT_DEFINITION FRAGMENT_SPREAD
    1              0.000003 syn keyword graphqlDirectiveLocation INLINE_FRAGMENT
                            " https://graphql.github.io/graphql-spec/June2018/#TypeSystemDirectiveLocation
    1              0.000004 syn keyword graphqlDirectiveLocation SCHEMA SCALAR OBJECT FIELD_DEFINITION
    1              0.000003 syn keyword graphqlDirectiveLocation ARGUMENT_DEFINITION INTERFACE UNION
    1              0.000003 syn keyword graphqlDirectiveLocation ENUM ENUM_VALUE INPUT_OBJECT
    1              0.000003 syn keyword graphqlDirectiveLocation INPUT_FIELD_DEFINITION
                            
    1              0.000003 syn keyword graphqlMetaFields __schema __type __typename
                            
    1              0.000012 syn region  graphqlFold matchgroup=graphqlBraces start="{" end="}" transparent fold contains=ALLBUT,graphqlStructure
    1              0.000014 syn region  graphqlList matchgroup=graphqlBraces start="\[" end="]" transparent contains=ALLBUT,graphqlDirective,graphqlStructure
                            
    1              0.000026 hi def link graphqlComment          Comment
    1              0.000018 hi def link graphqlOperator         Operator
                            
    1              0.000013 hi def link graphqlBraces           Delimiter
                            
    1              0.000010 hi def link graphqlBoolean          Boolean
    1              0.000010 hi def link graphqlNull             Keyword
    1              0.000010 hi def link graphqlNumber           Number
    1              0.000009 hi def link graphqlString           String
                            
    1              0.000009 hi def link graphqlDirective        PreProc
    1              0.000644 hi def link graphqlDirectiveLocation Special
    1              0.000017 hi def link graphqlName             Identifier
    1              0.000012 hi def link graphqlMetaFields       Special
    1              0.000010 hi def link graphqlKeyword          Keyword
    1              0.000009 hi def link graphqlStructure        Structure
    1              0.000009 hi def link graphqlType             Type
    1              0.000010 hi def link graphqlVariable         Identifier
                            
    1              0.000008 if !get(b:, 'graphql_nested_syntax')
                                syn sync minlines=500
    1              0.000001 endif
                            
    1              0.000011 let b:current_syntax = 'graphql'

SCRIPT  /Users/Ragglesoft/.config/nvim/autoload/plugged/vim-polyglot/after/syntax/javascript/sql.vim
Sourced 1 time
Total time:   0.007286
 Self time:   0.003529

count  total (s)   self (s)
    1   0.000139   0.000114 if polyglot#init#is_disabled(expand('<sfile>:p'), 'javascript-sql', 'after/syntax/javascript/sql.vim')
                              finish
    1              0.000001 endif
                            
                            " Vim plugin
                            " Language: JavaScript
                            " Maintainer: Ian Langworth <ian@langworth.com>
                            
    1              0.000030 if exists('b:current_syntax')
    1              0.000003   let s:current_syntax = b:current_syntax
    1              0.000002   unlet b:current_syntax
    1              0.000001 endif
                            
    1   0.006368   0.002635 exec 'syntax include @SQLSyntax syntax/' . g:javascript_sql_dialect . '.vim'
    1              0.000005 if exists('s:current_syntax')
    1              0.000003   let b:current_syntax = s:current_syntax
    1              0.000001 endif
                            
    1              0.000039 syntax region sqlTemplateString start=+`+ skip=+\\\(`\|$\)+ end=+`+ contains=@SQLSyntax,jsTemplateExpression,jsSpecial extend
    1              0.000013 exec 'syntax match sqlTaggedTemplate +\%(SQL\)\%(`\)\@=+ nextgroup=sqlTemplateString'
                            
    1              0.000007 hi def link sqlTemplateString jsTemplateString
    1              0.000004 hi def link sqlTaggedTemplate jsTaggedTemplate
                            
    1              0.000007 syn cluster jsExpression add=sqlTaggedTemplate
    1              0.000011 syn cluster sqlTaggedTemplate add=sqlTemplateString

SCRIPT  /Users/Ragglesoft/.config/nvim/autoload/plugged/vim-polyglot/syntax/sql.vim
Sourced 1 time
Total time:   0.003008
 Self time:   0.000968

count  total (s)   self (s)
    1   0.000070   0.000049 if polyglot#init#is_disabled(expand('<sfile>:p'), 'sql', 'syntax/sql.vim')
                              finish
    1              0.000001 endif
                            
                            " Vim syntax file loader
                            " Language:    SQL
                            " Maintainer:  David Fishburn <fishburn at ianywhere dot com>
                            " Last Change: Thu Sep 15 2005 10:30:02 AM
                            " Version:     1.0
                            
                            " Description: Checks for a:
                            "                  buffer local variable,
                            "                  global variable,
                            "              If the above exist, it will source the type specified.
                            "              If none exist, it will source the default sql.vim file.
                            "
                            " quit when a syntax file was already loaded
    1              0.000003 if exists("b:current_syntax")
                                finish
    1              0.000001 endif
                            
                            " Default to the standard Vim distribution file
    1              0.000005 let filename = 'sqloracle'
                            
                            " Check for overrides.  Buffer variables have the highest priority.
    1              0.000002 if exists("b:sql_type_override")
                                " Check the runtimepath to see if the file exists
                                if globpath(&runtimepath, 'syntax/'.b:sql_type_override.'.vim') != ''
                                    let filename = b:sql_type_override
                                endif
    1              0.000002 elseif exists("g:sql_type_default")
                                if globpath(&runtimepath, 'syntax/'.g:sql_type_default.'.vim') != ''
                                    let filename = g:sql_type_default
                                endif
    1              0.000001 endif
                            
                            " Source the appropriate file
    1   0.002368   0.000350 exec 'runtime syntax/'.filename.'.vim'
                            
                            " vim:sw=4:

SCRIPT  /Users/Ragglesoft/.config/nvim/autoload/plugged/vim-polyglot/syntax/sqloracle.vim
Sourced 1 time
Total time:   0.001972
 Self time:   0.001951

count  total (s)   self (s)
    1   0.000068   0.000048 if polyglot#init#is_disabled(expand('<sfile>:p'), 'sql', 'syntax/sqloracle.vim')
                              finish
    1              0.000001 endif
                            
                            " Vim syntax file
                            " Language:	SQL, PL/SQL (Oracle 11g)
                            " Maintainer:	Christian Brabandt
                            " Repository:   https://github.com/chrisbra/vim-sqloracle-syntax
                            " License:      Vim
                            " Previous Maintainer:	Paul Moore
                            " Last Change:	2018 June 24
                            
                            " Changes:
                            " 02.04.2016: Support for when keyword
                            " 03.04.2016: Support for join related keywords
                            " 22.07.2016: Support Oracle Q-Quote-Syntax
                            " 25.07.2016: Support for Oracle N'-Quote syntax
                            " 22.06.2018: Remove skip part for sqlString (do not escape strings)
                            " (https://web.archive.org/web/20150922065035/https://mariadb.com/kb/en/sql-99/character-string-literals/)
                            
    1              0.000003 if exists("b:current_syntax")
                              finish
    1              0.000000 endif
                            
    1              0.000002 syn case ignore
                            
                            " The SQL reserved words, defined as keywords.
                            
    1              0.000014 syn keyword sqlSpecial	false null true
                            
    1              0.000024 syn keyword sqlKeyword	access add as asc begin by case check cluster column
    1              0.000015 syn keyword sqlKeyword	cache compress connect current cursor decimal default desc
    1              0.000012 syn keyword sqlKeyword	else elsif end exception exclusive file for from
    1              0.000010 syn keyword sqlKeyword	function group having identified if immediate increment
    1              0.000013 syn keyword sqlKeyword	index initial initrans into is level link logging loop
    1              0.000012 syn keyword sqlKeyword	maxextents maxtrans mode modify monitoring
    1              0.000011 syn keyword sqlKeyword	nocache nocompress nologging noparallel nowait of offline on online start
    1              0.000010 syn keyword sqlKeyword	parallel successful synonym table tablespace then to trigger uid
    1              0.000008 syn keyword sqlKeyword	unique user validate values view when whenever
    1              0.000008 syn keyword sqlKeyword	where with option order pctfree pctused privileges procedure
    1              0.000008 syn keyword sqlKeyword	public resource return row rowlabel rownum rows
    1              0.000008 syn keyword sqlKeyword	session share size smallint type using
    1              0.000007 syn keyword sqlKeyword	join cross inner outer left right
                            
    1              0.000007 syn keyword sqlOperator	not and or
    1              0.000008 syn keyword sqlOperator	in any some all between exists
    1              0.000007 syn keyword sqlOperator	like escape
    1              0.000007 syn keyword sqlOperator	union intersect minus
    1              0.000007 syn keyword sqlOperator	prior distinct
    1              0.000006 syn keyword sqlOperator	sysdate out
                            
    1              0.000004 syn keyword sqlStatement analyze audit comment commit
    1              0.000005 syn keyword sqlStatement delete drop execute explain grant lock noaudit
    1              0.000004 syn keyword sqlStatement rename revoke rollback savepoint set
    1              0.000003 syn keyword sqlStatement truncate
                            " next ones are contained, so folding works.
    1              0.000004 syn keyword sqlStatement create update alter select insert contained
                            
    1              0.000005 syn keyword sqlType	bfile blob boolean char character clob date datetime
    1              0.000005 syn keyword sqlType	dec decimal float int integer long mlslabel nchar
    1              0.000005 syn keyword sqlType	nclob number numeric nvarchar2 precision raw rowid
    1              0.000008 syn keyword sqlType	smallint real timestamp urowid varchar varchar2 varray
                            
                            " Strings:
    1              0.000013 syn region sqlString	matchgroup=Quote start=+n\?"+     end=+"+
    1              0.000008 syn region sqlString	matchgroup=Quote start=+n\?'+     end=+'+
    1              0.000010 syn region sqlString	matchgroup=Quote start=+n\?q'\z([^[(<{]\)+    end=+\z1'+
    1              0.000007 syn region sqlString	matchgroup=Quote start=+n\?q'<+   end=+>'+
    1              0.000007 syn region sqlString	matchgroup=Quote start=+n\?q'{+   end=+}'+
    1              0.000007 syn region sqlString	matchgroup=Quote start=+n\?q'(+   end=+)'+
    1              0.000007 syn region sqlString	matchgroup=Quote start=+n\?q'\[+  end=+]'+
                            
                            " Numbers:
    1              0.000006 syn match sqlNumber	"-\=\<\d*\.\=[0-9_]\>"
                            
                            " Comments:
    1              0.000067 syn region sqlComment	start="/\*"  end="\*/" contains=sqlTodo,@Spell fold 
    1              0.000011 syn match sqlComment	"--.*$" contains=sqlTodo,@Spell
    1              0.000009 syn match sqlComment "^rem.*$" contains=sqlTodo,@Spell
                            
                            " Setup Folding:
                            " this is a hack, to get certain statements folded.
                            " the keywords create/update/alter/select/insert need to
                            " have contained option.
    1              0.000010 syn region sqlFold start='^\s*\zs\c\(Create\|Update\|Alter\|Select\|Insert\)' end=';$\|^$' transparent fold contains=ALL
                            
    1              0.000003 syn sync ccomment sqlComment
                            
                            " Functions:
                            " (Oracle 11g)
                            " Aggregate Functions
    1              0.000044 syn keyword sqlFunction	avg collect corr corr_s corr_k count covar_pop covar_samp cume_dist dense_rank first
    1              0.000403 syn keyword sqlFunction	group_id grouping grouping_id last max median min percentile_cont percentile_disc percent_rank rank
    1              0.000030 syn keyword sqlFunction	regr_slope regr_intercept regr_count regr_r2 regr_avgx regr_avgy regr_sxx regr_syy regr_sxy
    1              0.000015 syn keyword sqlFunction	stats_binomial_test stats_crosstab stats_f_test stats_ks_test stats_mode stats_mw_test
    1              0.000010 syn keyword sqlFunction	stats_one_way_anova stats_t_test_one stats_t_test_paired stats_t_test_indep stats_t_test_indepu
    1              0.000009 syn keyword sqlFunction	stats_wsr_test stddev stddev_pop stddev_samp sum
    1              0.000008 syn keyword sqlFunction	sys_xmlagg var_pop var_samp variance xmlagg
                            " Char Functions
    1              0.000008 syn keyword sqlFunction	ascii chr concat initcap instr length lower lpad ltrim
    1              0.000009 syn keyword sqlFunction	nls_initcap nls_lower nlssort nls_upper regexp_instr regexp_replace
    1              0.000010 syn keyword sqlFunction	regexp_substr replace rpad rtrim soundex substr translate treat trim upper
                            " Comparison Functions
    1              0.000007 syn keyword sqlFunction	greatest least
                            " Conversion Functions
    1              0.000008 syn keyword sqlFunction	asciistr bin_to_num cast chartorowid compose convert
    1              0.000008 syn keyword sqlFunction	decompose hextoraw numtodsinterval numtoyminterval rawtohex rawtonhex rowidtochar
    1              0.000008 syn keyword sqlFunction	rowidtonchar scn_to_timestamp timestamp_to_scn to_binary_double to_binary_float
    1              0.000009 syn keyword sqlFunction	to_char to_char to_char to_clob to_date to_dsinterval to_lob to_multi_byte
    1              0.000009 syn keyword sqlFunction	to_nchar to_nchar to_nchar to_nclob to_number to_dsinterval to_single_byte
    1              0.000008 syn keyword sqlFunction	to_timestamp to_timestamp_tz to_yminterval to_yminterval translate unistr
                            " DataMining Functions
    1              0.000008 syn keyword sqlFunction	cluster_id cluster_probability cluster_set feature_id feature_set
    1              0.000007 syn keyword sqlFunction	feature_value prediction prediction_bounds prediction_cost
    1              0.000008 syn keyword sqlFunction	prediction_details prediction_probability prediction_set
                            " Datetime Functions
    1              0.000008 syn keyword sqlFunction	add_months current_date current_timestamp dbtimezone extract
    1              0.000008 syn keyword sqlFunction	from_tz last_day localtimestamp months_between new_time
    1              0.000007 syn keyword sqlFunction	next_day numtodsinterval numtoyminterval round sessiontimezone
    1              0.000008 syn keyword sqlFunction	sys_extract_utc sysdate systimestamp to_char to_timestamp
    1              0.000008 syn keyword sqlFunction	to_timestamp_tz to_dsinterval to_yminterval trunc tz_offset
                            " Numeric Functions
    1              0.000009 syn keyword sqlFunction	abs acos asin atan atan2 bitand ceil cos cosh exp
    1              0.000008 syn keyword sqlFunction	floor ln log mod nanvl power remainder round sign
    1              0.000008 syn keyword sqlFunction	sin sinh sqrt tan tanh trunc width_bucket
                            " NLS Functions
    1              0.000008 syn keyword sqlFunction	ls_charset_decl_len nls_charset_id nls_charset_name
                            " Various Functions
    1              0.000009 syn keyword sqlFunction	bfilename cardin coalesce collect decode dump empty_blob empty_clob
    1              0.000009 syn keyword sqlFunction	lnnvl nullif nvl nvl2 ora_hash powermultiset powermultiset_by_cardinality
    1              0.000008 syn keyword sqlFunction	sys_connect_by_path sys_context sys_guid sys_typeid uid user userenv vsizeality
                            " XML Functions
    1              0.000008 syn keyword sqlFunction	appendchildxml deletexml depth extract existsnode extractvalue insertchildxml
    1              0.000009 syn keyword sqlFunction	insertxmlbefore path sys_dburigen sys_xmlagg sys_xmlgen updatexml xmlagg xmlcast
    1              0.000008 syn keyword sqlFunction	xmlcdata xmlcolattval xmlcomment xmlconcat xmldiff xmlelement xmlexists xmlforest
    1              0.000008 syn keyword sqlFunction	xmlparse xmlpatch xmlpi xmlquery xmlroot xmlsequence xmlserialize xmltable xmltransform
                            " Todo:
    1              0.000005 syn keyword sqlTodo TODO FIXME XXX DEBUG NOTE contained
                            
                            " Define the default highlighting.
    1              0.000014 hi def link Quote		Special
    1              0.000012 hi def link sqlComment		Comment
    1              0.000015 hi def link sqlFunction		Function
    1              0.000009 hi def link sqlKeyword		sqlSpecial
    1              0.000009 hi def link sqlNumber		Number
    1              0.000008 hi def link sqlOperator		sqlStatement
    1              0.000008 hi def link sqlSpecial		Special
    1              0.000008 hi def link sqlStatement	Statement
    1              0.000008 hi def link sqlString		String
    1              0.000008 hi def link sqlType		Type
    1              0.000008 hi def link sqlTodo		Todo
                            
    1              0.000005 let b:current_syntax = "sql"
                            " vim: ts=8

SCRIPT  /usr/local/Cellar/neovim/0.5.0/share/nvim/runtime/syntax/sql.vim
Sourced 1 time
Total time:   0.000679
 Self time:   0.000679

count  total (s)   self (s)
                            " Vim syntax file loader
                            " Language:    SQL
                            " Maintainer:  David Fishburn <fishburn at ianywhere dot com>
                            " Last Change: Thu Sep 15 2005 10:30:02 AM
                            " Version:     1.0
                            
                            " Description: Checks for a:
                            "                  buffer local variable,
                            "                  global variable,
                            "              If the above exist, it will source the type specified.
                            "              If none exist, it will source the default sql.vim file.
                            "
                            " quit when a syntax file was already loaded
    1              0.000010 if exists("b:current_syntax")
    1              0.000002     finish
                            endif
                            
                            " Default to the standard Vim distribution file
                            let filename = 'sqloracle'
                            
                            " Check for overrides.  Buffer variables have the highest priority.
                            if exists("b:sql_type_override")
                                " Check the runtimepath to see if the file exists
                                if globpath(&runtimepath, 'syntax/'.b:sql_type_override.'.vim') != ''
                                    let filename = b:sql_type_override
                                endif
                            elseif exists("g:sql_type_default")
                                if globpath(&runtimepath, 'syntax/'.g:sql_type_default.'.vim') != ''
                                    let filename = g:sql_type_default
                                endif
                            endif
                            
                            " Source the appropriate file
                            exec 'runtime syntax/'.filename.'.vim'
                            
                            " vim:sw=4:

SCRIPT  /Users/Ragglesoft/.vim/plugged/vim-jsx-pretty/after/syntax/javascript.vim
Sourced 27 times
Total time:   0.067593
 Self time:   0.003942

count  total (s)   self (s)
   27              0.000251 if get(g:, 'vim_jsx_pretty_disable_js', 0)
                              finish
   27              0.000019 endif
                            
   27   0.066381   0.002730 source <sfile>:h/jsx.vim

SCRIPT  /Users/Ragglesoft/.vim/plugged/vim-jsx-pretty/after/syntax/jsx.vim
Sourced 27 times
Total time:   0.063153
 Self time:   0.040266

count  total (s)   self (s)
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            " Vim syntax file
                            "
                            " Language: javascript.jsx
                            " Maintainer: MaxMellon <maxmellon1994@gmail.com>
                            "
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
   27              0.000274 let s:jsx_cpo = &cpo
   27   0.000245   0.000201 set cpo&vim
                            
   27              0.000035 syntax case match
                            
   27              0.000114 if exists('b:current_syntax')
   27              0.000071   let s:current_syntax = b:current_syntax
   27              0.000061   unlet b:current_syntax
   27              0.000019 endif
                            
   27              0.000057 if exists('s:current_syntax')
   27              0.000043   let b:current_syntax = s:current_syntax
   27              0.000014 endif
                            
   27              0.000393 if hlexists("jsDebugger") || hlexists("jsNoise")    " yuezk/vim-js or pangloss/vim-javascript
   27              0.000238   syntax cluster jsExpression add=jsxRegion
                            elseif hlexists("javascriptOpSymbols")    " othree/yajs.vim
                              " refine the javascript line comment
                              syntax region javascriptLineComment start=+//+ end=/$/ contains=@Spell,javascriptCommentTodo extend keepend
                              syntax cluster javascriptValue add=jsxRegion
                              syntax cluster javascriptNoReserved add=jsxElement,jsxTag
                            else    " build-in javascript syntax
                              " refine the javascript line comment
                              syntax region javaScriptLineComment start=+//+ end=/$/ contains=@Spell,javascriptCommentTodo extend keepend
                            
                              " refine the template string syntax
                              syntax region javaScriptEmbed matchgroup=javaScriptEmbedBraces start=+\${+ end=+}+ contained contains=@javaScriptEmbededExpr
                            
                              " add a javaScriptBlock group for build-in syntax
                              syntax region javaScriptBlock
                                    \ matchgroup=javaScriptBraces
                                    \ start="{"
                                    \ end="}"
                                    \ contained
                                    \ extend
                                    \ contains=javaScriptBlock,@javaScriptEmbededExpr,javaScript.*
                                    \ fold
                            
                              syntax cluster javaScriptEmbededExpr add=jsxRegion,javaScript.*
   27              0.000038 endif
                            
   27   0.034137   0.011383 runtime syntax/jsx_pretty.vim
                            
   27              0.000059 let b:current_syntax = 'javascript.jsx'
                            
   27   0.000432   0.000343 let &cpo = s:jsx_cpo
   27              0.000132 unlet s:jsx_cpo

FUNCTION  <SNR>61_unc_path()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:169
Called 58 times
Total time:   0.011963
 Self time:   0.000856

count  total (s)   self (s)
   58   0.011898   0.000791   return s:abs_path(a:bufnr, 0) =~ '^\\\\'

FUNCTION  airline#extensions#quickfix#inactive_qf_window()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/quickfix.vim:28
Called 265 times
Total time:   0.003332
 Self time:   0.003332

count  total (s)   self (s)
  265              0.002228   if getbufvar(a:2.bufnr, '&filetype') is# 'qf' && !empty(airline#util#getwinvar(a:2.winnr, 'quickfix_title', ''))
                                call setwinvar(a:2.winnr, 'airline_section_c', '[%{get(w:, "quickfix_title", "")}] %f %m')
  265              0.000164   endif

FUNCTION  coc#client#get_channel()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/client.vim:149
Called 1197 times
Total time:   0.009052
 Self time:   0.009052

count  total (s)   self (s)
 1197              0.002143   if s:is_vim
                                return a:client['channel']
 1197              0.000784   endif
 1197              0.002421   return a:client['chan_id']

FUNCTION  1()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/path.vim:14
Called 6 times
Total time:   0.000352
 Self time:   0.000293

count  total (s)   self (s)
    6              0.000016     let l:prependWorkingDir = 0
                            
    6   0.000115   0.000056     if nerdtree#runningWindows()
                                    let l:prependWorkingDir = a:pathStr !~# '^.:\(\\\|\/\)\?' && a:pathStr !~# '^\(\\\\\|\/\/\)'
    6              0.000006     else
    6              0.000049         let l:prependWorkingDir = a:pathStr !~# '^/'
    6              0.000005     endif
                            
    6              0.000014     let l:result = a:pathStr
                            
    6              0.000009     if l:prependWorkingDir
                                    let l:result = getcwd()
                            
                                    if l:result[-1:] == nerdtree#slash()
                                        let l:result = l:result . a:pathStr
                                    else
                                        let l:result = l:result . nerdtree#slash() . a:pathStr
                                    endif
    6              0.000004     endif
                            
    6              0.000010     return l:result

FUNCTION  3()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/path.vim:47
Called 1209 times
Total time:   0.082827
 Self time:   0.059221

count  total (s)   self (s)
 1209   0.025880   0.010694     let self.cachedDisplayString = g:NERDTreeNodeDelimiter . self.getLastPathComponent(1)
                            
 1209              0.001231     if self.isExecutable
                                    let self.cachedDisplayString = self.addDelimiter(self.cachedDisplayString) . '*'
 1209              0.000655     endif
                            
 1209              0.003963     let self._bookmarkNames = []
 1209   0.016953   0.008532     for i in g:NERDTreeBookmark.Bookmarks()
                                    if i.path.equals(self)
                                        call add(self._bookmarkNames, i.name)
                                    endif
 1209              0.001437     endfor
 1209              0.003285     if !empty(self._bookmarkNames) && g:NERDTreeMarkBookmarks ==# 1
                                    let self.cachedDisplayString = self.addDelimiter(self.cachedDisplayString) . ' {' . join(self._bookmarkNames) . '}'
 1209              0.000647     endif
                            
 1209              0.001294     if self.isSymLink
                                    let self.cachedDisplayString = self.addDelimiter(self.cachedDisplayString) . ' -> ' . self.symLinkDest
 1209              0.000618     endif
                            
 1209              0.001115     if self.isReadOnly
                                    let self.cachedDisplayString = self.addDelimiter(self.cachedDisplayString) . ' ['.g:NERDTreeGlyphReadOnly.']'
 1209              0.000615     endif

FUNCTION  <SNR>64_record()
    Defined: ~/.vim/plugged/ctrlp.vim/autoload/ctrlp/mrufiles.vim:59
Called 31 times
Total time:   0.005137
 Self time:   0.000837

count  total (s)   self (s)
   31              0.000087 	if s:locked | retu | en
   31              0.000070 	let bufnr = a:bufnr + 0
   31              0.000092 	let bufname = bufname(bufnr)
   31              0.000085 	if bufnr > 0 && !empty(bufname)
    7              0.000140 		cal filter(s:mrbs, 'v:val != bufnr')
    7              0.000025 		cal insert(s:mrbs, bufnr)
    7   0.004444   0.000144 		cal s:addtomrufs(bufname)
   31              0.000017 	en

FUNCTION  airline#parts#filetype()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/parts.vim:102
Called 522 times
Total time:   0.011933
 Self time:   0.007217

count  total (s)   self (s)
  522   0.011438   0.006722   return (airline#util#winwidth() < 90 && strlen(&filetype) > 3) ? matchstr(&filetype, '...'). (&encoding is? 'utf-8' ? '…' : '>') : &filetype

FUNCTION  RltvNmbr#RltvNmbrCtrl()
    Defined: ~/.vim/plugged/RltvNmbr.vim/autoload/RltvNmbr.vim:148
Called 1 time
Total time:   0.000145
 Self time:   0.000145

count  total (s)   self (s)
                            "  call Dfunc("RltvNmbr#RltvNmbrCtrl(start=".a:start.")")
                            
    1              0.000010   if      a:start && !exists("s:rltvnmbr_{bufnr('%')}")
                               let s:rltvnmbr_{bufnr("%")}= 1
                               let b:rltvnmbrmode         = 1
                            
                               if !exists("s:rltvnmbr_signs")
                            	let s:rltvnmbr_signs= 1
                            	hi default HL_RltvNmbr_Minus	gui=none,italic ctermfg=red   ctermbg=black guifg=red   guibg=black
                            	hi default HL_RltvNmbr_Positive	gui=none,italic ctermfg=green ctermbg=black guifg=green guibg=black
                            	silent call s:AvoidOtherSigns()
                                let L= 1
                                while L <= 99
                            	 exe "sign define RLTVN_M".L.' text='.string(L).' texthl=HL_RltvNmbr_Minus'
                            	 exe "sign define RLTVN_P".L.' text='.string(L).' texthl=HL_RltvNmbr_Positive'
                                 let L= L+1
                                endwhile
                               endif
                               sign define RLTVCURID text=-- texthl=Ignore
                            
                               exe "menu ".g:DrChipTopLvlMenu."RltvNmbr.Stop<tab>:RltvNmbr!	:RltvNmbr!<cr>"
                               exe 'silent! unmenu '.g:DrChipTopLvlMenu.'RltvNmbr.Start'
                               call s:RltvNmbr(1)
                               augroup RltvNmbrAutoCmd
                            	au!
                                au CursorHold           * call <SID>RltvNmbr(2,"cursorhold")
                            	au CursorMoved          * call <SID>RltvNmbr(2,"cursormoved")
                            	au FileChangedShellPost * call <SID>RltvNmbr(2,"filechangedshellpost")
                            	au FocusGained          * call <SID>RltvNmbr(2,"focusgained")
                            	au FocusLost            * call <SID>RltvNmbr(2,"focuslost")
                            	au ShellCmdPost         * call <SID>RltvNmbr(2,"shellcmdpost")
                            	au ShellFilterPost      * call <SID>RltvNmbr(2,"shellfilterpost")
                            	au TabEnter             * call <SID>RltvNmbr(2,"tabenter")
                            	au VimResized           * call <SID>RltvNmbr(2,"vimresized")
                            	au WinEnter             * call <SID>RltvNmbr(2,"winenter")
                                au ColorScheme          * call <SID>ColorschemeLoaded()
                               augroup END
                            
    1              0.000002   elseif !a:start && exists("s:rltvnmbr_{bufnr('%')}")
                               let b:rltvnmbrmode         = 0
                               unlet s:rltvnmbr_{bufnr("%")}
                               augroup RltvNmbrAutoCmd
                            	au!
                               augroup END
                               augroup! RltvNmbrAutoCmd
                               call s:RltvNmbr(3)
                               exe "sign unplace ".s:RLTVNMBR." buffer=".bufnr("%")
                               exe "menu ".g:DrChipTopLvlMenu."RltvNmbr.Start<tab>:RltvNmbr	:RltvNmbr<cr>"
                               exe 'silent! unmenu '.g:DrChipTopLvlMenu.'RltvNmbr.Stop'
                            
    1              0.000000   else
    1              0.000023    echo "RltvNmbr is already ".((a:start)? "enabled" : "off")
    1              0.000001   endif
                            "  call Dret("RltvNmbr#RltvNmbrCtrl")

FUNCTION  airline#extensions#ctrlp#apply()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/ctrlp.vim:70
Called 116 times
Total time:   0.001329
 Self time:   0.001329

count  total (s)   self (s)
                              " disable statusline overwrite if ctrlp already did it
  116              0.001144   return match(&statusline, 'CtrlPwhite') >= 0 ? -1 : 0

FUNCTION  airline#parts#iminsert()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/parts.vim:82
Called 522 times
Total time:   0.004104
 Self time:   0.004104

count  total (s)   self (s)
  522              0.001646   if g:airline_detect_iminsert && &iminsert && exists('b:keymap_name')
                                return toupper(b:keymap_name)
  522              0.000266   endif
  522              0.000367   return ''

FUNCTION  BlinkStop()
    Defined: ~/.config/nvim/vim-plug/movement_alt.vim:62
Called 123 times
Total time:   0.003329
 Self time:   0.003329

count  total (s)   self (s)
                                " Cancel timers
  123              0.000687     if s:blink_timer_id > 0
                                  call timer_stop(s:blink_timer_id)
                                  let s:blink_timer_id = 0
  123              0.000172     endif
  123              0.000188     if s:blink_stop_id > 0
                                  call timer_stop(s:blink_stop_id)
                                  let s:blink_stop_id = 0
  123              0.000071     endif
                                " And clear blink highlight
  123              0.000138     if s:blink_match_id > 0
                                  call BlinkClear()
  123              0.000065     endif

FUNCTION  <SNR>51_path2str()
    Defined: ~/.vim/plugged/nerdtree-git-plugin/nerdtree_plugin/git_status.vim:108
Called 1 time
Total time:   0.000129
 Self time:   0.000009

count  total (s)   self (s)
    1   0.000128   0.000009     return gitstatus#util#FormatPath(a:path)

FUNCTION  coc#compat#buf_del_var()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/compat.vim:66
Called 1 time
Total time:   0.000170
 Self time:   0.000170

count  total (s)   self (s)
    1              0.000002   if !bufloaded(a:bufnr)
                                return
    1              0.000000   endif
    1              0.000003   if exists('*nvim_buf_del_var')
    1              0.000153     silent! call nvim_buf_del_var(a:bufnr, a:name)
                              else
                                if bufnr == bufnr('%')
                                  execute 'unlet! b:'.a:name
                                elseif exists('*win_execute')
                                  let winid = coc#compat#buf_win_id(a:bufnr)
                                  if winid != -1
                                    call win_execute(winid, 'unlet! b:'.a:name)
                                  endif
                                endif
    1              0.000000   endif

FUNCTION  airline#extensions#coc#get_error()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/coc.vim:14
Called 522 times
Total time:   0.026450
 Self time:   0.005643

count  total (s)   self (s)
  522   0.026074   0.005268   return airline#extensions#coc#get('error')

FUNCTION  coc#float#create_pum_float()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/float.vim:875
Called 26 times
Total time:   3.113953
 Self time:   2.672593

count  total (s)   self (s)
   26              0.000300   if !pumvisible() || !s:float_supported
                                return v:null
   26              0.000035   endif
   26              0.000164   let pumbounding = a:config['pumbounding']
   26              0.000123   let pw = pumbounding['width'] + get(pumbounding, 'scrollbar', 0)
   26              0.000142   let rp = &columns - pumbounding['col'] - pw
   26              0.000075   let showRight = pumbounding['col'] > rp ? 0 : 1
   26   0.001112   0.000518   let maxWidth = showRight ? coc#helper#min(rp - 1, a:config['maxWidth']) : coc#helper#min(pumbounding['col'] - 1, a:config['maxWidth'])
   26              0.000087   let maxHeight = &lines - pumbounding['row'] - &cmdheight - 1
   26              0.000040   if maxWidth <= 2 || maxHeight < 1
                                return v:null
   26              0.000013   endif
   26              0.000024   let ch = 0
   26              0.000022   let width = 0
   62              0.000073   for line in a:lines
   36              0.000171     let dw = max([1, strdisplaywidth(line)])
   36              0.000091     let width = max([width, dw + 2])
   36              0.000306     let ch += float2nr(ceil(str2float(string(dw))/(maxWidth - 2)))
   62              0.000048   endfor
   26   0.000589   0.000218   let width = float2nr(coc#helper#min(maxWidth, width))
   26   0.000612   0.000205   let height = float2nr(coc#helper#min(maxHeight, ch))
   26   0.001172   0.000909   let lines = map(a:lines, {_, s -> s =~# '^—' ? repeat('—', width - 2 + (s:is_vim && ch > height ? -1 : 0)) : s})
   26              0.000282   let opts = { 'lines': lines, 'relative': 'editor', 'col': showRight ? pumbounding['col'] + pw : pumbounding['col'] - width - 1, 'row': pumbounding['row'], 'height': height, 'width': width - 2 + (s:is_vim && ch > height ? -1 : 0), }
   26   0.003242   0.000370   call coc#float#close_auto_hide_wins(a:winid)
   26   0.038714   0.000366   let res = coc#float#create_float_win(a:winid, a:bufnr, opts)
   26              0.000050   if empty(res)
                                return v:null
   26              0.000010   endif
   26   0.393393   0.000357   call coc#highlight#add_highlights(res[0], a:config['codes'], a:config['highlights'])
   26              0.000163   call setwinvar(res[0], 'kind', 'pum')
   26              2.666101   redraw
   26              0.000161   if has('nvim')
   26   0.006004   0.000534     call coc#float#nvim_scrollbar(res[0])
   26              0.000014   endif
   26              0.000028   return res

FUNCTION  <SNR>64_addtomrufs()
    Defined: ~/.vim/plugged/ctrlp.vim/autoload/ctrlp/mrufiles.vim:70
Called 7 times
Total time:   0.004300
 Self time:   0.004300

count  total (s)   self (s)
    7              0.000885 	let fn = fnamemodify(a:fname, get(g:, 'ctrlp_tilde_homedir', 0) ? ':p:~' : ':p')
    7              0.000084 	let fn = exists('+ssl') ? tr(fn, '/', '\') : fn
    7              0.000140 	let abs_fn = fnamemodify(fn,':p')
    7              0.002874 	if ( !empty({s:in}) && fn !~# {s:in} ) || ( !empty({s:ex}) && fn =~# {s:ex} ) || !empty(getbufvar('^' . abs_fn . '$', '&bt')) || !filereadable(abs_fn)
    1              0.000006 		retu
    6              0.000013 	en
    6              0.000077 	let idx = index(s:mrufs, fn, 0, !{s:cseno})
    6              0.000008 	if idx
    2              0.000060 		cal filter(s:mrufs, 'v:val !='.( {s:cseno} ? '#' : '?' ).' fn')
    2              0.000008 		cal insert(s:mrufs, fn)
    2              0.000010 		if {s:soup} && idx < 0
                            			cal s:savetofile(s:mergelists())
    2              0.000002 		en
    6              0.000004 	en

FUNCTION  <SNR>28_variables()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/util.vim:239
Called 1 time
Total time:   0.000276
 Self time:   0.000276

count  total (s)   self (s)
    1              0.000150   let info = getbufinfo(a:bufnr)
    1              0.000013   let variables = empty(info) ? {} : copy(info[0]['variables'])
   19              0.000025   for key in keys(variables)
   18              0.000049     if key !~# '\v^coc'
   17              0.000020       unlet variables[key]
   18              0.000006     endif
   19              0.000006   endfor
    1              0.000001   return variables

FUNCTION  229()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/nerdtree.vim:187
Called 3000 times
Total time:   0.013637
 Self time:   0.013637

count  total (s)   self (s)
 3000              0.006283     if !exists('s:NERDTree._PathFilters')
                                    let s:NERDTree._PathFilters = []
 3000              0.001164     endif
 3000              0.002531     return s:NERDTree._PathFilters

FUNCTION  coc#util#do_autocmd()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/util.vim:718
Called 34 times
Total time:   0.000541
 Self time:   0.000541

count  total (s)   self (s)
   34              0.000379   if exists('#User#'.a:name)
                                exe 'doautocmd <nomodeline> User '.a:name
   34              0.000023   endif

FUNCTION  airline#check_mode()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline.vim:216
Called 524 times
Total time:  11.382767
 Self time:   0.068197

count  total (s)   self (s)
  524              0.001762   if !has_key(s:contexts, a:winnr)
                                return ''
  524              0.000367   endif
  524              0.001495   let context = s:contexts[a:winnr]
                            
  524              0.001706   if get(w:, 'airline_active', 1)
  523              0.001559     let m = mode(1)
  523              0.000969     if m ==# "i"
  190              0.000411       let mode = ['insert']
  333              0.000675     elseif m[0] ==# "i"
  119              0.000183       let mode = ['insert']
  214              0.000270     elseif m ==# "Rv"
                                  let mode =['replace']
  214              0.000293     elseif m[0] ==# "R"
                                  let mode = ['replace']
  214              0.003310     elseif m[0] =~# '\v(v|V||s|S|)'
                                  let mode = ['visual']
  214              0.000278     elseif m ==# "t"
                                  let mode = ['terminal']
  214              0.000302     elseif m[0] ==# "c"
                                  let mode = ['commandline']
  214              0.000306     elseif m ==# "no"   " does not work, most likely, Vim does not refresh the statusline in OP mode
                                  let mode = ['normal']
  214              0.000391     elseif m[0:1] ==# 'ni'
                                  let mode = ['insert']
                                  let m = 'ni'
  214              0.000129     else
  214              0.000646       let mode = ['normal']
  523              0.000294     endif
  523              0.002604     if exists("*VMInfos") && !empty(VMInfos())
                                  " Vim plugin Multiple Cursors https://github.com/mg979/vim-visual-multi
                                  let m = 'multi'
  523              0.000291     endif
  523              0.003882     if index(['Rv', 'no', 'ni', 'ix', 'ic', 'multi'], m) == -1
  404              0.000951       let m = m[0]
  523              0.000277     endif
  523              0.003134     let w:airline_current_mode = get(g:airline_mode_map, m, m)
    1              0.000000   else
    1              0.000001     let mode = ['inactive']
    1              0.000003     let w:airline_current_mode = get(g:airline_mode_map, '__')
  524              0.000284   endif
                            
  524              0.002074   if g:airline_detect_modified && &modified
  410              0.001264     call add(mode, 'modified')
  524              0.000289   endif
                            
  524              0.000958   if g:airline_detect_paste && &paste
                                call add(mode, 'paste')
  524              0.000294   endif
                            
  524              0.003712   if g:airline_detect_crypt && exists("+key") && !empty(&key)
                                call add(mode, 'crypt')
  524              0.000240   endif
                            
  524              0.000861   if g:airline_detect_spell && &spell
                                call add(mode, 'spell')
  524              0.000246   endif
                            
  524              0.000757   if &readonly || ! &modifiable
    2              0.000006     call add(mode, 'readonly')
  524              0.000212   endif
                            
  524              0.002699   let mode_string = join(mode)
  524              0.002033   if get(w:, 'airline_lastmode', '') != mode_string
   29   0.016488   0.000602     call airline#highlighter#highlight_modified_inactive(context.bufnr)
   29  11.293704   0.001280     call airline#highlighter#highlight(mode, string(context.bufnr))
   29   0.006721   0.000461     call airline#util#doautocmd('AirlineModeChanged')
   29              0.000078     let w:airline_lastmode = mode_string
  524              0.000256   endif
                            
  524              0.000516   return ''

FUNCTION  airline#util#append()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim:49
Called 3654 times
Total time:   0.037189
 Self time:   0.037189

count  total (s)   self (s)
 3654              0.008936   if a:minwidth > 0 && airline#util#winwidth() < a:minwidth
                                return ''
 3654              0.001555   endif
 3654              0.010611   let prefix = s:spc == "\ua0" ? s:spc : s:spc.s:spc
 3654              0.010184   return empty(a:text) ? '' : prefix.g:airline_left_alt_sep.s:spc.a:text

FUNCTION  coc#util#get_format_opts()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/util.vim:924
Called 39 times
Total time:   0.001421
 Self time:   0.001421

count  total (s)   self (s)
   39              0.000486   if a:bufnr && bufloaded(a:bufnr)
   39              0.000308     let tabsize = getbufvar(a:bufnr, '&shiftwidth')
   39              0.000080     if tabsize == 0
                                  let tabsize = getbufvar(a:bufnr, '&tabstop')
   39              0.000047     endif
   39              0.000276     return [tabsize, getbufvar(a:bufnr, '&expandtab')]
                              endif
                              let tabsize = &shiftwidth == 0 ? &tabstop : &shiftwidth
                              return [tabsize, &expandtab]

FUNCTION  coc#highlight#compose_hlgroup()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/highlight.vim:321
Called 26 times
Total time:   0.000195
 Self time:   0.000195

count  total (s)   self (s)
   26              0.000099   let hlGroup = 'Fg'.a:fgGroup.'Bg'.a:bgGroup
   26              0.000046   if a:fgGroup == a:bgGroup
   26              0.000025     return a:fgGroup
                              endif
                              if hlexists(hlGroup)
                                return hlGroup
                              endif
                              let fg = synIDattr(synIDtrans(hlID(a:fgGroup)), 'fg', 'gui')
                              let bg = synIDattr(synIDtrans(hlID(a:bgGroup)), 'bg', 'gui')
                              if fg =~# '^#' || bg =~# '^#'
                                call s:create_gui_hlgroup(hlGroup, fg, bg, '')
                              else
                                let fg = synIDattr(synIDtrans(hlID(a:fgGroup)), 'fg', 'cterm')
                                let bg = synIDattr(synIDtrans(hlID(a:bgGroup)), 'bg', 'cterm')
                                call s:create_cterm_hlgroup(hlGroup, fg, bg, '')
                              endif
                              return hlGroup

FUNCTION  coc#float#create_buf()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/float.vim:1215
Called 52 times
Total time:   0.015075
 Self time:   0.014955

count  total (s)   self (s)
   52              0.000156   if a:bufnr > 0 && bufloaded(a:bufnr)
   26              0.000053     let bufnr = a:bufnr
   26              0.000014   else
   26              0.000047     if s:is_vim
                                  noa let bufnr = bufadd('')
                                  noa call bufload(bufnr)
                                  call setbufvar(bufnr, '&buflisted', 0)
   26              0.000013     else
   26              0.004245       noa let bufnr = nvim_create_buf(v:false, v:true)
   26              0.000041     endif
   26              0.000112     let bufhidden = get(a:, 2, 'wipe')
   26   0.000975   0.000900     call setbufvar(bufnr, '&buftype', 'nofile')
   26   0.000767   0.000753     call setbufvar(bufnr, '&bufhidden', bufhidden)
   26   0.000706   0.000697     call setbufvar(bufnr, '&swapfile', 0)
   26   0.000706   0.000694     call setbufvar(bufnr, '&undolevels', -1)
                                " neovim's bug
   26   0.000686   0.000676     call setbufvar(bufnr, '&modifiable', 1)
   52              0.000033   endif
   52              0.000157   let lines = get(a:, 1, v:null)
   52              0.000113   if type(lines) != 7
   52              0.000166     if has('nvim')
   52              0.004251       call nvim_buf_set_lines(bufnr, 0, -1, v:false, lines)
                                else
                                  silent call deletebufline(bufnr, 1, '$')
                                  silent call setbufline(bufnr, 1, lines)
   52              0.000039     endif
   52              0.000021   endif
   52              0.000055   return bufnr

FUNCTION  airline#util#try_focusgained()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim:207
Called 7 times
Total time:   0.000513
 Self time:   0.000513

count  total (s)   self (s)
                              " Ignore lasts for at most one second and is cleared on the first
                              " focusgained. We use ignore to prevent system() calls from triggering
                              " FocusGained (which occurs 100% on win32 and seem to sometimes occur under
                              " tmux).
    7              0.000051   let dt = localtime() - s:focusgained_ignore_time
    7              0.000410   let s:focusgained_ignore_time = 0
    7              0.000015   return dt >= 1

FUNCTION  239()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/ui.vim:268
Called 40 times
Total time:   0.000112
 Self time:   0.000112

count  total (s)   self (s)
   40              0.000041     return self._showBookmarks

FUNCTION  <SNR>61_dir()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:214
Called 146 times
Total time:   0.032122
 Self time:   0.004111

count  total (s)   self (s)
  146   0.032013   0.004001   return gitgutter#utility#shellescape(fnamemodify(s:abs_path(a:bufnr, 0), ':h'))

FUNCTION  airline#themes#get_highlight()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/themes.vim:35
Called 29192 times
Total time:   6.669625
 Self time:   0.440952

count  total (s)   self (s)
29192   6.656923   0.428250     return call('airline#highlighter#get_highlight', [a:group] + a:000)

FUNCTION  coc#highlight#create_namespace()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/highlight.vim:510
Called 145 times
Total time:   0.001715
 Self time:   0.001715

count  total (s)   self (s)
  145              0.000467   if type(a:key) == 0
   26              0.000023     return a:key
  119              0.000091   endif
  119              0.000427   if has_key(s:namespace_map, a:key)
  119              0.000307     return s:namespace_map[a:key]
                              endif
                              if has('nvim')
                                let s:namespace_map[a:key] = nvim_create_namespace('coc-'.a:key)
                              else
                                let s:namespace_map[a:key] = s:ns_id
                                let s:ns_id = s:ns_id + 1
                              endif
                              return s:namespace_map[a:key]

FUNCTION  <SNR>171_execute()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/highlight.vim:495
Called 52 times
Total time:   0.370637
 Self time:   0.029944

count  total (s)   self (s)
   52              0.000131   if has('nvim')
   52   0.370183   0.029490     execute 'silent! ' a:cmd
                              else
                                call win_execute(a:winid, a:cmd, 'silent!')
   52              0.000027   endif

FUNCTION  <SNR>169_is_comment()
    Defined: ~/.vim/plugged/vim-jsx-pretty/autoload/jsx_pretty/indent.vim:87
Called 14 times
Total time:   0.000069
 Self time:   0.000069

count  total (s)   self (s)
   14              0.000059   return a:syntax =~? 'comment'

FUNCTION  150()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/tree_dir_node.vim:358
Called 200 times
Total time:   0.360677
 Self time:   0.039670

count  total (s)   self (s)
  200              0.000230     let toReturn = []
 3240              0.003598     for i in self.children
 3040   0.345836   0.024829         if i.path.ignore(self.getNerdtree()) ==# 0
 3000              0.005840             call add(toReturn, i)
 3040              0.001456         endif
 3240              0.001532     endfor
  200              0.000145     return toReturn

FUNCTION  coc#_insert_key()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc.vim:43
Called 70 times
Total time:   0.006477
 Self time:   0.002663

count  total (s)   self (s)
   70              0.000977   if get(a:, 1, 1)
   70   0.004683   0.000869     call coc#_cancel()
   70              0.000046   endif
   70              0.000529   return "\<c-r>=coc#rpc#".a:method."('doKeymap', ['".a:key."'])\<CR>"

FUNCTION  155()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/tree_dir_node.vim:472
Called 2 times
Total time:   0.000453
 Self time:   0.000124

count  total (s)   self (s)
    2              0.000007     let l:options = a:0 ? a:1 : {}
                            
                                " If special options were specified, process them and return.
    2              0.000011     if has_key(l:options, 'where') && !empty(l:options['where'])
                                    let l:opener = g:NERDTreeOpener.New(self.path, l:options)
                                    call l:opener.open(self)
                                    return 0
    2              0.000002     endif
                            
                                " Open any ancestors of this node that render within the same cascade.
    2              0.000005     let l:parent = self.parent
    2   0.000346   0.000017     while !empty(l:parent) && !l:parent.isRoot()
                                    if index(l:parent.getCascade(), self) >= 0
                                        let l:parent.isOpen = 1
                                        let l:parent = l:parent.parent
                                    else
                                        break
                                    endif
    2              0.000004     endwhile
                            
    2              0.000005     let self.isOpen = 1
                            
    2              0.000004     let l:numChildrenCached = 0
    2              0.000006     if empty(self.children)
                                    let l:numChildrenCached = self._initChildren(0)
    2              0.000002     endif
                            
    2              0.000004     return l:numChildrenCached

FUNCTION  airline#extensions#coc#get_warning()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/coc.vim:10
Called 522 times
Total time:   0.034200
 Self time:   0.006517

count  total (s)   self (s)
  522   0.033664   0.005981   return airline#extensions#coc#get('warning')

FUNCTION  gitstatus#util#BuildGitWorkdirCommand()
    Defined: ~/.vim/plugged/nerdtree-git-plugin/autoload/gitstatus/util.vim:50
Called 1 time
Total time:   0.000006
 Self time:   0.000006

count  total (s)   self (s)
    1              0.000006     return [ get(a:opts, 'NERDTreeGitStatusGitBinPath', 'git'), '-C', a:root, 'rev-parse', '--show-toplevel', ]

FUNCTION  airline#extensions#nvimlsp#get()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/nvimlsp.vim:17
Called 1044 times
Total time:   0.062169
 Self time:   0.062169

count  total (s)   self (s)
 1044              0.059688   if luaeval('vim.tbl_isempty(vim.lsp.buf_get_clients(0))')
 1044              0.001260     return ''
                              endif
                            
                              let error_symbol = get(g:, 'airline#extensions#nvimlsp#error_symbol', 'E:')
                              let warning_symbol = get(g:, 'airline#extensions#nvimlsp#warning_symbol', 'W:')
                            
                              let is_err = a:type ==# 'Error'
                            
                              let symbol = is_err ? error_symbol : warning_symbol
                            
                              if luaeval("pcall(require, 'vim.lsp.diagnostic')")
                                let num = v:lua.vim.lsp.diagnostic.get_count(0, a:type)
                              else
                                let num = v:lua.vim.lsp.util.buf_diagnostics_count(a:type)
                              endif
                            
                              return s:airline_nvimlsp_count(num, symbol)

FUNCTION  gitgutter#utility#set_repo_path()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:139
Called 15 times
Total time:   0.059714
 Self time:   0.001611

count  total (s)   self (s)
                              " Values of path:
                              " * non-empty string - path
                              " *               -1 - pending
                              " *               -2 - not tracked by git
                            
   15   0.000324   0.000127   call gitgutter#utility#setbufvar(a:bufnr, 'path', -1)
   15   0.008519   0.000424   let cmd = gitgutter#utility#cd_cmd(a:bufnr, g:gitgutter_git_executable.' '.g:gitgutter_git_args.' ls-files --error-unmatch --full-name -z -- '.gitgutter#utility#shellescape(s:filename(a:bufnr)))
                            
   15   0.000200   0.000169   if g:gitgutter_async && gitgutter#async#available() && !has('vim_starting')
   15              0.000065     let handler = copy(s:set_path_handler)
   15              0.000028     let handler.continuation = a:continuation
   15   0.050180   0.000400     call gitgutter#async#execute(cmd, a:bufnr, handler)
   15              0.000060     return 'async'
                              endif
                            
                              let path = gitgutter#utility#system(cmd)
                              if v:shell_error
                                call gitgutter#utility#setbufvar(a:bufnr, 'path', -2)
                              else
                                call gitgutter#utility#setbufvar(a:bufnr, 'path', s:strip_trailing_new_line(path))
                              endif

FUNCTION  <SNR>166_process_modified_and_added()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:319
Called 75 times
Total time:   0.005913
 Self time:   0.005913

count  total (s)   self (s)
   75              0.000257   let offset = 0
  267              0.000321   while offset < a:from_count
  192              0.000334     let line_number = a:to_line + offset
  192              0.000769     call add(a:modifications, [line_number, 'modified'])
  192              0.000249     let offset += 1
  267              0.000183   endwhile
  435              0.000399   while offset < a:to_count
  360              0.000479     let line_number = a:to_line + offset
  360              0.001196     call add(a:modifications, [line_number, 'added'])
  360              0.000403     let offset += 1
  435              0.000261   endwhile

FUNCTION  <SNR>122_empty_border()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/float.vim:920
Called 78 times
Total time:   0.000336
 Self time:   0.000336

count  total (s)   self (s)
   78              0.000181   if empty(a:border)
   78              0.000060     return 1
                              endif
                              if a:border[0] == 0 && a:border[1] == 0 && a:border[2] == 0 && a:border[3] == 0
                                return 1
                              endif
                              return 0

FUNCTION  airline#util#exec_funcrefs()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim:93
Called 381 times
Total time:   0.389800
 Self time:   0.039168

count  total (s)   self (s)
 2104              0.003251     for Fn in a:list
 2104   0.378909   0.028278       let code = call(Fn, a:000)
 2104              0.002330       if code != 0
  381              0.000354         return code
 1723              0.000886       endif
 1723              0.001106     endfor
                                return 0

FUNCTION  nerdtree#slash()
    Defined: ~/.vim/plugged/nerdtree/autoload/nerdtree.vim:47
Called 3003 times
Total time:   0.083219
 Self time:   0.053455

count  total (s)   self (s)
 3003   0.059552   0.029788     if nerdtree#runningWindows()
                                    if exists('+shellslash') && &shellslash
                                        return '/'
                                    endif
                            
                                    return '\'
 3003              0.001648     endif
                            
 3003              0.002406     return '/'

FUNCTION  284()
    Defined: ~/.vim/plugged/nerdtree-git-plugin/autoload/gitstatus/listener.vim:81
Called 44 times
Total time:   0.041359
 Self time:   0.001210

count  total (s)   self (s)
   44   0.006104   0.000624     if !g:NERDTree.IsOpen()
    3              0.000006         return
   41              0.000022     endif
                            
   41   0.000547   0.000209     if !self.changed()
   40              0.000023         return
    1              0.000000     endif
                            
    1   0.000027   0.000003     call self.update()
                            
    1              0.000002     let l:winnr = winnr()
    1              0.000002     let l:altwinnr = winnr('#')
                            
    1              0.000001     try
    1   0.000284   0.000005         call g:NERDTree.CursorToTreeWin()
    1   0.022543   0.000008         call b:NERDTree.root.refreshFlags()
    1   0.011502   0.000008         call NERDTreeRender()
    1              0.000001     finally
    1              0.000009         noautocmd exec l:altwinnr . 'wincmd w'
    1              0.000120         noautocmd exec l:winnr . 'wincmd w'
    1              0.000002     endtry

FUNCTION  <SNR>166_process_hunk()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:240
Called 126 times
Total time:   0.032871
 Self time:   0.012607

count  total (s)   self (s)
  126              0.000199   let modifications = []
  126              0.000183   let from_line  = a:hunk[0]
  126              0.000144   let from_count = a:hunk[1]
  126              0.000133   let to_line    = a:hunk[2]
  126              0.000132   let to_count   = a:hunk[3]
                            
  126   0.001541   0.001135   if s:is_added(from_count, to_count)
                                call s:process_added(modifications, from_count, to_count, to_line)
                                call gitgutter#hunk#increment_lines_added(a:bufnr, to_count)
                            
  126   0.001403   0.001022   elseif s:is_removed(from_count, to_count)
                                call s:process_removed(modifications, from_count, to_count, to_line)
                                call gitgutter#hunk#increment_lines_removed(a:bufnr, from_count)
                            
  126   0.001470   0.000941   elseif s:is_modified(from_count, to_count)
   50   0.001786   0.000585     call s:process_modified(modifications, from_count, to_count, to_line)
   50   0.003383   0.000470     call gitgutter#hunk#increment_lines_modified(a:bufnr, to_count)
                            
   76   0.001284   0.000981   elseif s:is_modified_and_added(from_count, to_count)
   75   0.006923   0.001009     call s:process_modified_and_added(modifications, from_count, to_count, to_line)
   75   0.005908   0.001020     call gitgutter#hunk#increment_lines_added(a:bufnr, to_count - from_count)
   75   0.004349   0.000731     call gitgutter#hunk#increment_lines_modified(a:bufnr, from_count)
                            
    1   0.000008   0.000006   elseif s:is_modified_and_removed(from_count, to_count)
    1   0.000027   0.000009     call s:process_modified_and_removed(modifications, from_count, to_count, to_line)
    1   0.000043   0.000006     call gitgutter#hunk#increment_lines_modified(a:bufnr, to_count)
    1   0.000065   0.000009     call gitgutter#hunk#increment_lines_removed(a:bufnr, from_count - to_count)
                            
  126              0.000047   endif
  126              0.000121   return modifications

FUNCTION  airline#extensions#searchcount#status()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/searchcount.vim:27
Called 522 times
Total time:   0.027567
 Self time:   0.025612

count  total (s)   self (s)
  522              0.000637   try
  522              0.009044     let result = searchcount(#{recompute: 1, maxcount: -1})
  522              0.001635     if empty(result) || result.total ==# 0
  489              0.000583       return ''
   33              0.000016     endif
   33              0.000037     if result.incomplete ==# 1     " timed out
                                  return printf('%s [?/??]', s:search_term())
   33              0.000036     elseif result.incomplete ==# 2 " max count exceeded
                                  if result.total > result.maxcount &&  result.current > result.maxcount
                                    return printf('%s[>%d/>%d]', s:search_term(),		    result.current, result.total)
                                  elseif result.total > result.maxcount
                                    return printf('%s[%d/>%d]', s:search_term(),		    result.current, result.total)
                                  endif
   33              0.000013     endif
   33   0.002337   0.000382     return printf('%s[%d/%d]', s:search_term(),		result.current, result.total)
                              catch
                                return ''
  522              0.000639   endtry

FUNCTION  <SNR>23_RltvNmbr()
    Defined: ~/.vim/plugged/RltvNmbr.vim/autoload/RltvNmbr.vim:46
Called 303 times
Total time:   0.200619
 Self time:   0.154355

count  total (s)   self (s)
                            "  call Dfunc("s:RltvNmbr(mode=".a:mode.((a:0 > 0)? " ".a:1.")" : ")"))
                            
  303              0.000545   if a:mode == 1
                               " initial placement of signs
                            "   call Decho("mode ".a:mode.": initial sign placement")
   64              0.000237    let wt                              = line("w0")
   64              0.000115    let wc                              = line(".")
   64              0.000112    let wb                              = line("w$")
                            "   call Decho("initial placement of signs: wt=".wt." wc=".wc." wb=".wb)
   64              0.000076    let w                               = wt
   64              0.000334    let s:rltvnmbr_topline_{bufnr("%")} = wt
   64              0.000261    let s:rltvnmbr_curline_{bufnr("%")} = wc
   64              0.000217    let s:rltvnmbr_botline_{bufnr("%")} = wb
 1531              0.001403    while w <= wb
 1467              0.001193 	if w == wc
   64              0.000050 	 let w= w + 1
   64              0.000035 	 continue
 1403              0.000473 	endif
 1403              0.001501 	let wmwc = w - wc
 1403              0.002131 	if foldclosed(w) != -1
                            "	 call Decho("skipping w=".w." wmwc=".wmwc." foldclosed=".foldclosed(w))
                            	 let w= foldclosedend(w)+1
                            	 continue
 1403              0.000520 	endif
 1403              0.001190 	if wmwc <= -100
                            	 let w= wc - 99
                            	 continue
 1403              0.000538 	endif
 1403              0.001014 	if wmwc >= 100
                            	 break
 1403              0.000475 	endif
 1403              0.000935 	if wmwc < 0
  826              0.001415 	 let name = "RLTVN_M".(-wmwc)
  826              0.006229 	 exe "sign place ".(s:RLTVNMBR + wmwc)." line=".w." name=".name." buffer=".bufnr("%")
  577              0.000266 	else
  577              0.000963 	 let name = "RLTVN_P".wmwc
  577              0.004077 	 exe "sign place ".(s:RLTVNMBR + wmwc)." line=".w." name=".name." buffer=".bufnr("%")
 1403              0.000716 	endif
 1403              0.001269 	let w= w + 1
 1467              0.000996    endwhile
                            
  239              0.000323   elseif a:mode == 2
                            "   call Decho("mode ".a:mode.": consider removing and placing signs")
  175              0.001405    if exists("s:rltvnmbr_curline_{bufnr('%')}")
                                " remove and place signs
  175              0.002594     if line(".") != s:rltvnmbr_curline_{bufnr("%")} || line("w0") != s:rltvnmbr_topline_{bufnr("%")} || line("w$") != s:rltvnmbr_botline_{bufnr("%")}
                            "	 call Decho("do remove&place signs : (".line(".").",".line("w0").") =?= (".s:rltvnmbr_curline_{bufnr("%")}.",".s:rltvnmbr_topline_{bufnr("%")}.")")
   64              0.001242      exe "sign place ".s:RLTVNMBR." line=".s:rltvnmbr_curline_{bufnr("%")}." name=RLTVCURID buffer=".bufnr("%")
   64              0.000296      let lzkeep= &lz
   64              0.000534 	 set lz
   64              0.000297      call s:RltvNmbr(3)  " remove signs
   64              0.000351      call s:RltvNmbr(1)  " place signs
   64              0.000429      exe "sign unplace ".s:RLTVNMBR." buffer=".bufnr("%")
   64              0.000434      let &lz= lzkeep
  175              0.000141     endif
  175              0.000082    endif
                            
   64              0.000061   elseif a:mode == 3
                               " removal of signs
                            "   call Decho("mode ".a:mode.": removal of signs")
   64              0.000280    let wt = s:rltvnmbr_topline_{bufnr("%")}
   64              0.000205    let wc = s:rltvnmbr_curline_{bufnr("%")}
   64              0.000197    let wb = s:rltvnmbr_botline_{bufnr("%")}
                            "   call Decho("using s:wt=".wt." s:wc=".wc." s:wb=".wb)
   64              0.000088    let w  = wt
 1528              0.001385    while w <= wb
 1464              0.001203 	if w == wc
   64              0.000053 	 let w= w + 1
   64              0.000040 	 continue
 1400              0.000545 	endif
 1400              0.001622 	let wmwc = w - wc
 1400              0.002206 	if foldclosed(w) != -1
                            "	 call Decho("skipping w=".w." wmwc=".wmwc." foldclosed=".foldclosed(w))
                            	 let w= foldclosedend(w)+1
                            	 continue
 1400              0.000507 	endif
 1400              0.001276 	if wmwc <= -100
                            	 let w= wc - 99
                            	 continue
 1400              0.000492 	endif
 1400              0.000964 	if wmwc >= 100
                            	 break
 1400              0.000464 	endif
 1400              0.001024 	if wmwc < 0
  811              0.001463 	 let name= "RLTVN_M".(-wmwc)
  589              0.000282 	else
  589              0.000988 	 let name= "RLTVN_P".wmwc
 1400              0.000639 	endif
 1400              0.007346 	exe "sign unplace ".(s:RLTVNMBR + wmwc)." buffer=".bufnr("%")
 1400              0.001586 	let w= w + 1
 1464              0.000965    endwhile
                            
                              else
                               echoerr "mode=".a:mode." unsupported"
  303              0.000208   endif
                            
                            "  call Dret("s:RltvNmbr")

FUNCTION  coc#float#check_related()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/float.vim:809
Called 41 times
Total time:   0.011507
 Self time:   0.003276

count  total (s)   self (s)
   41              0.000194   let invalids = []
   41   0.008643   0.001154   let ids = coc#float#get_float_win_list(1)
   43              0.000114   for id in ids
    2              0.000009     let target = getwinvar(id, 'target_winid', 0)
    2              0.000012     if (target && index(ids, target) == -1) || getwinvar(id, 'kind', '') == 'pum'
    1              0.000003       call add(invalids, id)
    2              0.000002     endif
   43              0.000092   endfor
   41              0.000099   if !s:popup_list_api
   41              0.000491     let s:popup_list = filter(ids, "index(invalids, v:val) == -1")
   41              0.000050   endif
   42              0.000114   for id in invalids
    1   0.000755   0.000013     call coc#float#close(id)
   42              0.000065   endfor

FUNCTION  <SNR>121_reset_tick()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter.vim:166
Called 54 times
Total time:   0.001981
 Self time:   0.000832

count  total (s)   self (s)
   54   0.001938   0.000790   call gitgutter#utility#setbufvar(a:bufnr, 'tick', 0)

FUNCTION  coc#rpc#ready()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/rpc.vim:32
Called 1197 times
Total time:   0.012538
 Self time:   0.012538

count  total (s)   self (s)
 1197              0.007222   if empty(s:client) || s:client['running'] == 0
                                return 0
 1197              0.000697   endif
 1197              0.001135   return 1

FUNCTION  jsx_pretty#indent#get()
    Defined: ~/.vim/plugged/vim-jsx-pretty/autoload/jsx_pretty/indent.vim:236
Called 14 times
Total time:   0.026332
 Self time:   0.002927

count  total (s)   self (s)
   14   0.000639   0.000314   let line = s:trim(getline(v:lnum))
   14   0.001991   0.000204   let start_syntax = s:start_syntax(v:lnum)
                            
   14   0.000428   0.000275   if s:is_jsx_backticks(start_syntax)
                                return s:jsx_indent_backticks(v:lnum)
   14              0.000017   endif
                            
   14   0.000206   0.000128   if s:is_jsx_brace(start_syntax)
                                return s:jsx_indent_element(v:lnum)
   14              0.000008   endif
                            
   14   0.000282   0.000208   if s:is_opening_tag(start_syntax) && line =~ '^>'
                                return s:jsx_indent_trail_punct(v:lnum)
   14              0.000008   endif
                            
   14   0.005761   0.000283   let syntax_context = s:syntax_context(v:lnum)
                            
   14              0.000029   if syntax_context == 'jsxRegion'
                                if s:is_closing_tag(start_syntax)
                                  return s:jsx_indent_closing_tag(v:lnum)
                                endif
                            
                                let prev_lnum = s:prev_lnum(v:lnum)
                                let prev_line = s:trim(getline(prev_lnum))
                            
                                if prev_line =~ '[([{=?]$'
                                  return indent(prev_lnum) + s:sw()
                                elseif prev_line =~ '[:|&<>]$' && s:trim(getline(s:prev_lnum(prev_lnum))) !~ '[?:|&<>]$'
                                  return indent(prev_lnum) + s:sw()
                                else
                                  return indent(prev_lnum)
                                endif
   14              0.000026   elseif syntax_context == 'jsxTaggedRegion'
                                if s:is_closing_tag(start_syntax)
                                  return s:jsx_indent_closing_tag(v:lnum)
                                elseif s:is_jsx_comment(start_syntax)
                                  return s:jsx_indent_comment(v:lnum)
                                else
                                  return indent(s:prev_lnum(v:lnum)) + s:sw()
                                endif
   14              0.000020   elseif syntax_context == 'jsxElement'
   14   0.000199   0.000121     if s:is_jsx_comment(start_syntax)
                                  return s:jsx_indent_comment(v:lnum)
   14              0.000009     endif
                            
   14   0.000201   0.000131     if s:is_comment(start_syntax)
                                  return s:jsx_indent_comment(v:lnum)
   14              0.000008     endif
                            
   14   0.015678   0.000316     return s:jsx_indent_element(v:lnum)
                              elseif syntax_context == 'jsxExpressionBlock'
                                let prev_lnum = s:prev_lnum(v:lnum)
                                let prev_line = s:trim(getline(prev_lnum))
                            
                                if line =~ '^?'
                                  return indent(prev_lnum) + s:sw()
                                elseif line =~ '^:'
                                  return indent(prev_lnum)
                                else
                                  return a:js_indent()
                                endif
                              endif
                            
                              return a:js_indent()

FUNCTION  <SNR>111_add_section()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/default.vim:47
Called 1713 times
Total time:   0.173130
 Self time:   0.061540

count  total (s)   self (s)
 1713              0.008243     let condition = (a:key is# "warning" || a:key is# "error") && (v:version == 704 && !has("patch1511"))
                                " i have no idea why the warning section needs special treatment, but it's
                                " needed to prevent separators from showing up
 1713   0.021167   0.009543     if ((a:key == 'error' || a:key == 'warning') && empty(s:get_section(a:context.winnr, a:key)))
                                  return
 1713              0.000694     endif
 1713              0.001276     if condition
                                  call a:builder.add_raw('%(')
 1713              0.000786     endif
 1713   0.126608   0.026642     call a:builder.add_section('airline_'.a:key, s:get_section(a:context.winnr, a:key))
 1713              0.001577     if condition
                                  call a:builder.add_raw('%)')
 1713              0.000875     endif

FUNCTION  coc#util#cursor()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/util.vim:36
Called 126 times
Total time:   0.003589
 Self time:   0.003589

count  total (s)   self (s)
  126              0.003148   return [line('.') - 1, strchars(strpart(getline('.'), 0, col('.') - 1))]

FUNCTION  gitgutter#utility#get_diff_base()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:196
Called 43 times
Total time:   0.009416
 Self time:   0.009416

count  total (s)   self (s)
   43              0.007815   let p = resolve(expand('#'.a:bufnr.':p'))
   43              0.000940   let ml = matchlist(p, '\v^fugitive:/.*/(\x{40,})/')
   43              0.000220   if !empty(ml) && !empty(ml[1])
                                return ml[1].'^'
   43              0.000038   endif
   43              0.000126   return g:gitgutter_diff_base

FUNCTION  airline#util#stl_disabled()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim:189
Called 498 times
Total time:   0.021854
 Self time:   0.016028

count  total (s)   self (s)
                              " setting the statusline is disabled,
                              " either globally, per window, or per buffer
                              " w:airline_disabled is deprecated!
  498   0.020829   0.015003   return get(g:, 'airline_disable_statusline', 0) || airline#util#getwinvar(a:winnr, 'airline_disable_statusline', 0) || airline#util#getwinvar(a:winnr, 'airline_disabled', 0) || airline#util#getbufvar(winbufnr(a:winnr), 'airline_disable_statusline', 0)

FUNCTION  coc#float#create_float_win()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/float.vim:58
Called 26 times
Total time:   0.038348
 Self time:   0.010829

count  total (s)   self (s)
   26              0.000087   let lines = get(a:config, 'lines', v:null)
   26   0.005065   0.000318   let bufnr = coc#float#create_buf(a:bufnr, lines, 'hide')
                              " use exists
   26              0.000057   if a:winid && coc#float#valid(a:winid)
                                if s:is_vim
                                  let [line, col] = s:popup_position(a:config)
                                  let opts = { 'firstline': 1, 'line': line, 'col': col, 'minwidth': a:config['width'], 'minheight': a:config['height'], 'maxwidth': a:config['width'], 'maxheight': a:config['height'], 'cursorline': get(a:config, 'cursorline', 0), 'title': get(a:config, 'title', ''), }
                                  if !s:empty_border(get(a:config, 'border', []))
                                    let opts['border'] = a:config['border']
                                  endif
                                  call popup_setoptions(a:winid, opts)
                                  call coc#float#vim_buttons(a:winid, a:config)
                                  return [a:winid, winbufnr(a:winid)]
                                else
                                  let config = s:convert_config_nvim(a:config)
                                  call nvim_win_set_buf(a:winid, bufnr)
                                  call nvim_win_set_config(a:winid, config)
                                  call nvim_win_set_cursor(a:winid, [1, 0])
                                  call coc#float#nvim_create_related(a:winid, config, a:config)
                                  return [a:winid, bufnr]
                                endif
   26              0.000016   endif
   26              0.000026   let winid = 0
   26              0.000019   if s:is_vim
                                let [line, col] = s:popup_position(a:config)
                                let title = get(a:config, 'title', '')
                                let buttons = get(a:config, 'buttons', [])
                                let hlgroup = get(a:config, 'highlight',  'CocFloating')
                                let opts = { 'title': title, 'line': line, 'col': col, 'fixed': 1, 'padding': empty(title) ?  [0, 1, 0, 1] : [0, 0, 0, 0], 'borderchars': s:borderchars, 'highlight': hlgroup, 'cursorline': get(a:config, 'cursorline', 0), 'minwidth': a:config['width'], 'minheight': a:config['height'], 'maxwidth': a:config['width'], 'maxheight': a:config['height'] }
                                if get(a:config, 'close', 0)
                                  let opts['close'] = 'button'
                                endif
                                if !empty(get(a:config, 'borderhighlight', []))
                                  let opts['borderhighlight'] = map(a:config['borderhighlight'], 'coc#highlight#compose_hlgroup(v:val,"'.hlgroup.'")')
                                endif
                                if !s:empty_border(get(a:config, 'border', []))
                                  let opts['border'] = a:config['border']
                                endif
                                let winid = popup_create(bufnr, opts)
                                if !s:popup_list_api
                                  call add(s:popup_list, winid)
                                endif
                                if winid == 0
                                  return []
                                endif
                                call coc#float#vim_buttons(winid, a:config)
                                if has("patch-8.1.2281")
                                  call setwinvar(winid, '&showbreak', 'NONE')
                                endif
   26              0.000014   else
   26   0.003577   0.000489     let config = s:convert_config_nvim(a:config)
   26              0.003101     noa let winid = nvim_open_win(bufnr, 0, config)
   26              0.000055     if winid == 0
                                  return []
   26              0.000016     endif
   26              0.000095     let hlgroup = get(a:config, 'highlight', 'CocFloating')
   26              0.000989     call setwinvar(winid, '&winhl', 'Normal:'.hlgroup.',NormalNC:'.hlgroup.',FoldColumn:'.hlgroup)
   26              0.000152     call setwinvar(winid, '&signcolumn', 'no')
   26              0.000163     call setwinvar(winid, '&foldenable', 0)
                                " cursorline highlight not work on old neovim
   26              0.000100     call setwinvar(winid, '&cursorline', 0)
   26              0.000100     call setwinvar(winid, 'border', get(a:config, 'border', []))
                                " no left border
   26   0.000469   0.000367     if s:empty_border(get(a:config, 'border', [])) || a:config['border'][3] == 0
   26              0.000128       call setwinvar(winid, '&foldcolumn', 1)
                                else
                                  call setwinvar(winid, '&foldcolumn', 0)
   26              0.000012     endif
   26              0.000183     call nvim_win_set_cursor(winid, [1, 0])
   26   0.019785   0.000485     call coc#float#nvim_create_related(winid, config, a:config)
   26              0.000014   endif
   26              0.000065   if get(a:config, 'autohide', 0)
                                call setwinvar(winid, 'autohide', 1)
   26              0.000011   endif
   26              0.000090   if s:is_vim || has('nvim-0.5.0')
   26              0.000213     call setwinvar(winid, '&scrolloff', 0)
   26              0.000012   endif
   26              0.000061   call setwinvar(winid, 'float', 1)
   26              0.000088   call setwinvar(winid, '&list', 0)
   26              0.000072   call setwinvar(winid, '&number', 0)
   26              0.000085   call setwinvar(winid, '&relativenumber', 0)
   26              0.000089   call setwinvar(winid, '&cursorcolumn', 0)
   26              0.000139   call setwinvar(winid, '&colorcolumn', 0)
   26              0.000077   call setwinvar(winid, '&wrap', 1)
   26              0.000068   call setwinvar(winid, '&linebreak', 1)
   26              0.000078   call setwinvar(winid, '&conceallevel', 0)
   26              0.000144   let g:coc_last_float_win = winid
   26   0.000550   0.000268   call coc#util#do_autocmd('CocOpenFloat')
   26              0.000046   return [winid, bufnr]

FUNCTION  coc#helper#obj_equal()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/helper.vim:8
Called 300 times
Total time:   0.008385
 Self time:   0.008385

count  total (s)   self (s)
 1349              0.002428   for key in keys(a:one)
 1099              0.002387     if a:one[key] != a:two[key]
   50              0.000040       return 0
 1049              0.000473     endif
 1299              0.000878   endfor
  250              0.000189   return 1

FUNCTION  airline#extensions#netrw#apply()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/netrw.vim:11
Called 116 times
Total time:   0.002376
 Self time:   0.002376

count  total (s)   self (s)
  116              0.000582   if &ft == 'netrw'
                                let spc = g:airline_symbols.space
                            
                                call a:1.add_section('airline_a', spc.'netrw'.spc)
                                if exists('*airline#extensions#branch#get_head')
                                  call a:1.add_section('airline_b', spc.'%{airline#extensions#branch#get_head()}'.spc)
                                endif
                                call a:1.add_section('airline_c', spc.'%f'.spc)
                                call a:1.split()
                                call a:1.add_section('airline_y', spc.'%{airline#extensions#netrw#sortstring()}'.spc)
                                return 1
  116              0.000048   endif

FUNCTION  airline#extensions#term#apply()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/term.vim:14
Called 116 times
Total time:   0.002679
 Self time:   0.002679

count  total (s)   self (s)
  116              0.000849   if &buftype ==? 'terminal' || bufname(a:2.bufnr)[0] ==? '!'
                                call a:1.add_section_spaced('airline_a', s:section_a)
                                call a:1.add_section_spaced('airline_b', s:neoterm_id(a:2.bufnr))
                                call a:1.add_section('airline_term', s:spc.s:termname(a:2.bufnr))
                                call a:1.split()
                                call a:1.add_section('airline_y', '')
                                call a:1.add_section_spaced('airline_z', s:section_z)
                                return 1
  116              0.000049   endif

FUNCTION  <SNR>61_exists_file()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:223
Called 88 times
Total time:   0.025135
 Self time:   0.004355

count  total (s)   self (s)
   88   0.025008   0.004228   return filereadable(s:abs_path(a:bufnr, 0))

FUNCTION  coc#compat#execute()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/compat.vim:132
Called 26 times
Total time:   0.012264
 Self time:   0.012264

count  total (s)   self (s)
   26              0.000045   if s:is_vim
                                if !exists('*win_execute')
                                  throw 'win_execute function not exists, please upgrade your vim.'
                                endif
                                if type(a:command) == v:t_string
                                  keepalt call win_execute(a:winid, a:command)
                                elseif type(a:command) == v:t_list
                                  keepalt call win_execute(a:winid, join(a:command, "\n"))
                                endif
   26              0.000012   else
   26              0.000070     let curr = nvim_get_current_win()
   26              0.001475     noa keepalt call nvim_set_current_win(a:winid)
   26              0.000091     if type(a:command) == v:t_string
   26              0.008794       exec a:command
                                elseif type(a:command) == v:t_list
                                  exec join(a:command, "\n")
   26              0.000017     endif
   26              0.001195     noa keepalt call nvim_set_current_win(curr)
   26              0.000022   endif

FUNCTION  <SNR>162_on_exit_nvim()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/async.vim:72
Called 57 times
Total time:   0.077107
 Self time:   0.001718

count  total (s)   self (s)
   57              0.000229   if !a:exit_code
   42   0.076611   0.001223     call self.handler.out(self.buffer, join(self.stdoutbuffer, "\n"))
   57              0.000030   endif

FUNCTION  <SNR>93_invoke_funcrefs()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline.vim:194
Called 381 times
Total time:   3.002394
 Self time:   0.028288

count  total (s)   self (s)
  381   0.016174   0.003745   let builder = airline#builder#new(a:context)
  381   0.396920   0.007121   let err = airline#util#exec_funcrefs(a:funcrefs + s:core_funcrefs, builder, a:context)
  381              0.000358   if err == 1
  381   2.576781   0.004903     let a:context.line = builder.build()
  381              0.003760     let s:contexts[a:context.winnr] = a:context
  381              0.001720     let option = get(g:, 'airline_statusline_ontop', 0) ? '&tabline' : '&statusline'
  381              0.005410     call setwinvar(a:context.winnr, option, '%!airline#statusline('.a:context.winnr.')')
  381              0.000243   endif

FUNCTION  coc#rpc#request()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/rpc.vim:89
Called 76 times
Total time:   0.706848
 Self time:   0.002495

count  total (s)   self (s)
   76   0.002085   0.001054   if !coc#rpc#ready()
                                return ''
   76              0.000035   endif
   76   0.704429   0.001106   return s:client['request'](a:method, a:args)

FUNCTION  coc#float#get_related()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/float.vim:1205
Called 193 times
Total time:   0.003727
 Self time:   0.003727

count  total (s)   self (s)
  245              0.001389   for winid in getwinvar(a:winid, 'related', [])
   52              0.000173     if getwinvar(winid, 'kind', '') ==# a:kind
                                  return winid
   52              0.000027     endif
  245              0.000433   endfor
  193              0.000219   return 0

FUNCTION  gitgutter#process_buffer()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter.vim:21
Called 90 times
Total time:   0.421579
 Self time:   0.014433

count  total (s)   self (s)
                              " NOTE a:bufnr is not necessarily the current buffer.
                            
   90   0.056945   0.001822   if gitgutter#utility#is_active(a:bufnr)
                            
   88              0.000501     if has('patch-7.4.1559')
   88              0.000954       let l:Callback = function('gitgutter#process_buffer', [a:bufnr, a:force])
                                else
                                  let l:Callback = {'function': 'gitgutter#process_buffer', 'arguments': [a:bufnr, a:force]}
   88              0.000061     endif
   88   0.067967   0.001559     let how = s:setup_path(a:bufnr, l:Callback)
   88              0.000371     if [how] == ['async']  " avoid string-to-number conversion if how is a number
   15              0.000011       return
   73              0.000047     endif
                            
   73   0.002842   0.000758     if a:force || s:has_fresh_changes(a:bufnr)
                            
   43              0.000065       let diff = 'NOT SET'
   43              0.000048       try
   43   0.286769   0.003238         let diff = gitgutter#diff#run_diff(a:bufnr, g:gitgutter_diff_relative_to, 0)
                                  catch /gitgutter not tracked/
                                    call gitgutter#debug#log('Not tracked: '.gitgutter#utility#file(a:bufnr))
                                  catch /gitgutter diff failed/
                                    call gitgutter#debug#log('Diff failed: '.gitgutter#utility#file(a:bufnr))
                                    call gitgutter#hunk#reset(a:bufnr)
   43              0.000074       endtry
                            
   43              0.000152       if diff != 'async' && diff != 'NOT SET'
                                    call gitgutter#diff#handler(a:bufnr, diff)
   43              0.000031       endif
                            
   73              0.000037     endif
   75              0.000035   endif

FUNCTION  coc#_hide()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc.vim:92
Called 18 times
Total time:   0.000242
 Self time:   0.000242

count  total (s)   self (s)
   18              0.000151   if !pumvisible() | return | endif
    7              0.000053   call feedkeys("\<C-e>", 'in')

FUNCTION  airline#extensions#coc#get()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/coc.vim:18
Called 1044 times
Total time:   0.048489
 Self time:   0.048489

count  total (s)   self (s)
 1044              0.004333   if !exists(':CocCommand')
                                return ''
 1044              0.000534   endif
 1044              0.003915   let _backup = get(g:, 'coc_stl_format', '')
 1044              0.002617   let is_err = (a:type  is# 'error')
 1044              0.000929   if is_err
  522              0.002628     let g:coc_stl_format = get(g:, 'airline#extensions#coc#stl_format_err', '%E{[%e(#%fe)]}')
  522              0.000266   else
  522              0.003232     let g:coc_stl_format = get(g:, 'airline#extensions#coc#stl_format_warn', '%W{[%w(#%fw)]}')
 1044              0.000509   endif
 1044              0.003357   let info = get(b:, 'coc_diagnostic_info', {})
 1044              0.002837   if empty(info) | return '' | endif
                            
                            
 1034              0.002779   let cnt = get(info, a:type, 0)
 1034              0.001848   if !empty(_backup)
 1034              0.002761     let g:coc_stl_format = _backup
 1034              0.000522   endif
                            
 1034              0.001419   if empty(cnt)
  517              0.000356     return ''
  517              0.000210   else
  517              0.002964     let lnum = printf('(L%d)', (info.lnums)[is_err ? 0 : 1])
  517              0.001980     return (is_err ? s:error_symbol : s:warning_symbol).cnt.lnum
                              endif

FUNCTION  <SNR>51_enableLiveUpdate()
    Defined: ~/.vim/plugged/nerdtree-git-plugin/nerdtree_plugin/git_status.vim:314
Called 1 time
Total time:   0.000361
 Self time:   0.000361

count  total (s)   self (s)
    1              0.000005     augroup nerdtreegitplugin_liveupdate
    1              0.000326         autocmd!
    1              0.000002         if g:NERDTreeGitStatusUpdateOnWrite
    1              0.000006             autocmd BufWritePost * silent! call s:onFileUpdate(expand('%:p'))
    1              0.000001         endif
                            
    1              0.000001         if g:NERDTreeGitStatusUpdateOnCursorHold
    1              0.000005             autocmd CursorHold * silent! call s:onCursorHold(expand('%:p'))
    1              0.000000         endif
                            
                                    " TODO: is it necessary to pass the buffer name?
    1              0.000006         autocmd User FugitiveChanged silent! call s:onFileUpdate(expand('%:p'))
                            
    1              0.000006         autocmd BufEnter NERD_tree_* call s:onNERDTreeInit(s:path2str(b:NERDTree.root.path))
    1              0.000001     augroup end

FUNCTION  coc#util#set_lines()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/util.vim:567
Called 2 times
Total time:   0.000134
 Self time:   0.000134

count  total (s)   self (s)
    2              0.000005   if !s:is_vim
    2              0.000088     call nvim_buf_set_lines(a:bufnr, a:start, a:end, 0, a:replacement)
                              else
                                call coc#api#notify('buf_set_lines', [a:bufnr, a:start, a:end, 0, a:replacement])
    2              0.000001   endif
    2              0.000028   return { 'lines': getbufline(a:bufnr, 1, '$'), 'changedtick': getbufvar(a:bufnr, 'changedtick') }

FUNCTION  301()
    Defined: ~/.vim/plugged/nerdtree-git-plugin/autoload/gitstatus/job.vim:42
Called 45 times
Total time:   0.001477
 Self time:   0.001068

count  total (s)   self (s)
   45   0.001095   0.000686     let self.failed = self.failed || !s:isEOF(a:data)
   45              0.000155     let self.err_chunks[-1] .= a:data[0]
   45              0.000108     call extend(self.err_chunks, a:data[1:])

FUNCTION  304()
    Defined: ~/.vim/plugged/nerdtree-git-plugin/autoload/gitstatus/job.vim:63
Called 45 times
Total time:   0.124219
 Self time:   0.001383

count  total (s)   self (s)
   45              0.000244     if has_key(self.opts, 'on_success_cb')
   45   0.123881   0.001045         call call(self.opts.on_success_cb, [self])
   45              0.000025     endif

FUNCTION  305()
    Defined: ~/.vim/plugged/nerdtree-git-plugin/autoload/gitstatus/job.vim:70
Called 45 times
Total time:   0.163575
 Self time:   0.163575

count  total (s)   self (s)
   45              0.159460         let jid = jobstart(a:cmd, { 'on_stdout': {_job_id, data, _event  -> self.onStdoutCB(data)}, 'on_stderr': {_job_id, data, _event  -> self.onStderrCB(data)}, 'on_exit':   {_job_id, _data, _event -> self.onExitCB()}, 'env':       {'GIT_OPTIONAL_LOCKS': '0'}, })
   45              0.001367         let self.id = jid
   45              0.000236         let self.running = jid > 0
   45              0.000073         if jid <= 0
                                        let self.failed = 1
                                        let self.err_chunks = jid == 0 ? ['invalid arguments'] : ['command is not executable']
                                        call self.onExitCB()
   45              0.000083         endif

FUNCTION  <SNR>97_group_not_done()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim:32
Called 1461 times
Total time:   0.015092
 Self time:   0.015092

count  total (s)   self (s)
 1461              0.005139     if index(a:list, a:name) == -1
 1026              0.003669       call add(a:list, a:name)
 1026              0.001176       return 1
  435              0.000314     else
  435              0.000632       if &vbs
                                    echomsg printf("airline: group: %s already done, skipping", a:name)
  435              0.000218       endif
  435              0.000398       return 0
                                endif

FUNCTION  266()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/notifier.vim:30
Called 1209 times
Total time:   0.022282
 Self time:   0.013183

count  total (s)   self (s)
 1209   0.017060   0.007961     let listenersMap = s:Notifier.GetListenersMap()
 1209              0.004365     return get(listenersMap, a:name, [])

FUNCTION  <SNR>67_on_window_changed()
    Defined: ~/.vim/plugged/vim-airline/plugin/airline.vim:51
Called 110 times
Total time:   2.947159
 Self time:   0.007751

count  total (s)   self (s)
                              " don't trigger for Vim popup windows
  110              0.000473   if &buftype is# 'popup'
                                return
  110              0.000060   endif
                            
  110              0.000343   if pumvisible() && (!&previewwindow || g:airline_exclude_preview)
                                " do not trigger for previewwindows
                                return
  110              0.000057   endif
  110              0.000464   let s:active_winnr = winnr()
                              " Handle each window only once, since we might come here several times for
                              " different autocommands.
  110              0.001160   let l:key = [bufnr('%'), s:active_winnr, winnr('$'), tabpagenr(), &ft]
  110              0.001100   if get(g:, 'airline_last_window_changed', []) == l:key && &stl is# '%!airline#statusline('.s:active_winnr.')' && &ft !~? 'gitcommit'
                                " fugitive is special, it changes names and filetypes several times,
                                " make sure the caching does not get into its way
                                return
  110              0.000047   endif
  110              0.000815   let g:airline_last_window_changed = l:key
  110   0.001265   0.000908   call s:init()
  110   2.940326   0.001275   call airline#update_statusline()

FUNCTION  gitgutter#utility#has_repo_path()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:102
Called 88 times
Total time:   0.004671
 Self time:   0.001513

count  total (s)   self (s)
   88   0.004605   0.001447   return index(['', -1, -2], gitgutter#utility#repo_path(a:bufnr, 0)) == -1

FUNCTION  airline#mode_changed()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline.vim:296
Called 29 times
Total time:   0.001805
 Self time:   0.000645

count  total (s)   self (s)
                              " airline#visual_active
                              " Boolean: for when to get visual wordcount
                              " needed for the wordcount extension
   29              0.000429   let g:airline#visual_active = (mode() =~? '[vs]')
   29   0.001316   0.000156   call airline#update_tabline()

FUNCTION  12()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/path.vim:244
Called 1160 times
Total time:   0.005632
 Self time:   0.005632

count  total (s)   self (s)
 1160              0.001793     if self.cachedDisplayString ==# ''
                                    call self.cacheDisplayString()
 1160              0.000475     endif
                            
 1160              0.000975     return self.cachedDisplayString

FUNCTION  14()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/path.vim:263
Called 6 times
Total time:   0.000234
 Self time:   0.000179

count  total (s)   self (s)
    6   0.000107   0.000051     if nerdtree#runningWindows()
                                    if a:fullpath =~# '^\(\\\\\|\/\/\)'
                                        "For network shares, the 'drive' consists of the first two parts of the path, i.e. \\boxname\share
                                        let self.drive = substitute(a:fullpath, '^\(\(\\\\\|\/\/\)[^\\\/]*\(\\\|\/\)[^\\\/]*\).*', '\1', '')
                                        let self.drive = substitute(self.drive, '/', '\', 'g')
                                    else
                                        let self.drive = substitute(a:fullpath, '\(^[a-zA-Z]:\).*', '\1', '')
                                    endif
    6              0.000004     else
    6              0.000023         let self.drive = ''
    6              0.000005     endif
                            

FUNCTION  18()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/path.vim:314
Called 5 times
Total time:   0.003533
 Self time:   0.000223

count  total (s)   self (s)
    5   0.000117   0.000069     if nerdtree#runningWindows()
                                    let path = self.drive . '\' . join(self.pathSegments[0:-2], '\')
    5              0.000004     else
    5              0.000074         let path = '/'. join(self.pathSegments[0:-2], '/')
    5              0.000004     endif
                            
    5   0.003303   0.000041     return s:Path.New(path)

FUNCTION  19()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/path.vim:331
Called 7255 times
Total time:   0.062542
 Self time:   0.062542

count  total (s)   self (s)
 7255              0.013275     if empty(self.pathSegments)
                                    return ''
 7255              0.003102     endif
 7255              0.012370     let toReturn = self.pathSegments[-1]
 7255              0.007853     if a:dirSlash && self.isDirectory
  156              0.000447         let toReturn = toReturn . '/'
 7255              0.002935     endif
 7255              0.005717     return toReturn

FUNCTION  <SNR>166_process_modified_and_removed()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:333
Called 1 time
Total time:   0.000017
 Self time:   0.000017

count  total (s)   self (s)
    1              0.000001   let offset = 0
    2              0.000002   while offset < a:to_count
    1              0.000001     let line_number = a:to_line + offset
    1              0.000004     call add(a:modifications, [line_number, 'modified'])
    1              0.000001     let offset += 1
    2              0.000001   endwhile
    1              0.000003   let a:modifications[-1] = [a:to_line + offset - 1, 'modified_removed']

FUNCTION  <SNR>11_SynSet()
    Defined: /usr/local/Cellar/neovim/0.5.0/share/nvim/runtime/syntax/synload.vim:33
Called 1 time
Total time:   0.027933
 Self time:   0.004427

count  total (s)   self (s)
                              " clear syntax for :set syntax=OFF  and any syntax name that doesn't exist
    1              0.000390   syn clear
    1              0.000003   if exists("b:current_syntax")
                                unlet b:current_syntax
    1              0.000001   endif
                            
    1              0.000003   let s = expand("<amatch>")
    1              0.000001   if s == "ON"
                                " :set syntax=ON
                                if &filetype == ""
                                  echohl ErrorMsg
                                  echo "filetype unknown"
                                  echohl None
                                endif
                                let s = &filetype
    1              0.000001   elseif s == "OFF"
                                let s = ""
    1              0.000000   endif
                            
    1              0.000001   if s != ""
                                " Load the syntax file(s).  When there are several, separated by dots,
                                " load each in sequence.  Skip empty entries.
    2              0.000008     for name in split(s, '\.')
    1              0.000002       if !empty(name)
    1   0.026557   0.003051         exe "runtime! syntax/" . name . ".vim syntax/" . name . "/*.vim"
    1              0.000948         exe "runtime! syntax/" . name . ".lua syntax/" . name . "/*.lua"
    1              0.000001       endif
    2              0.000002     endfor
    1              0.000000   endif

FUNCTION  airline#extensions#po#apply()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/po.vim:64
Called 116 times
Total time:   0.001048
 Self time:   0.001048

count  total (s)   self (s)
  116              0.000391   if &ft ==# 'po'
                                call airline#extensions#prepend_to_section('z', '%{airline#extensions#po#stats()}')
                                " Also reset the cache variable, if a window has been split, e.g. the winwidth changed
                                autocmd airline BufWritePost * call s:autocmd_handler()
                                autocmd airline WinEnter * call airline#extensions#po#on_winenter()
  116              0.000052   endif

FUNCTION  23()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/path.vim:411
Called 1 time
Total time:   0.000175
 Self time:   0.000056

count  total (s)   self (s)
                            
    1   0.000127   0.000008     if !self.isUnder(a:path)
                                    return 0
    1              0.000001     endif
                            
    1              0.000004     let l:startIndex = len(a:path.pathSegments)
    1              0.000005     let l:segments = self.pathSegments[l:startIndex : ]
                            
    3              0.000006     for l:segment in l:segments
                            
    2              0.000011         if l:segment =~# '^\.'
                                        return 1
    2              0.000002         endif
    3              0.000003     endfor
                            
    1              0.000001     return 0

FUNCTION  24()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/path.vim:432
Called 3000 times
Total time:   0.041774
 Self time:   0.019326

count  total (s)   self (s)
 3000   0.040773   0.018325     return self.getLastPathComponent(0) =~# '^\.'

FUNCTION  26()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/path.vim:453
Called 3040 times
Total time:   0.317454
 Self time:   0.139763

count  total (s)   self (s)
                                "filter out the user specified paths to ignore
 3040   0.016713   0.012954     if a:nerdtree.ui.isIgnoreFilterEnabled()
 6040              0.006685         for i in g:NERDTreeIgnore
 3040   0.127090   0.015714             if self._ignorePatternMatches(i)
   40              0.000041                 return 1
 3000              0.001199             endif
 6000              0.004148         endfor
                            
 3000   0.027584   0.013947         for l:Callback in g:NERDTree.PathFilters()
                                        let l:Callback = type(l:Callback) ==# type(function('tr')) ? l:Callback : function(l:Callback)
                                        if l:Callback({'path': self, 'nerdtree': a:nerdtree})
                                           return 1
                                        endif
 3000              0.002876         endfor
 3000              0.001199     endif
                            
                                "dont show hidden files unless instructed to
 3000   0.067172   0.022020     if !a:nerdtree.ui.getShowHidden() && self.isUnixHiddenFile()
                                    return 1
 3000              0.001105     endif
                            
 3000   0.017449   0.013682     if a:nerdtree.ui.getShowFiles() ==# 0 && self.isDirectory ==# 0
                                    return 1
 3000              0.001171     endif
                            
 3000              0.001560     return 0

FUNCTION  27()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/path.vim:484
Called 3040 times
Total time:   0.111375
 Self time:   0.086564

count  total (s)   self (s)
 3040              0.003755     let pat = a:pattern
 3040              0.008798     if strpart(pat,len(pat)-8) ==# '[[path]]'
                                    let pat = strpart(pat,0, len(pat)-8)
                                    return self.str() =~# pat
 3040              0.008004     elseif strpart(pat,len(pat)-7) ==# '[[dir]]'
                                    if !self.isDirectory
                                        return 0
                                    endif
                                    let pat = strpart(pat,0, len(pat)-7)
 3040              0.007764     elseif strpart(pat,len(pat)-8) ==# '[[file]]'
                                    if self.isDirectory
                                        return 0
                                    endif
                                    let pat = strpart(pat,0, len(pat)-8)
 3040              0.001174     endif
                            
 3040   0.047755   0.022943     return self.getLastPathComponent(0) =~# pat

FUNCTION  29()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/path.vim:514
Called 4 times
Total time:   0.000486
 Self time:   0.000445

count  total (s)   self (s)
    4              0.000009     if a:parent.isDirectory ==# 0
                                    return 0
    4              0.000003     endif
    4   0.000080   0.000040     if nerdtree#runningWindows() && a:parent.drive !=# self.drive
                                    return 0
    4              0.000003     endif
    4              0.000017     let l:this_count = len(self.pathSegments)
    4              0.000007     if l:this_count ==# 0
                                    return 0
    4              0.000003     endif
    4              0.000014     let l:that_count = len(a:parent.pathSegments)
    4              0.000006     if l:that_count ==# 0
                                    return 1
    4              0.000003     endif
    4              0.000008     if l:that_count >= l:this_count
                                    return 0
    4              0.000003     endif
   37              0.000063     for i in range(0, l:that_count-1)
   33              0.000111         if self.pathSegments[i] !=# a:parent.pathSegments[i]
                                        return 0
   33              0.000023         endif
   37              0.000027     endfor
    4              0.000005     return 1

FUNCTION  <SNR>165_syn_contains()
    Defined: ~/.vim/plugged/vim-jsx-pretty/autoload/jsx_pretty/comment.vim:33
Called 78 times
Total time:   0.021785
 Self time:   0.021785

count  total (s)   self (s)
   78              0.019885   let stack = synstack(a:lnum, a:cnum)
   78              0.001417   let syn_names = map(stack, 'synIDattr(v:val, "name")')
   78              0.000349   return index(syn_names, a:syn_name) >= 0

FUNCTION  gitgutter#utility#cd_cmd()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:164
Called 58 times
Total time:   0.027115
 Self time:   0.002470

count  total (s)   self (s)
   58   0.014008   0.001515   let cd = s:unc_path(a:bufnr) ? 'pushd' : (gitgutter#utility#windows() && s:dos_shell() ? 'cd /d' : 'cd')
   58   0.013004   0.000852   return cd.' '.s:dir(a:bufnr).' && '.a:cmd

FUNCTION  111()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/tree_file_node.vim:88
Called 1080 times
Total time:   0.034461
 Self time:   0.009286

count  total (s)   self (s)
 1080   0.034167   0.008992     return self.path.flagSet.renderToString() . self.path.displayString()

FUNCTION  113()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/tree_file_node.vim:112
Called 6 times
Total time:   0.001886
 Self time:   0.000049

count  total (s)   self (s)
    6   0.001869   0.000031     if a:path.equals(self.path)
    1              0.000001         return self
    5              0.000003     endif
    5              0.000004     return {}

FUNCTION  115()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/tree_file_node.vim:157
Called 4412 times
Total time:   0.006168
 Self time:   0.006168

count  total (s)   self (s)
 4412              0.004609     return self._nerdtree

FUNCTION  119()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/tree_file_node.vim:196
Called 162 times
Total time:   0.040701
 Self time:   0.002677

count  total (s)   self (s)
  162   0.001316   0.000746     if !g:NERDTree.ExistsForBuf()
                                    throw 'NERDTree.NoTreeError: No tree exists for the current buffer'
  162              0.000111     endif
                            
  162   0.038903   0.001450     return self.equals(self.getNerdtree().root)

FUNCTION  airline#util#winwidth()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim:19
Called 6540 times
Total time:   0.050729
 Self time:   0.050729

count  total (s)   self (s)
 6540              0.019427   let nr = get(a:000, 0, 0)
 6540              0.015680   if get(g:, 'airline_statusline_ontop', 0)
 6540              0.008899     return &columns
                              else
                                return winwidth(nr)
                              endif

FUNCTION  302()
    Defined: ~/.vim/plugged/nerdtree-git-plugin/autoload/gitstatus/job.vim:48
Called 45 times
Total time:   0.125057
 Self time:   0.000838

count  total (s)   self (s)
   45              0.000166     let self.running = 0
   45              0.000053     if self.failed
                                    call self.onFailed()
   45              0.000070     else
   45   0.124486   0.000267         call self.onSuccess()
   45              0.000022     endif

FUNCTION  <SNR>61_not_git_dir()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:59
Called 88 times
Total time:   0.022295
 Self time:   0.002325

count  total (s)   self (s)
   88   0.022224   0.002255   return s:dir(a:bufnr) !~ '[/\\]\.git\($\|[/\\]\)'

FUNCTION  airline#util#doautocmd()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim:176
Called 36 times
Total time:   0.007400
 Self time:   0.003845

count  total (s)   self (s)
   36              0.000231   if !exists('#airline') && a:event !=? 'AirlineToggledOff'
                                " airline disabled
                                return
   36              0.000016   endif
   36   0.006997   0.003442   exe printf("silent doautocmd %s User %s", s:nomodeline, a:event)

FUNCTION  31()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/path.vim:556
Called 15 times
Total time:   0.005130
 Self time:   0.000402

count  total (s)   self (s)
   15   0.000293   0.000154     if nerdtree#runningWindows()
                                    return self.str() ==? a:path.str()
   15              0.000013     else
   15   0.004766   0.000177         return self.str() ==# a:path.str()
                                endif

FUNCTION  32()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/path.vim:565
Called 6 times
Total time:   0.004066
 Self time:   0.000472

count  total (s)   self (s)
    6              0.000221     let l:newPath = copy(self)
                            
    6   0.003609   0.000131     call l:newPath.readInfoFromDisk(s:Path.AbsolutePathFor(a:pathStr))
                            
    6              0.000017     let l:newPath.cachedDisplayString = ''
    6   0.000186   0.000069     let l:newPath.flagSet = g:NERDTreeFlagSet.New()
                            
    6              0.000011     return l:newPath

FUNCTION  33()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/path.vim:581
Called 13 times
Total time:   0.001338
 Self time:   0.001338

count  total (s)   self (s)
   13              0.000798     let tmp = resolve(a:path)
   13              0.000528     return tmp =~# '.\+/$' ? substitute(tmp, '/$', '', '') : tmp

FUNCTION  34()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/path.vim:590
Called 6 times
Total time:   0.003126
 Self time:   0.001240

count  total (s)   self (s)
    6   0.000280   0.000046     call self.extractDriveLetter(a:fullpath)
                            
    6   0.000176   0.000051     let fullpath = s:Path.WinToUnixPath(a:fullpath)
                            
    6              0.000154     if getftype(fullpath) ==# 'fifo'
                                    throw 'NERDTree.InvalidFiletypeError: Cant handle FIFO files: ' . a:fullpath
    6              0.000005     endif
                            
    6              0.000216     let self.pathSegments = filter(split(fullpath, '/'), '!empty(v:val)')
                            
    6              0.000019     let self.isReadOnly = 0
    6              0.000086     if isdirectory(a:fullpath)
    5              0.000017         let self.isDirectory = 1
    1              0.000038     elseif filereadable(a:fullpath)
    1              0.000004         let self.isDirectory = 0
    1              0.000039         let self.isReadOnly = filewritable(a:fullpath) ==# 0
                                else
                                    throw 'NERDTree.InvalidArgumentsError: Invalid path = ' . a:fullpath
    6              0.000004     endif
                            
    6              0.000019     let self.isExecutable = 0
    6              0.000009     if !self.isDirectory
    1              0.000019         let self.isExecutable = getfperm(a:fullpath) =~# 'x'
    6              0.000005     endif
                            
                                "grab the last part of the path (minus the trailing slash)
    6   0.000163   0.000066     let lastPathComponent = self.getLastPathComponent(0)
                            
                                "get the path to the new node with the parent dir fully resolved
    6   0.000945   0.000099     let hardPath = s:Path.Resolve(self.strTrunk()) . '/' . lastPathComponent
                            
                                "if  the last part of the path is a symlink then flag it as such
    6   0.000655   0.000070     let self.isSymLink = (s:Path.Resolve(hardPath) !=# hardPath)
    6              0.000010     if self.isSymLink
                                    let self.symLinkDest = s:Path.Resolve(fullpath)
                            
                                    "if the link is a dir then slap a / on the end of its dest
                                    if isdirectory(self.symLinkDest)
                            
                                        "we always wanna treat MS windows shortcuts as files for
                                        "simplicity
                                        if hardPath !~# '\.lnk$'
                            
                                            let self.symLinkDest = self.symLinkDest . '/'
                                        endif
                                    endif
    6              0.000004     endif

FUNCTION  38()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/path.vim:698
Called 3045 times
Total time:   0.416314
 Self time:   0.198990

count  total (s)   self (s)
 3045              0.009076     let options = a:0 ? a:1 : {}
 3045              0.004177     let toReturn = ''
                            
 3045              0.007865     if has_key(options, 'format')
   42              0.000073         let format = options['format']
   42              0.000109         if has_key(self, '_strFor' . format)
   42   0.001046   0.000361             exec 'let toReturn = self._strFor' . format . '()'
                                    else
                                        throw 'NERDTree.UnknownFormatError: unknown format "'. format .'"'
   42              0.000026         endif
 3003              0.001603     else
 3003   0.224010   0.021594         let toReturn = self._str()
 3045              0.002052     endif
                            
 3045   0.041451   0.027226     if nerdtree#has_opt(options, 'escape')
                                    let toReturn = shellescape(toReturn)
 3045              0.001814     endif
                            
 3045              0.006696     if has_key(options, 'truncateTo')
   40              0.000064         let limit = options['truncateTo']
   40              0.000132         if strdisplaywidth(toReturn) > limit-1
 1440              0.005223             while strdisplaywidth(toReturn) > limit-1 && strchars(toReturn) > 0
 1400              0.006311                 let toReturn = substitute(toReturn, '^.', '', '')
 1440              0.000797             endwhile
   40              0.000290             if len(split(toReturn, '/')) > 1
   40              0.000404                 let toReturn = '</' . join(split(toReturn, '/')[1:], '/') . '/'
                                        else
                                            let toReturn = '<' . toReturn
   40              0.000019             endif
   40              0.000018         endif
 3045              0.001305     endif
                            
 3045              0.003660     return toReturn

FUNCTION  <SNR>67_on_cursor_moved()
    Defined: ~/.vim/plugged/vim-airline/plugin/airline.vim:83
Called 115 times
Total time:   1.723015
 Self time:   0.002815

count  total (s)   self (s)
  115              0.000873   if winnr() != s:active_winnr || !exists('w:airline_active')
                                call s:on_window_changed('CursorMoved')
  115              0.000084   endif
  115   1.721521   0.001321   call airline#update_tabline()

FUNCTION  <SNR>51_onCursorHold()
    Defined: ~/.vim/plugged/nerdtree-git-plugin/nerdtree_plugin/git_status.vim:191
Called 41 times
Total time:   0.162690
 Self time:   0.006354

count  total (s)   self (s)
                                " Do not update when a special buffer is selected
   41              0.000233     if !empty(&l:buftype)
    1              0.000001         return
   40              0.000023     endif
   40              0.000170     let l:fname = s:is_win ? substitute(a:fname, '\', '/', 'g') : a:fname
                            
   40   0.000815   0.000495     if !exists('g:NTGitWorkdir') || !s:hasPrefix(l:fname, g:NTGitWorkdir)
                                    return
   40              0.000016     endif
                            
   40   0.151683   0.001329     let l:job = s:refreshGitStatus('cursor-hold', g:NTGitWorkdir)
   40   0.009272   0.003609     call s:logger.debug('run cursor-hold job: ' . l:job.id)

FUNCTION  coc#util#get_complete_option()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/util.vim:338
Called 44 times
Total time:   0.020727
 Self time:   0.020727

count  total (s)   self (s)
   44              0.000450   let pos = getcurpos()
   44              0.000205   let line = getline(pos[1])
   44              0.000856   let input = matchstr(strpart(line, 0, pos[2] - 1), '\k*$')
   44              0.000199   let col = pos[2] - strlen(input)
   44              0.010612   let synname = synIDattr(synID(pos[1], col, 1), 'name')
   44              0.008214   return { 'word': matchstr(strpart(line, col - 1), '^\k\+'), 'input': empty(input) ? '' : input, 'line': line, 'filetype': &filetype, 'filepath': expand('%:p'), 'bufnr': bufnr('%'), 'linenr': pos[1], 'colnr' : pos[2], 'col': col - 1, 'synname': synname, 'changedtick': b:changedtick, 'blacklist': get(b:, 'coc_suggest_blacklist', []),}

FUNCTION  126()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/tree_file_node.vim:262
Called 1 time
Total time:   0.001221
 Self time:   0.000041

count  total (s)   self (s)
    1   0.001196   0.000016     let ln = self.getNerdtree().ui.getLineNum(self)
    1              0.000001     if ln != -1
    1              0.000001         if a:isJump
    1              0.000002             mark '
    1              0.000001         endif
    1              0.000004         call cursor(ln, col('.'))
                                else
                                    if a:recurseUpward
                                        let node = self
                                        while node != {} && self.getNerdtree().ui.getLineNum(node) ==# -1
                                            let node = node.parent
                                            call node.open()
                                        endwhile
                                        call self._nerdtree.render()
                                        call node.putCursorHere(a:isJump, 0)
                                    endif
    1              0.000000     endif

FUNCTION  128()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/tree_file_node.vim:288
Called 1053 times
Total time:   0.997767
 Self time:   0.011352

count  total (s)   self (s)
 1053   0.997212   0.010797     call self.path.refreshFlags(self.getNerdtree())

FUNCTION  <SNR>26_Autocmd()
    Defined: ~/.vim/plugged/coc.nvim/plugin/coc.vim:245
Called 1054 times
Total time:   0.152821
 Self time:   0.019704

count  total (s)   self (s)
 1054              0.003224   if !g:coc_service_initialized
                                return
 1054              0.000922   endif
 1054   0.145448   0.012331   call coc#rpc#notify('CocAutocmd', a:000)

FUNCTION  <SNR>26_AsyncRequest()
    Defined: ~/.vim/plugged/coc.nvim/plugin/coc.vim:112
Called 41 times
Total time:   0.011466
 Self time:   0.003026

count  total (s)   self (s)
   41              0.000832   let Cb = empty(a:args)? v:null : a:args[len(a:args) - 1]
   41              0.000250   if type(Cb) == 2
                                if !coc#rpc#ready()
                                  call Cb('service not started', v:null)
                                else
                                  call coc#rpc#request_async(a:name, a:args[0:-2], Cb)
                                endif
                                return ''
   41              0.000061   endif
   41   0.009305   0.000865   call coc#rpc#notify(a:name, a:args)
   41              0.000061   return ''

FUNCTION  nerdtree#checkForBrowse()
    Defined: ~/.vim/plugged/nerdtree/autoload/nerdtree.vim:61
Called 5 times
Total time:   0.000174
 Self time:   0.000174

count  total (s)   self (s)
    5              0.000165     if !isdirectory(a:dir)
    5              0.000005         return
                                endif
                            
                                if s:reuseWin(a:dir)
                                    return
                                endif
                            
                                call g:NERDTreeCreator.CreateWindowTree(a:dir)

FUNCTION  <SNR>162_on_stdout_nvim()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/async.vim:56
Called 99 times
Total time:   0.002788
 Self time:   0.002788

count  total (s)   self (s)
   99              0.000810   if empty(self.stdoutbuffer)
   57              0.000421     let self.stdoutbuffer = a:data
   42              0.000042   else
   42              0.000652     let self.stdoutbuffer = self.stdoutbuffer[:-2] + [self.stdoutbuffer[-1] . a:data[0]] + a:data[1:]
   99              0.000058   endif

FUNCTION  <SNR>99_is_branch_empty()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/hunks.vim:55
Called 521 times
Total time:   0.003908
 Self time:   0.003908

count  total (s)   self (s)
  521              0.003405   return exists('*airline#extensions#branch#head') && empty(get(b:, 'airline_head', ''))

FUNCTION  43()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/path.vim:793
Called 3003 times
Total time:   0.202415
 Self time:   0.097044

count  total (s)   self (s)
 3003   0.107829   0.024611     let l:separator = nerdtree#slash()
 3003              0.005048     let l:leader = l:separator
                            
 3003   0.047900   0.025747     if nerdtree#runningWindows()
                                    let l:leader = self.drive . l:separator
 3003              0.001689     endif
                            
 3003              0.029211     return l:leader . join(self.pathSegments, l:separator)

FUNCTION  44()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/path.vim:806
Called 6 times
Total time:   0.000200
 Self time:   0.000200

count  total (s)   self (s)
    6              0.000196     return self.drive . '/' . join(self.pathSegments[0:-2], '/')

FUNCTION  46()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/path.vim:833
Called 6 times
Total time:   0.000124
 Self time:   0.000070

count  total (s)   self (s)
    6   0.000107   0.000053     if !nerdtree#runningWindows()
    6              0.000011         return a:pathstr
                                endif
                            
                                let toReturn = a:pathstr
                            
                                "remove the x:\ of the front
                                let toReturn = substitute(toReturn, '^.*:\(\\\|/\)\?', '/', '')
                            
                                "remove the \\ network share from the front
                                let toReturn = substitute(toReturn, '^\(\\\\\|\/\/\)[^\\\/]*\(\\\|\/\)[^\\\/]*\(\\\|\/\)\?', '/', '')
                            
                                "convert all \ chars to /
                                let toReturn = substitute(toReturn, '\', '/', 'g')
                            
                                return toReturn

FUNCTION  300()
    Defined: ~/.vim/plugged/nerdtree-git-plugin/autoload/gitstatus/job.vim:37
Called 90 times
Total time:   0.001097
 Self time:   0.001097

count  total (s)   self (s)
   90              0.000630     let self.chunks[-1] .= a:data[0]
   90              0.000340     call extend(self.chunks, a:data[1:])

FUNCTION  <SNR>97_get_syn()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim:44
Called 189116 times
Total time:   5.148463
 Self time:   5.148463

count  total (s)   self (s)
189116              0.185630     let color = ''
189116              1.380470     if hlexists(a:group)
135460              1.044075       let color = synIDattr(synIDtrans(hlID(a:group)), a:what, a:mode)
189116              0.090789     endif
189116              0.341475     if empty(color) || color == -1
                                  " should always exist
53656              0.607479       let color = synIDattr(synIDtrans(hlID('Normal')), a:what, a:mode)
                                  " however, just in case
53656              0.105444       if empty(color) || color == -1
                                    let color = 'NONE'
53656              0.022015       endif
189116              0.058984     endif
189116              0.128123     return color

FUNCTION  130()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/tree_file_node.vim:310
Called 40 times
Total time:   0.491494
 Self time:   0.000430

count  total (s)   self (s)
   40   0.491449   0.000385     return self._renderToString(0, 0)

FUNCTION  131()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/tree_file_node.vim:319
Called 1200 times
Total time:   0.989379
 Self time:   0.932396

count  total (s)   self (s)
 1200              0.001020     let output = ''
 1200              0.000918     if a:drawText ==# 1
                            
 1160              0.002344         let treeParts = repeat('  ', a:depth - 1)
 1160              0.003627         let treeParts .= (self.path.isDirectory || g:NERDTreeDirArrowExpandable ==# '' ? '' : '  ')
                            
 1160   0.184300   0.005766         let line = treeParts . self.displayString()
 1160              0.002064         let output = output . line . "\n"
 1200              0.000464     endif
                            
                                " if the node is an open dir, draw its children
 1200              0.001323     if self.path.isDirectory ==# 1 && self.isOpen ==# 1
                            
   80   0.140491   0.000593         let childNodesToDraw = self.getVisibleChildren()
                            
   80   0.129286   0.000714         if self.isCascadable() && a:depth > 0
                            
                                        let output = output . childNodesToDraw[0]._renderToString(a:depth, 0)
                            
   80              0.000171         elseif len(childNodesToDraw) > 0
 1240              0.001063             for i in childNodesToDraw
 1160              0.003780                 let output = output . i._renderToString(a:depth + 1, 1)
 1240              0.000634             endfor
   80              0.000034         endif
 1200              0.000343     endif
                            
 1200              0.000890     return output

FUNCTION  <SNR>166_is_modified()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:281
Called 126 times
Total time:   0.000529
 Self time:   0.000529

count  total (s)   self (s)
  126              0.000361   return a:from_count > 0 && a:to_count > 0 && a:from_count == a:to_count

FUNCTION  138()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/tree_dir_node.vim:95
Called 80 times
Total time:   0.144073
 Self time:   0.003754

count  total (s)   self (s)
   80              0.000112     let l:result = ''
                            
                                " Build a label that identifies this TreeDirNode.
   80              0.000077     let l:label = ''
   80   0.138438   0.000512     let l:cascade = self.getCascade()
  160              0.000196     for l:dirNode in l:cascade
   80   0.001035   0.000532         let l:next = l:dirNode.path.displayString()
   80              0.000356         let l:label .= l:label ==# '' ? l:next : substitute(l:next,'^.','','')
  160              0.000119     endfor
                            
                                " Select the appropriate open/closed status indicator symbol.
   80              0.000268     let l:symbol = (l:cascade[-1].isOpen ? g:NERDTreeDirArrowCollapsible : g:NERDTreeDirArrowExpandable )
   80              0.000211     let l:symbol .= (g:NERDTreeDirArrowExpandable ==# '' ? '' : ' ')
   80   0.002354   0.000463     let l:flags = l:cascade[-1].path.flagSet.renderToString()
                            
   80              0.000172     return l:symbol . l:flags . l:label

FUNCTION  139()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/tree_dir_node.vim:120
Called 5 times
Total time:   0.006619
 Self time:   0.001712

count  total (s)   self (s)
    5   0.001768   0.000031     if a:path.equals(self.path)
    1              0.000001         return self
    4              0.000002     endif
    4   0.001180   0.000056     if stridx(a:path.str(), self.path.str(), 0) ==# -1
    2              0.000002         return {}
    2              0.000001     endif
                            
    2              0.000003     if self.path.isDirectory
    9              0.000020         for i in self.children
    9   0.001966   0.000080             let retVal = i.findNode(a:path)
    9              0.000016             if retVal !=# {}
    2              0.000002                 return retVal
    7              0.000004             endif
    7              0.000006         endfor
                                endif
                                return {}

FUNCTION  <SNR>169_is_jsx_element()
    Defined: ~/.vim/plugged/vim-jsx-pretty/autoload/jsx_pretty/indent.vim:67
Called 64 times
Total time:   0.000290
 Self time:   0.000290

count  total (s)   self (s)
   64              0.000266   return a:syntax =~? 'jsxElement'

FUNCTION  <SNR>166_save_last_seen_change()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:415
Called 42 times
Total time:   0.001268
 Self time:   0.000508

count  total (s)   self (s)
   42   0.001196   0.000436   call gitgutter#utility#setbufvar(a:bufnr, 'tick', getbufvar(a:bufnr, 'changedtick'))

FUNCTION  <SNR>51_buildGitWorkdirCommand()
    Defined: ~/.vim/plugged/nerdtree-git-plugin/nerdtree_plugin/git_status.vim:142
Called 1 time
Total time:   0.000018
 Self time:   0.000012

count  total (s)   self (s)
    1   0.000018   0.000011     return gitstatus#util#BuildGitWorkdirCommand(a:root, g:)

FUNCTION  gitgutter#diff#parse_diff()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:205
Called 42 times
Total time:   0.008916
 Self time:   0.003408

count  total (s)   self (s)
   42              0.000141   let hunks = []
  168              0.000651   for line in split(a:diff, '\n')
  126   0.007073   0.001565     let hunk_info = gitgutter#diff#parse_hunk(line)
  126              0.000197     if len(hunk_info) == 4
  126              0.000252       call add(hunks, hunk_info)
  126              0.000063     endif
  168              0.000122   endfor
   42              0.000040   return hunks

FUNCTION  <SNR>82_Highlight_Matching_Pair()
    Defined: /usr/local/Cellar/neovim/0.5.0/share/nvim/runtime/plugin/matchparen.vim:40
Called 399 times
Total time:   0.204543
 Self time:   0.199589

count  total (s)   self (s)
                              " Remove any previous match.
  399   0.008916   0.003962   call s:Remove_Matches()
                            
                              " Avoid that we remove the popup menu.
                              " Return when there are no colors (looks like the cursor jumps).
  399              0.001810   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
                                return
  399              0.000256   endif
                            
                              " Get the character under the cursor and check if it's in 'matchpairs'.
  399              0.001185   let c_lnum = line('.')
  399              0.001018   let c_col = col('.')
  399              0.000470   let before = 0
                            
  399              0.001290   let text = getline(c_lnum)
  399              0.009563   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
  399              0.001041   if empty(matches)
                                let [c_before, c] = ['', '']
  399              0.000319   else
  399              0.001955     let [c_before, c] = matches[1:2]
  399              0.000312   endif
  399              0.007542   let plist = split(&matchpairs, '.\zs[:,]')
  399              0.001733   let i = index(plist, c)
  399              0.000525   if i < 0
                                " not found, in Insert mode try character before the cursor
  283              0.001259     if c_col > 1 && (mode() == 'i' || mode() == 'R')
  166              0.000504       let before = strlen(c_before)
  166              0.000234       let c = c_before
  166              0.000400       let i = index(plist, c)
  283              0.000200     endif
  283              0.000293     if i < 0
                                  " not found, nothing to do
  282              0.000261       return
    1              0.000001     endif
  117              0.000051   endif
                            
                              " Figure out the arguments for searchpairpos().
  117              0.000146   if i % 2 == 0
    8              0.000017     let s_flags = 'nW'
    8              0.000018     let c2 = plist[i + 1]
  109              0.000062   else
  109              0.000162     let s_flags = 'nbW'
  109              0.000179     let c2 = c
  109              0.000230     let c = plist[i - 1]
  117              0.000064   endif
  117              0.000174   if c == '['
    3              0.000003     let c = '\['
    3              0.000003     let c2 = '\]'
  117              0.000057   endif
                            
                              " Find the match.  When it was just before the cursor move it there for a
                              " moment.
  117              0.000123   if before > 0
    1              0.000004     let has_getcurpos = exists("*getcurpos")
    1              0.000001     if has_getcurpos
                                  " getcurpos() is more efficient but doesn't exist before 7.4.313.
    1              0.000004       let save_cursor = getcurpos()
                                else
                                  let save_cursor = winsaveview()
    1              0.000000     endif
    1              0.000003     call cursor(c_lnum, c_col - before)
  117              0.000066   endif
                            
  117              0.000722   if !has("syntax") || !exists("g:syntax_on")
                                let s_skip = "0"
  117              0.000062   else
                                " Build an expression that detects whether the current cursor position is
                                " in certain syntax types (string, comment, etc.), for use as
                                " searchpairpos()'s skip argument.
                                " We match "escape" for special items, such as lispEscapeSpecial, and
                                " match "symbol" for lispBarSymbol.
  117              0.000530     let s_skip = '!empty(filter(map(synstack(line("."), col(".")), ''synIDattr(v:val, "name")''), ' . '''v:val =~? "string\\|character\\|singlequote\\|escape\\|symbol\\|comment"''))'
                                " If executing the expression determines that the cursor is currently in
                                " one of the syntax types, then we want searchpairpos() to find the pair
                                " within those syntax types (i.e., not skip).  Otherwise, the cursor is
                                " outside of the syntax types and s_skip should keep its value so we skip
                                " any matching pair inside the syntax types.
                                " Catch if this throws E363: pattern uses more memory than 'maxmempattern'.
  117              0.000106     try
  117              0.072218       execute 'if ' . s_skip . ' | let s_skip = "0" | endif'
                                catch /^Vim\%((\a\+)\)\=:E363/
                                  " We won't find anything, so skip searching, should keep Vim responsive.
                                  return
  117              0.000104     endtry
  117              0.000055   endif
                            
                              " Limit the search to lines visible in the window.
  117              0.000578   let stoplinebottom = line('w$')
  117              0.000286   let stoplinetop = line('w0')
  117              0.000172   if i % 2 == 0
    8              0.000023     let stopline = stoplinebottom
  109              0.000071   else
  109              0.000314     let stopline = stoplinetop
  117              0.000096   endif
                            
                              " Limit the search time to 300 msec to avoid a hang on very long lines.
                              " This fails when a timeout is not supported.
  117              0.000424   if mode() == 'i' || mode() == 'R'
  102              0.000528     let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
   15              0.000008   else
   15              0.000062     let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
  117              0.000064   endif
  117              0.000083   try
  117              0.060641     let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
                              catch /E118/
                                " Can't use the timeout, restrict the stopline a bit more to avoid taking
                                " a long time on closed folds and long lines.
                                " The "viewable" variables give a range in which we can scroll while
                                " keeping the cursor at the same position.
                                " adjustedScrolloff accounts for very large numbers of scrolloff.
                                let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
                                let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
                                let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
                                " one of these stoplines will be adjusted below, but the current values are
                                " minimal boundaries within the current window
                                if i % 2 == 0
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
                            	let stopline = min([bottom_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = min([bottom_viewable, c_lnum + 100])
                                  endif
                                  let stoplinebottom = stopline
                                else
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
                            	let stopline = max([top_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = max([top_viewable, c_lnum - 100])
                                  endif
                                  let stoplinetop = stopline
                                endif
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
  117              0.000154   endtry
                            
  117              0.000151   if before > 0
    1              0.000001     if has_getcurpos
    1              0.000003       call setpos('.', save_cursor)
                                else
                                  call winrestview(save_cursor)
    1              0.000000     endif
  117              0.000049   endif
                            
                              " If a match is found setup match highlighting.
  117              0.000282   if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
  117              0.000384     if exists('*matchaddpos')
  117              0.005416       call matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10, 3)
                                else
                                  exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) . 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
  117              0.000060     endif
  117              0.000251     let w:paren_hl_on = 1
  117              0.000063   endif

FUNCTION  <SNR>167_highlight_name_for_change()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/sign.vim:234
Called 611 times
Total time:   0.003646
 Self time:   0.003646

count  total (s)   self (s)
  611              0.000982   if a:text ==# 'added'
  360              0.000345     return 'GitGutterLineAdded'
  251              0.000360   elseif a:text ==# 'removed'
                                return 'GitGutterLineRemoved'
  251              0.000350   elseif a:text ==# 'removed_first_line'
                                return 'GitGutterLineRemovedFirstLine'
  251              0.000293   elseif a:text ==# 'modified'
  250              0.000218     return 'GitGutterLineModified'
    1              0.000001   elseif a:text ==# 'modified_removed'
    1              0.000001     return 'GitGutterLineModifiedRemoved'
                              elseif a:text ==# 'removed_above_and_below'
                                return 'GitGutterLineRemovedAboveAndBelow'
                              endif

FUNCTION  <SNR>114_getStatusKey()
    Defined: ~/.vim/plugged/nerdtree-git-plugin/autoload/gitstatus/util.vim:153
Called 484 times
Total time:   0.006080
 Self time:   0.006080

count  total (s)   self (s)
  484              0.001119     let l:xy = a:x . a:y
  484              0.001289     if get(s:unmerged_status, l:xy, 0)
                                    return 'Unmerged'
  484              0.000604     elseif l:xy ==# '??'
                                    return 'Untracked'
  484              0.000581     elseif l:xy ==# '!!'
                                    return 'Ignored'
  484              0.000575     elseif a:y ==# 'M'
  484              0.000356         return 'Modified'
                                elseif a:y ==# 'D'
                                    return 'Deleted'
                                elseif a:y =~# '[RC]'
                                    return 'Renamed'
                                elseif a:x ==# 'D'
                                    return 'Deleted'
                                elseif a:x =~# '[MA]'
                                    return 'Staged'
                                elseif a:x =~# '[RC]'
                                    return 'Renamed'
                                else
                                    return 'Unknown'
                                endif

FUNCTION  coc#highlight#add_highlight()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/highlight.vim:222
Called 107 times
Total time:   0.004229
 Self time:   0.004229

count  total (s)   self (s)
  107              0.000447   if has('nvim')
  107              0.003137     call nvim_buf_add_highlight(a:bufnr, a:src_id, a:hl_group, a:line, a:col_start, a:col_end)
                              else
                                call coc#api#call('buf_add_highlight', [a:bufnr, a:src_id, a:hl_group, a:line, a:col_start, a:col_end])
  107              0.000059   endif

FUNCTION  airline#section#create()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/section.vim:74
Called 2 times
Total time:   0.000963
 Self time:   0.000048

count  total (s)   self (s)
    2   0.000962   0.000046   return s:create(a:parts, 0)

FUNCTION  <SNR>9_LoadIndent()
    Defined: /usr/local/Cellar/neovim/0.5.0/share/nvim/runtime/indent.vim:13
Called 1 time
Total time:   0.006789
 Self time:   0.002494

count  total (s)   self (s)
    1              0.000003     if exists("b:undo_indent")
    1              0.000012       exe b:undo_indent
    1              0.000003       unlet! b:undo_indent b:did_indent
    1              0.000000     endif
    1              0.000003     let s = expand("<amatch>")
    1              0.000001     if s != ""
    1              0.000002       if exists("b:did_indent")
                            	unlet b:did_indent
    1              0.000000       endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "indent/aaa.vim" and then "indent/bbb.vim".
    2              0.000007       for name in split(s, '\.')
    1   0.006296   0.002001         exe 'runtime! indent/' . name . '.vim'
    1              0.000451         exe 'runtime! indent/' . name . '.lua'
    2              0.000003       endfor
    1              0.000001     endif

FUNCTION  152()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/tree_dir_node.vim:382
Called 160 times
Total time:   0.265702
 Self time:   0.004190

count  total (s)   self (s)
  160              0.000227     if g:NERDTreeCascadeSingleChildDir ==# 0
                                    return 0
  160              0.000067     endif
                            
  160   0.040824   0.000682     if self.isRoot()
   40              0.000032         return 0
  120              0.000048     endif
                            
  120              0.000122     if self.path.isSymLink
                                    return 0
  120              0.000081     endif
                            
  120   0.001283   0.000691     for i in g:NERDTreeBookmark.Bookmarks()
                                    if i.path.equals(self.path)
                                        return 0
                                    endif
  120              0.000196     endfor
                            
  120   0.221480   0.000701     let c = self.getVisibleChildren()
  120              0.000266     return len(c) ==# 1 && c[0].path.isDirectory

FUNCTION  airline#extensions#default#apply()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/default.vim:79
Called 381 times
Total time:   0.275219
 Self time:   0.031671

count  total (s)   self (s)
  381              0.000885   let winnr = a:context.winnr
  381              0.000612   let active = a:context.active
                            
  381   0.006071   0.004314   if airline#util#getwinvar(winnr, 'airline_render_left', active || (!active && !g:airline_inactive_collapse))
  229   0.079708   0.003123     call s:build_sections(a:builder, a:context, s:layout[0])
  152              0.000107   else
  152   0.017888   0.003333     let text = !empty(s:get_section(winnr, 'c')) ? s:get_section(winnr, 'c') : ' %f%m '
  152   0.002156   0.001399     call a:builder.add_section('airline_c'.(a:context.bufnr), text)
  381              0.000215   endif
                            
  381   0.024226   0.006191   call a:builder.split(s:get_section(winnr, 'gutter', '', ''))
                            
  381   0.004811   0.003394   if airline#util#getwinvar(winnr, 'airline_render_right', 1)
  266   0.133241   0.002799     call s:build_sections(a:builder, a:context, s:layout[1])
  381              0.000212   endif
                            
  381              0.000305   return 1

FUNCTION  277()
    Defined: ~/.vim/plugged/nerdtree-git-plugin/autoload/gitstatus/listener.vim:31
Called 1209 times
Total time:   0.312381
 Self time:   0.009046

count  total (s)   self (s)
 1209   0.311651   0.008316     call self.callback(a:event)

FUNCTION  279()
    Defined: ~/.vim/plugged/nerdtree-git-plugin/autoload/gitstatus/listener.vim:47
Called 1209 times
Total time:   0.241524
 Self time:   0.046747

count  total (s)   self (s)
 1209   0.197148   0.014239     let l:pathStr = gitstatus#util#FormatPath(a:path)
 1209              0.005337     let l:statusKey = get(self.current, l:pathStr, '')
                            
 1209              0.002188     if l:statusKey !=# ''
  505   0.011950   0.006464         return gitstatus#getIndicator(l:statusKey)
  704              0.000355     endif
                            
  704   0.008634   0.005082     if self.getOption('ShowClean', 0)
                                    return gitstatus#getIndicator('Clean')
  704              0.000421     endif
                            
  704   0.007969   0.005139     if self.getOption('ConcealBrackets', 0) && self.getOption('AlignIfConceal', 0)
                                    return ' '
  704              0.000371     endif
  704              0.000538     return ''

FUNCTION  airline#extensions#term#inactive_apply()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/term.vim:26
Called 265 times
Total time:   0.005948
 Self time:   0.005948

count  total (s)   self (s)
  265              0.001489   if getbufvar(a:2.bufnr, '&buftype') ==? 'terminal'
                                call a:1.add_section_spaced('airline_a', s:section_a)
                                call a:1.add_section_spaced('airline_b', s:neoterm_id(a:2.bufnr))
                                call a:1.add_section('airline_term', s:spc.s:termname(a:2.bufnr))
                                call a:1.split()
                                call a:1.add_section('airline_y', '')
                                call a:1.add_section_spaced('airline_z', s:section_z)
                                return 1
  265              0.000142   endif

FUNCTION  gitstatus#getIndicator()
    Defined: ~/.vim/plugged/nerdtree-git-plugin/autoload/gitstatus.vim:61
Called 505 times
Total time:   0.005486
 Self time:   0.005486

count  total (s)   self (s)
  505              0.005114     return get(get(g:, 'NERDTreeGitStatusIndicatorMapCustom', {}), a:status, s:indicatorMap[a:status])

FUNCTION  NERDTreeRender()
    Defined: ~/.vim/plugged/nerdtree/plugin/NERD_tree.vim:187
Called 39 times
Total time:   0.509817
 Self time:   0.000550

count  total (s)   self (s)
   39   0.509795   0.000529     call nerdtree#renderView()

FUNCTION  <SNR>102_conflict_marker()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/whitespace.vim:52
Called 11 times
Total time:   0.001423
 Self time:   0.001423

count  total (s)   self (s)
                              " Checks for git conflict markers
   11              0.000025   let annotation = '\%([0-9A-Za-z_.:]\+\)\?'
   11              0.000130   if match(['rst', 'markdown'], &ft) >= 0
                                " rst filetypes use '=======' as header
                                let pattern = '^\%(\%(<\{7} '.annotation. '\)\|\%(>\{7\} '.annotation.'\)\)$'
   11              0.000005   else
   11              0.000045     let pattern = '^\%(\%(<\{7} '.annotation. '\)\|\%(=\{7\}\)\|\%(>\{7\} '.annotation.'\)\)$'
   11              0.000005   endif
   11              0.001158   return search(pattern, 'nw')

FUNCTION  162()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/tree_dir_node.vim:599
Called 156 times
Total time:   2.265546
 Self time:   0.011579

count  total (s)   self (s)
  156   0.218222   0.002613     call self.path.refreshFlags(self.getNerdtree())
 1326              0.003208     for i in self.children
 1170   1.004693   0.006926         call i.refreshFlags()
 1326              0.001271     endfor

FUNCTION  164()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/tree_dir_node.vim:615
Called 2 times
Total time:   0.015395
 Self time:   0.002766

count  total (s)   self (s)
    2              0.000007     let opts = a:0 ? a:1 : {}
                            
    2   0.000245   0.000015     if !a:path.isUnder(self.path)
                                    throw 'NERDTree.InvalidArgumentsError: ' . a:path.str() . ' should be under ' . self.path.str()
    2              0.000001     endif
                            
    2   0.000478   0.000025     call self.open()
                            
    2   0.002194   0.000091     if self.path.equals(a:path.getParent())
    1   0.002711   0.000008         let n = self.findNode(a:path)
                                    " We may be looking for a newly-saved file that isn't in the tree yet.
    1              0.000002         if n ==# {}
                                        call self.refresh()
                                        let n = self.findNode(a:path)
    1              0.000001         endif
    1              0.000002         if has_key(opts, 'open')
                                        call n.open()
    1              0.000001         endif
    1              0.000001         return n
    1              0.000001     endif
                            
    1              0.000002     let p = a:path
    2   0.002335   0.000107     while !p.getParent().equals(self.path)
    1   0.000765   0.000008         let p = p.getParent()
    2              0.000003     endwhile
                            
    1   0.002321   0.000015     let n = self.findNode(p)
    1              0.000005     return n.reveal(a:path, opts)

FUNCTION  graphql#has_syntax_group()
    Defined: ~/.config/nvim/autoload/plugged/vim-polyglot/autoload/graphql.vim:28
Called 1 time
Total time:   0.000024
 Self time:   0.000024

count  total (s)   self (s)
    1              0.000001   try
    1              0.000017     silent execute 'silent highlight ' . a:group
                              catch
                                return v:false
    1              0.000001   endtry
    1              0.000001   return v:true

FUNCTION  airline#highlighter#add_separator()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim:184
Called 1484 times
Total time:   1.422811
 Self time:   0.039743

count  total (s)   self (s)
 1484              0.012625     let s:separators[a:from.a:to] = [a:from, a:to, a:inverse]
 1484   1.409041   0.025972     call <sid>exec_separator({}, a:from, a:to, a:inverse, '')

FUNCTION  NERDTreeWebDevIconsRefreshListener()
    Defined: ~/.vim/plugged/vim-devicons/plugin/webdevicons.vim:605
Called 1209 times
Total time:   0.656026
 Self time:   0.162954

count  total (s)   self (s)
 1209              0.002845   let path = a:event.subject
 1209              0.003432   let postPadding = g:WebDevIconsNerdTreeAfterGlyphPadding
 1209              0.003248   let prePadding = g:WebDevIconsNerdTreeBeforeGlyphPadding
 1209   0.020644   0.011302   let hasGitFlags = (len(path.flagSet._flagsForScope('git')) > 0)
 1209              0.005808   let hasGitNerdTreePlugin = (exists('g:loaded_nerdtree_git_status') == 1)
 1209   0.028340   0.015842   let artifactFix = s:DevIconsGetArtifactFix()
                            
                              " align vertically at the same level: non git-flag nodes with git-flag nodes
 1209              0.003108   if g:WebDevIconsNerdTreeGitPluginForceVAlign && !hasGitFlags && hasGitNerdTreePlugin
  704              0.001853     let prePadding .= ' '
 1209              0.000666   endif
                            
 1209              0.001603   if !path.isDirectory
                                " Hey we got a regular file, lets get it's proper icon
 1053   0.380965   0.020459     let flag = prePadding . WebDevIconsGetFileTypeSymbol(path.str()) . postPadding
                            
  156              0.000431   elseif path.isDirectory && g:WebDevIconsUnicodeDecorateFolderNodes == 1
                                " Ok we got a directory, some more tests and checks
  156              0.000333     let directoryOpened = 0
                            
  156              0.000743     if g:DevIconsEnableFoldersOpenClose && len(path.flagSet._flagsForScope('webdevicons')) > 0
                                  " did the user set different icons for open and close?
                            
                                  " isOpen is not available on the path listener directly
                                  " but we added one via overriding particular keymappings for NERDTree
                                  if has_key(path, 'isOpen') && path.isOpen == 1
                                    let directoryOpened = 1
                                  endif
  156              0.000108     endif
                            
  156              0.000381     if g:WebDevIconsUnicodeDecorateFolderNodesExactMatches == 1
                                  " Did the user enable exact matching of folder type/names
                                  " think node_modules
  156              0.000378       if g:DevIconsEnableFoldersOpenClose && directoryOpened
                                    " the folder is open
                                    let flag = prePadding . g:DevIconsDefaultFolderOpenSymbol . artifactFix . postPadding
  156              0.000234       else
                                    " the folder is not open
  156              0.000238         if path.isSymLink
                                      " We have a symlink
                                      let flag = prePadding . g:WebDevIconsUnicodeDecorateFolderNodesSymlinkSymbol . artifactFix . postPadding
  156              0.000130         else
                                      " We have a regular folder
  156   0.081213   0.004873           let flag = prePadding . WebDevIconsGetFileTypeSymbol(path.str(), path.isDirectory) . postPadding
  156              0.000145         endif
  156              0.000143       endif
                            
                                else
                                  " the user did not enable exact matching
                                  if g:DevIconsEnableFoldersOpenClose && directoryOpened
                                    " the folder is open
                                    let flag = prePadding . g:DevIconsDefaultFolderOpenSymbol . artifactFix . postPadding
                                  else
                                    " the folder is not open
                                    if path.isSymLink
                                      " We have a symlink
                                      let flag = prePadding . g:WebDevIconsUnicodeDecorateFolderNodesSymlinkSymbol . artifactFix . postPadding
                                    else
                                      " We have a regular folder
                                      let flag = prePadding . g:WebDevIconsUnicodeDecorateFolderNodesDefaultSymbol . artifactFix . postPadding
                                    endif
                                  endif
                            
  156              0.000089     endif
                            
                              else
                                let flag = prePadding . ' ' . artifactFix . postPadding
 1209              0.000633   endif
                            
 1209   0.016652   0.009616   call path.flagSet.clearFlags('webdevicons')
                            
 1209              0.002214   if flag !=? ''
 1209   0.035576   0.008227     call path.flagSet.addFlag('webdevicons', flag)
 1209              0.000675   endif
                            

FUNCTION  81()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/bookmark.vim:35
Called 1329 times
Total time:   0.009013
 Self time:   0.009013

count  total (s)   self (s)
 1329              0.004351     if !exists('g:NERDTreeBookmarks')
                                    let g:NERDTreeBookmarks = []
 1329              0.000742     endif
 1329              0.001530     return g:NERDTreeBookmarks

FUNCTION  coc#highlight#get()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/highlight.vim:19
Called 59 times
Total time:   0.014520
 Self time:   0.013883

count  total (s)   self (s)
   59              0.000283   if !has('nvim-0.5.0') && !exists('*prop_list')
                                throw 'Get highlights requires neovim 0.5.0 or vim support prop_list()'
   59              0.000036   endif
   59              0.000287   if !has_key(s:namespace_map, a:key) || !bufloaded(a:bufnr)
                                return {}
   59              0.000026   endif
   59   0.001431   0.000793   let ns = coc#highlight#create_namespace(a:key)
   59              0.000108   let current = {}
   59              0.000196   if has('nvim-0.5.0')
   59              0.000248     let end = a:end == -1 ? [-1, -1] : [a:end, 0]
   59              0.001856     let markers = nvim_buf_get_extmarks(a:bufnr, ns, [a:start, 0], end, {'details': v:true})
  212              0.000533     for [_, row, start_col, details] in markers
  153              0.000349       let delta = details['end_row'] - row
  153              0.000342       if delta > 1 || (delta == 1 && details['end_col'] != 0)
                                    " Don't known neovim's api for multiple lines markers.
                                    continue
  153              0.000091       endif
  153              0.000740       let lines = getbufline(a:bufnr, row + 1)
  153              0.000320       if empty(lines)
                                    " It's possible that markers exceeded last line.
                                    continue
  153              0.000126       endif
  153              0.000332       let text = lines[0]
  153              0.000756       let curr = get(current, string(row), [])
  153              0.001343       call add(curr, { 'hlGroup': details['hl_group'], 'lnum': row, 'colStart': start_col, 'colEnd': delta == 1 ? strlen(text) : details['end_col'] })
  153              0.000569       let current[string(row)] = curr
  212              0.000309     endfor
                              else
                                let id = s:prop_offset + ns
                                " we could only get textprops line by line
                                let end = a:end == -1 ? getbufinfo(a:bufnr)[0]['linecount'] : a:end
                                for line in range(a:start + 1, end)
                                  let items = []
                                  for prop in prop_list(line, {'bufnr': a:bufnr, 'id': id})
                                    " vim have support for cross line text props, but we're not using
                                    call add(items, { 'hlGroup': s:prop_type_hlgroup(prop['type']), 'lnum': line - 1, 'colStart': prop['col'] - 1, 'colEnd': prop['col'] - 1 + prop['length'] - (prop['end'] == 0 ? 1 : 0), })
                                  endfor
                                  if !empty(items)
                                    let current[string(line - 1)] = items
                                  endif
                                endfor
   59              0.000038   endif
   59              0.000085   return current

FUNCTION  airline#util#wrap()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim:42
Called 5744 times
Total time:   0.039762
 Self time:   0.036204

count  total (s)   self (s)
 5744   0.022891   0.019334   if a:minwidth > 0 && airline#util#winwidth() < a:minwidth
                                return ''
 5744              0.002754   endif
 5744              0.005424   return a:text

FUNCTION  coc#util#echo_messages()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/util.vim:172
Called 3 times
Total time:   0.447943
 Self time:   0.447943

count  total (s)   self (s)
    3              0.000120   if a:hl !~# 'Error' && (mode() !~# '\v^(i|n)$')
                                return
    3              0.000004   endif
    3              0.000038   let msgs = filter(copy(a:msgs), '!empty(v:val)')
    3              0.000006   if empty(msgs)
                                return
    3              0.000003   endif
    3              0.000181   execute 'echohl '.a:hl
    3              0.000185   echom a:msgs[0]
    3              0.447261   redraw
    3              0.000028   echo join(msgs, "\n")
    3              0.000075   echohl None

FUNCTION  gitgutter#debug#log()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/debug.vim:70
Called 100 times
Total time:   0.004316
 Self time:   0.004316

count  total (s)   self (s)
  100              0.000183   if g:gitgutter_log
                                if s:new_log_session && gitgutter#async#available()
                                  if exists('*ch_logfile')
                                    call ch_logfile(s:channel_log, 'w')
                                  endif
                                endif
                            
                                execute 'redir >> '.s:log_file
                                  if s:new_log_session
                                    let s:start = reltime()
                                    silent echo "\n==== start log session ===="
                                  endif
                            
                                  let elapsed = reltimestr(reltime(s:start)).' '
                                  silent echo ''
                                  " callers excluding this function
                                  silent echo elapsed.expand('<sfile>')[:-22].':'
                                  silent echo elapsed.s:format_for_log(a:message)
                                  if a:0 && !empty(a:1)
                                    for msg in a:000
                                      silent echo elapsed.s:format_for_log(msg)
                                    endfor
                                  endif
                                redir END
                            
                                let s:new_log_session = 0
  100              0.000065   endif

FUNCTION  <SNR>29_notify()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/client.vim:189
Called 1121 times
Total time:   0.104537
 Self time:   0.096160

count  total (s)   self (s)
 1121   0.024446   0.016070   let channel = coc#client#get_channel(self)
 1121              0.002582   if empty(channel)
                                return ''
 1121              0.000581   endif
 1121              0.001118   try
 1121              0.000982     if s:is_vim
                                  call ch_sendraw(channel, json_encode([0, [a:method, a:args]])."\n")
 1121              0.000946     else
 1121              0.034300       call call('rpcnotify', [channel, a:method] + a:args)
 1121              0.000959     endif
                              catch /.*/
                                if v:exception =~# 'E475'
                                  if get(g:, 'coc_vim_leaving', 0)
                                    return
                                  endif
                                  echohl Error | echom '['.self.name.'] server connection lost' | echohl None
                                  let name = self.name
                                  call s:on_exit(name, 0)
                                  execute 'silent do User ConnectionLost'.toupper(name[0]).name[1:]
                                elseif v:exception =~# 'E12'
                                  " neovim's bug, ignore it
                                else
                                  echohl Error | echo 'Error on notify ('.a:method.'): '.v:exception | echohl None
                                endif
 1121              0.001430   endtry

FUNCTION  <SNR>169_trim()
    Defined: ~/.vim/plugged/vim-jsx-pretty/autoload/jsx_pretty/indent.vim:16
Called 28 times
Total time:   0.000553
 Self time:   0.000553

count  total (s)   self (s)
   28              0.000522   return substitute(a:line, '^\s*\|\s*$', '', 'g')

FUNCTION  <SNR>169_start_col()
    Defined: ~/.vim/plugged/vim-jsx-pretty/autoload/jsx_pretty/indent.vim:31
Called 42 times
Total time:   0.000748
 Self time:   0.000748

count  total (s)   self (s)
   42              0.000706   return len(matchstr(getline(a:lnum), '^\s*')) + 1

FUNCTION  airline#extensions#apply_left_override()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions.vim:63
Called 2 times
Total time:   0.001027
 Self time:   0.000064

count  total (s)   self (s)
    2              0.000008   let w:airline_section_a = a:section1
    2              0.000006   let w:airline_section_b = a:section2
    2   0.000995   0.000032   let w:airline_section_c = airline#section#create(['readonly'])
    2              0.000006   let w:airline_render_left = 1
    2              0.000005   let w:airline_render_right = 0

FUNCTION  airline#util#getwinvar()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim:82
Called 4384 times
Total time:   0.018251
 Self time:   0.018251

count  total (s)   self (s)
 4384              0.016144     return getwinvar(a:winnr, a:key, a:def)

FUNCTION  <SNR>61_filename()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:219
Called 15 times
Total time:   0.002233
 Self time:   0.000201

count  total (s)   self (s)
   15   0.002210   0.000178   return fnamemodify(s:abs_path(a:bufnr, 0), ':t')

FUNCTION  gitstatus#job#Spawn()
    Defined: ~/.vim/plugged/nerdtree-git-plugin/autoload/gitstatus/job.vim:132
Called 45 times
Total time:   0.166965
 Self time:   0.002135

count  total (s)   self (s)
   45   0.001731   0.000476     let l:job = s:newJob(a:name, a:opts)
   45   0.164516   0.000941     call l:job.run(a:cmd)
   45              0.000166     return l:job

FUNCTION  airline#extensions#whitespace#check()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/whitespace.vim:64
Called 522 times
Total time:   0.089051
 Self time:   0.069509

count  total (s)   self (s)
  522              0.002675   let max_lines = get(g:, 'airline#extensions#whitespace#max_lines', 20000)
  522              0.004028   if &readonly || !&modifiable || !s:enabled || line('$') > max_lines || get(b:, 'airline_whitespace_disabled', 0)
                                return ''
  522              0.000314   endif
  522              0.007666   let skip_check_ft = extend(s:skip_check_ft, get(g:, 'airline#extensions#whitespace#skip_indent_check_ft', {}), 'force')
                            
  522              0.001799   if !exists('b:airline_whitespace_check')
   11              0.000040     let b:airline_whitespace_check = ''
   11              0.000064     let checks = get(b:, 'airline_whitespace_checks', get(g:, 'airline#extensions#whitespace#checks', s:default_checks))
                            
   11              0.000012     let trailing = 0
   11              0.000012     let check = 'trailing'
   11              0.000102     if index(checks, check) > -1 && index(get(skip_check_ft, &ft, []), check) < 0
   11              0.000010       try
   11              0.000052         let regexp = get(b:, 'airline_whitespace_trailing_regexp', get(g:, 'airline#extensions#whitespace#trailing_regexp', '\s$'))
   11              0.000639         let trailing = search(regexp, 'nw')
                                  catch
                                    call airline#util#warning(printf('Whitespace: error occurred evaluating "%s"', regexp))
                                    echomsg v:exception
                                    return ''
   11              0.000010       endtry
   11              0.000005     endif
                            
   11              0.000012     let mixed = 0
   11              0.000012     let check = 'indent'
   11              0.000097     if index(checks, check) > -1 && index(get(skip_check_ft, &ft, []), check) < 0
   11   0.002081   0.000162       let mixed = s:check_mixed_indent()
   11              0.000015     endif
                            
   11              0.000019     let mixed_file = ''
   11              0.000013     let check = 'mixed-indent-file'
   11              0.000148     if index(checks, check) > -1 && index(get(skip_check_ft, &ft, []), check) < 0
   11   0.000855   0.000150       let mixed_file = s:check_mixed_indent_file()
   11              0.000005     endif
                            
   11              0.000013     let long = 0
   11              0.000025     if index(checks, 'long') > -1 && &tw > 0
                                  let long = search('\%>'.&tw.'v.\+', 'nw')
   11              0.000005     endif
                            
   11              0.000012     let conflicts = 0
   11              0.000019     if index(checks, 'conflicts') > -1
   11   0.001537   0.000114       let conflicts = s:conflict_marker()
   11              0.000012     endif
                            
   11              0.000046     if trailing != 0 || mixed != 0 || long != 0 || !empty(mixed_file) || conflicts != 0
    4              0.000010       let b:airline_whitespace_check = s:symbol
    4              0.000008       if strlen(s:symbol) > 0
    4              0.000011         let space = (g:airline_symbols.space)
                                  else
                                    let space = ''
    4              0.000002       endif
                            
    4              0.000004       if s:show_message
    4              0.000003         if trailing != 0
    4              0.000014           let trailing_fmt = get(g:, 'airline#extensions#whitespace#trailing_format', '[%s]trailing')
    4              0.000025           let b:airline_whitespace_check .= space.printf(trailing_fmt, trailing)
    4              0.000002         endif
    4              0.000003         if mixed != 0
                                      let mixed_indent_fmt = get(g:, 'airline#extensions#whitespace#mixed_indent_format', '[%s]mixed-indent')
                                      let b:airline_whitespace_check .= space.printf(mixed_indent_fmt, mixed)
    4              0.000002         endif
    4              0.000003         if long != 0
                                      let long_fmt = get(g:, 'airline#extensions#whitespace#long_format', '[%s]long')
                                      let b:airline_whitespace_check .= space.printf(long_fmt, long)
    4              0.000002         endif
    4              0.000008         if !empty(mixed_file)
                                      let mixed_indent_file_fmt = get(g:, 'airline#extensions#whitespace#mixed_indent_file_format', '[%s]mix-indent-file')
                                      let b:airline_whitespace_check .= space.printf(mixed_indent_file_fmt, mixed_file)
    4              0.000001         endif
    4              0.000004         if conflicts != 0
                                      let conflicts_fmt = get(g:, 'airline#extensions#whitespace#conflicts_format', '[%s]conflicts')
                                      let b:airline_whitespace_check .= space.printf(conflicts_fmt, conflicts)
    4              0.000009         endif
    4              0.000002       endif
   11              0.000011     endif
  522              0.000411   endif
  522   0.020909   0.005414   return airline#util#shorten(b:airline_whitespace_check, 120, 9)

FUNCTION  gitgutter#hunk#hunks()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/hunk.vim:10
Called 42 times
Total time:   0.001276
 Self time:   0.000708

count  total (s)   self (s)
   42   0.001155   0.000587   return gitgutter#utility#getbufvar(a:bufnr, 'hunks', [])

FUNCTION  gitstatus#util#ParseGitStatusLine()
    Defined: ~/.vim/plugged/nerdtree-git-plugin/autoload/gitstatus/util.vim:178
Called 610 times
Total time:   0.025623
 Self time:   0.019544

count  total (s)   self (s)
  610              0.001785     if get(a:opts, 'NERDTreeGitStatusPorcelainVersion', 2) ==# 2
  610              0.001464         if a:statusLine[0] ==# '1'
  484   0.011176   0.005096             let l:statusKey = s:getStatusKey(a:statusLine[2], a:statusLine[3])
  484              0.000897             let l:pathStr = a:statusLine[113:]
  126              0.000171         elseif a:statusLine[0] ==# '2'
                                        let l:statusKey = 'Renamed'
                                        let l:pathStr = a:statusLine[113:]
                                        let l:pathStr = l:pathStr[stridx(l:pathStr, ' ')+1:]
  126              0.000278         elseif a:statusLine[0] ==# 'u'
                                        let l:statusKey = 'Unmerged'
                                        let l:pathStr = a:statusLine[161:]
  126              0.000178         elseif a:statusLine[0] ==# '?'
  126              0.000144             let l:statusKey = 'Untracked'
  126              0.000184             let l:pathStr = a:statusLine[2:]
                                    elseif a:statusLine[0] ==# '!'
                                        let l:statusKey = 'Ignored'
                                        let l:pathStr = a:statusLine[2:]
                                    else
                                        throw '[nerdtree_git_status] unknown status: ' . a:statusLine
  610              0.000246         endif
  610              0.000981         return [l:pathStr, l:statusKey]
                                else
                                    let l:pathStr = a:statusLine[3:]
                                    let l:statusKey = s:getStatusKey(a:statusLine[0], a:statusLine[1])
                                    return [l:pathStr, l:statusKey]
                                endif

FUNCTION  coc#_cancel()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc.vim:97
Called 70 times
Total time:   0.003814
 Self time:   0.001802

count  total (s)   self (s)
                              " hack for close pum
   70              0.000228   if pumvisible()
   16              0.000473     let g:coc#_context = {'start': 0, 'preselect': -1,'candidates': []}
   16              0.000124     call feedkeys("\<Plug>CocRefresh", 'i')
   16   0.002195   0.000183     call coc#rpc#notify('stopCompletion', [])
   70              0.000094   endif

FUNCTION  283()
    Defined: ~/.vim/plugged/nerdtree-git-plugin/autoload/gitstatus/listener.vim:77
Called 1 time
Total time:   0.000024
 Self time:   0.000024

count  total (s)   self (s)
    1              0.000024     let self.current = self.next

FUNCTION  airline#highlighter#highlight_modified_inactive()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim:205
Called 29 times
Total time:   0.015886
 Self time:   0.001657

count  total (s)   self (s)
   29              0.000169     if getbufvar(a:bufnr, '&modified')
   20              0.000368       let colors = exists('g:airline#themes#{g:airline_theme}#palette.inactive_modified.airline_c') ? g:airline#themes#{g:airline_theme}#palette.inactive_modified.airline_c : []
    9              0.000007     else
    9              0.000185       let colors = exists('g:airline#themes#{g:airline_theme}#palette.inactive.airline_c') ? g:airline#themes#{g:airline_theme}#palette.inactive.airline_c : []
   29              0.000017     endif
                            
   29              0.000060     if !empty(colors)
   29   0.014809   0.000581       call airline#highlighter#exec('airline_c'.(a:bufnr).'_inactive', colors)
   29              0.000017     endif

FUNCTION  <SNR>73_setup_styledEmmetAbbreviation()
    Defined: ~/.vim/plugged/emmet-vim/plugin/emmet.vim:177
Called 1 time
Total time:   0.000022
 Self time:   0.000022

count  total (s)   self (s)
    1              0.000007   if index(['javascript', 'javascriptreact', 'typescript', 'typescriptreact'], &filetype) != -1
    1              0.000013     syntax match styledEmmetAbbreviation "[a-z0-9#+!%]\+" containedin=styledDefinition contained
    1              0.000000   endif

FUNCTION  112()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/tree_file_node.vim:102
Called 162 times
Total time:   0.037259
 Self time:   0.002163

count  total (s)   self (s)
  162   0.037150   0.002054     return self.path.str() ==# a:treenode.path.str()

FUNCTION  gitgutter#hunk#increment_lines_modified()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/hunk.vim:34
Called 126 times
Total time:   0.006568
 Self time:   0.002430

count  total (s)   self (s)
  126   0.003547   0.000977   let summary = gitgutter#hunk#summary(a:bufnr)
  126              0.000178   let summary[1] += a:count
  126   0.002662   0.001095   call gitgutter#utility#setbufvar(a:bufnr, 'summary', summary)

FUNCTION  <SNR>26_SyncAutocmd()
    Defined: ~/.vim/plugged/coc.nvim/plugin/coc.vim:252
Called 3 times
Total time:   0.492472
 Self time:   0.000085

count  total (s)   self (s)
    3              0.000019   if !g:coc_service_initialized
                                return
    3              0.000004   endif
    3   0.492434   0.000048   call coc#rpc#request('CocAutocmd', a:000)

FUNCTION  287()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:131
Called 15 times
Total time:   0.000481
 Self time:   0.000179

count  total (s)   self (s)
   15   0.000443   0.000141   call gitgutter#utility#setbufvar(a:buffer, 'path', -2)

FUNCTION  airline#update_statusline_inactive()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline.vim:173
Called 116 times
Total time:   1.501894
 Self time:   0.019328

count  total (s)   self (s)
  116   0.005652   0.001185   if airline#util#stl_disabled(winnr())
                                return
  116              0.000066   endif
  381              0.000736   for nr in a:range
  265   0.014960   0.003132     if airline#util#stl_disabled(nr)
                                  continue
  265              0.000183     endif
  265              0.001102     call setwinvar(nr, 'airline_active', 0)
  265              0.001442     let context = { 'winnr': nr, 'active': 0, 'bufnr': winbufnr(nr) }
  265              0.000674     if get(g:, 'airline_inactive_alt_sep', 0)
                                  call extend(context, { 'left_sep': g:airline_left_alt_sep, 'right_sep': g:airline_right_alt_sep }, 'keep')
  265              0.000150     endif
  265   1.472598   0.006328     call s:invoke_funcrefs(context, g:airline_inactive_funcrefs)
  381              0.000625   endfor

FUNCTION  <SNR>91_check_defined_section()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions.vim:47
Called 116 times
Total time:   0.001506
 Self time:   0.001506

count  total (s)   self (s)
  116              0.000711   if !exists('w:airline_section_{a:name}')
  116              0.000581     let w:airline_section_{a:name} = g:airline_section_{a:name}
  116              0.000069   endif

FUNCTION  <SNR>169_is_jsx_backticks()
    Defined: ~/.vim/plugged/vim-jsx-pretty/autoload/jsx_pretty/indent.vim:92
Called 14 times
Total time:   0.000154
 Self time:   0.000154

count  total (s)   self (s)
   14              0.000131   return a:syntax =~? 'jsxBackticks'

FUNCTION  gitgutter#hunk#set_hunks()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/hunk.vim:5
Called 42 times
Total time:   0.005207
 Self time:   0.002395

count  total (s)   self (s)
   42   0.003448   0.001814   call gitgutter#utility#setbufvar(a:bufnr, 'hunks', a:hunks)
   42   0.001677   0.000499   call s:reset_summary(a:bufnr)

FUNCTION  coc#float#nvim_win_enter()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/float.vim:1125
Called 4 times
Total time:   0.000081
 Self time:   0.000081

count  total (s)   self (s)
    4              0.000030   let kind = getwinvar(a:winid, 'kind', '')
    4              0.000016   if kind == 'buttons' || kind == 'close'
                                if empty(maparg('<LeftRelease>', 'n'))
                                  nnoremap <buffer><silent> <LeftRelease> :call coc#float#nvim_float_click()<CR>
                                endif
    4              0.000003   endif

FUNCTION  coc#highlight#clear_match_group()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/highlight.vim:405
Called 27 times
Total time:   0.002261
 Self time:   0.002261

count  total (s)   self (s)
   27              0.000189   let winid = a:winid == 0 ? win_getid() : a:winid
   27              0.000471   if empty(getwininfo(winid))
                                " not valid
                                return
   27              0.000020   endif
   27              0.000057   if s:clear_match_by_window
   27              0.000374     let arr = filter(getmatches(winid), 'v:val["group"] =~# "'.a:match.'"')
   35              0.000068     for item in arr
    8              0.000032       call matchdelete(item['id'], winid)
   35              0.000040     endfor
                              else
                                let curr = win_getid()
                                let switch = exists('*nvim_set_current_win') && curr != winid
                                if switch
                                  noa call nvim_set_current_win(a:winid)
                                endif
                                if win_getid() == winid
                                  let arr = filter(getmatches(), 'v:val["group"] =~# "'.a:match.'"')
                                  for item in arr
                                    call matchdelete(item['id'])
                                  endfor
                                endif
                                if switch
                                  noa call nvim_set_current_win(curr)
                                endif
   27              0.000011   endif

FUNCTION  gitgutter#all()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter.vim:3
Called 7 times
Total time:   0.104970
 Self time:   0.039856

count  total (s)   self (s)
    7              0.000031   let visible = tabpagebuflist()
                            
 2331              0.003225   for bufnr in range(1, bufnr('$') + 1)
 2324              0.003417     if buflisted(bufnr)
   63              0.009272       let file = expand('#'.bufnr.':p')
   63              0.000270       if !empty(file)
   63              0.000182         if index(visible, bufnr) != -1
    9   0.063511   0.000378           call gitgutter#process_buffer(bufnr, a:force)
   54              0.000058         elseif a:force
   54   0.002698   0.000718           call s:reset_tick(bufnr)
   63              0.000039         endif
   63              0.000026       endif
 2324              0.000806     endif
 2331              0.001625   endfor

FUNCTION  gitgutter#utility#extension()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:88
Called 43 times
Total time:   0.009266
 Self time:   0.000757

count  total (s)   self (s)
   43   0.009166   0.000657   return fnamemodify(s:abs_path(a:bufnr, 0), ':e')

FUNCTION  245()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/ui.vim:306
Called 3040 times
Total time:   0.003759
 Self time:   0.003759

count  total (s)   self (s)
 3040              0.002933     return self._ignoreEnabled ==# 1

FUNCTION  coc#float#get_float_win_list()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/float.vim:606
Called 120 times
Total time:   0.015690
 Self time:   0.015690

count  total (s)   self (s)
  120              0.000309   let res = []
  120              0.000544   let all = get(a:, 1, 0)
  120              0.000190   if s:is_vim
                                if s:popup_list_api
                                  return filter(popup_list(), 'popup_getpos(v:val)["visible"]'.(all ? '' : '&& getwinvar(v:val, "float", 0)'))
                                endif
                                return filter(s:popup_list, 's:popup_visible(v:val)')
  120              0.001039   elseif has('nvim') && exists('*nvim_win_get_config')
  120              0.000286     let res = []
  556              0.001418     for i in range(1, winnr('$'))
  436              0.001178       let id = win_getid(i)
  436              0.003541       let config = nvim_win_get_config(id)
  436              0.001814       if empty(config) || empty(config['relative'])
  351              0.000369         continue
   85              0.000045       endif
                                  " ignore border & button window & others
   85              0.000168       if !all && !getwinvar(id, 'float', 0)
    1              0.000001         continue
   84              0.000033       endif
   84              0.000220       call add(res, id)
  204              0.000427     endfor
  120              0.000166     return res
                              endif
                              return []

FUNCTION  graphql#javascript_tags()
    Defined: ~/.config/nvim/autoload/plugged/vim-polyglot/autoload/graphql.vim:37
Called 1 time
Total time:   0.000006
 Self time:   0.000006

count  total (s)   self (s)
    1              0.000005   return get(g:, 'graphql_javascript_tags', ['gql', 'graphql', 'Relay.QL'])

FUNCTION  coc#float#close()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/float.vim:580
Called 26 times
Total time:   0.032011
 Self time:   0.001038

count  total (s)   self (s)
   26   0.016600   0.000465   call coc#float#close_related(a:winid)
   26   0.015296   0.000459   call s:close_win(a:winid)
   26              0.000022   return 1

FUNCTION  <SNR>99_get_hunks_gitgutter()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/hunks.vim:60
Called 521 times
Total time:   0.043894
 Self time:   0.012981

count  total (s)   self (s)
  521   0.010733   0.006824   if !get(g:, 'gitgutter_enabled', 0) || s:is_branch_empty()
                                return ''
  521              0.000304   endif
  521   0.031717   0.004713   return GitGutterGetHunkSummary()

FUNCTION  airline#highlighter#highlight()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim:255
Called 29 times
Total time:  11.292424
 Self time:   0.619954

count  total (s)   self (s)
   29              0.000101     let bufnr = a:0 ? a:1 : ''
   29              0.000127     let p = g:airline#themes#{g:airline_theme}#palette
                            
                                " draw the base mode, followed by any overrides
   29              0.000374     let mapped = map(a:modes, 'v:val == a:modes[0] ? v:val : a:modes[0]."_".v:val')
   29              0.000077     let suffix = a:modes[0] == 'inactive' ? '_inactive' : ''
   29              0.000051     let airline_grouplist = []
   29              0.000495     let buffers_in_tabpage = sort(tabpagebuflist())
   29              0.000103     if exists("*uniq")
   29              0.000157       let buffers_in_tabpage = uniq(buffers_in_tabpage)
   29              0.000019     endif
                                " mapped might be something like ['normal', 'normal_modified']
                                " if a group is in both modes available, only define the second
                                " that is how this was done previously overwrite the previous definition
   79              0.000169     for mode in reverse(mapped)
   50              0.000419       if exists('g:airline#themes#{g:airline_theme}#palette[mode]')
   50              0.000206         let dict = g:airline#themes#{g:airline_theme}#palette[mode]
12904              0.031242         for kvp in items(dict)
12854              0.022527           let mode_colors = kvp[1]
12854              0.017323           let name = kvp[0]
12854              0.026175           if name is# 'airline_c' && !empty(bufnr) && suffix is# '_inactive'
    2              0.000004             let name = 'airline_c'.bufnr
12854              0.005513           endif
                                      " do not re-create highlighting for buffers that are no longer visible
                                      " in the current tabpage
12854              0.060855           if name =~# 'airline_c\d\+'
12175              0.079011             let bnr = matchstr(name, 'airline_c\zs\d\+') + 0
12175              0.027444             if bnr > 0 && index(buffers_in_tabpage, bnr) == -1
12031              0.007837               continue
  144              0.000055             endif
  679              0.003623           elseif (name =~# '_to_') || (name[0:10] is# 'airline_tab' && !empty(suffix))
                                        " group will be redefined below at exec_separator
                                        " or is not needed for tabline with '_inactive' suffix
                                        " since active flag is 1 for builder)
  336              0.000244             continue
  487              0.000238           endif
  487   0.011580   0.005937           if s:group_not_done(airline_grouplist, name.suffix)
  342   0.134900   0.004642             call airline#highlighter#exec(name.suffix, mode_colors)
  487              0.000327           endif
                            
  487              0.001163           if !has_key(p, 'accents')
                                        " work around a broken installation
                                        " shouldn't actually happen, p should always contain accents
                                        continue
  487              0.000226           endif
                            
 1461              0.003012           for accent in keys(s:accents)
  974              0.002270             if !has_key(p.accents, accent)
                                          continue
  974              0.000383             endif
  974              0.004275             let colors = copy(mode_colors)
  974              0.002192             if p.accents[accent][0] != ''
  487              0.001015               let colors[0] = p.accents[accent][0]
  974              0.000466             endif
  974              0.001701             if p.accents[accent][2] != ''
  487              0.000838               let colors[2] = p.accents[accent][2]
  974              0.000380             endif
  974              0.001538             if len(colors) >= 5
  974              0.002918               let colors[4] = get(p.accents[accent], 4, '')
                                        else
                                          call add(colors, get(p.accents[accent], 4, ''))
  974              0.000427             endif
  974   0.020878   0.011429             if s:group_not_done(airline_grouplist, name.suffix.'_'.accent)
  684   0.259747   0.009802               call airline#highlighter#exec(name.suffix.'_'.accent, colors)
  974              0.000520             endif
 1461              0.000864           endfor
  537              0.000367         endfor
                            
   50              0.000136         if empty(s:separators)
                                      " nothing to be done
                                      continue
   50              0.000024         endif
                                    " TODO: optimize this
13162              0.036675         for sep in items(s:separators)
                                      " we cannot check, that the group already exists, else the separators
                                      " might not be correctly defined. But perhaps we can skip above groups
                                      " that match the '_to_' name, because they would be redefined here...
13112  10.444907   0.167733           call <sid>exec_separator(dict, sep[1][0], sep[1][1], sep[1][2], suffix)
13162              0.010297         endfor
   50              0.000024       endif
   79              0.000297     endfor

FUNCTION  <SNR>67_init()
    Defined: ~/.vim/plugged/vim-airline/plugin/airline.vim:15
Called 110 times
Total time:   0.000357
 Self time:   0.000357

count  total (s)   self (s)
  110              0.000163   if s:airline_initialized
  110              0.000091     return
                              endif
                              let s:airline_initialized = 1
                            
                              call airline#extensions#load()
                              call airline#init#sections()
                            
                              let s:theme_in_vimrc = exists('g:airline_theme')
                              if s:theme_in_vimrc
                                try
                                  if g:airline_theme is# 'random'
                                    let g:airline_theme=s:random_theme()
                                  endif
                                  let palette = g:airline#themes#{g:airline_theme}#palette
                                catch
                                  call airline#util#warning(printf('Could not resolve airline theme "%s". Themes have been migrated to github.com/vim-airline/vim-airline-themes.', g:airline_theme))
                                  let g:airline_theme = 'dark'
                                endtry
                                try
                                  silent call airline#switch_theme(g:airline_theme)
                                catch
                                  call airline#util#warning(printf('Could not find airline theme "%s".', g:airline_theme))
                                  let g:airline_theme = 'dark'
                                  silent call airline#switch_theme(g:airline_theme)
                                endtry
                              else
                                let g:airline_theme = 'dark'
                                silent call s:on_colorscheme_changed()
                              endif
                            
                              call airline#util#doautocmd('AirlineAfterInit')

FUNCTION  <SNR>51_refreshGitStatus()
    Defined: ~/.vim/plugged/nerdtree-git-plugin/nerdtree_plugin/git_status.vim:150
Called 44 times
Total time:   0.169208
 Self time:   0.003487

count  total (s)   self (s)
   44              0.000671     let l:opts =  { 'on_failed_cb': function('s:onGitStatusFailedCB'), 'on_success_cb': function('s:onGitStatusSuccessCB'), 'cwd': a:workdir }
   44   0.168142   0.002420     let l:job = gitstatus#job#Spawn(a:name, s:buildGitStatusCommand(a:workdir), l:opts)
   44              0.000136     return l:job

FUNCTION  <SNR>51_getGitWorkdir()
    Defined: ~/.vim/plugged/nerdtree-git-plugin/nerdtree_plugin/git_status.vim:131
Called 1 time
Total time:   0.003865
 Self time:   0.000086

count  total (s)   self (s)
    1   0.003862   0.000083     call gitstatus#job#Spawn('git-workdir', s:buildGitWorkdirCommand(a:ntRoot), { 'on_success_cb': function('s:onGitWorkdirSuccessCB'), 'on_failed_cb': function('s:onGitWorkdirFailedCB'), 'cwd': a:ntRoot, })

FUNCTION  airline#parts#ffenc()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/parts.vim:108
Called 522 times
Total time:   0.015096
 Self time:   0.015096

count  total (s)   self (s)
  522              0.002127   let expected = get(g:, 'airline#parts#ffenc#skip_expected_string', '')
  522              0.001114   let bomb     = &bomb ? '[BOM]' : ''
  522              0.002230   let noeolf   = &eol ? '' : '[!EOL]'
  522              0.003519   let ff       = strlen(&ff) ? '['.&ff.']' : ''
  522              0.002649   if expected is# &fenc.bomb.noeolf.ff
                                return ''
  522              0.000309   else
  522              0.001828     return &fenc.bomb.noeolf.ff
                              endif

FUNCTION  airline#extensions#nvimlsp#get_error()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/nvimlsp.vim:42
Called 522 times
Total time:   0.026330
 Self time:   0.006389

count  total (s)   self (s)
  522   0.025851   0.005909   return airline#extensions#nvimlsp#get('Error')

FUNCTION  SyncTree()
    Defined: ~/.config/nvim/vim-plug/benawad.vim:101
Called 1 time
Total time:   0.030830
 Self time:   0.000179

count  total (s)   self (s)
    1   0.000227   0.000026   if &modifiable && IsNERDTreeOpen() && strlen(expand('%')) > 0 && !&diff
    1   0.030512   0.000062     NERDTreeFind
    1              0.000086     wincmd p
    1              0.000001   endif

FUNCTION  <SNR>60_on_bufenter()
    Defined: ~/.vim/plugged/vim-gitgutter/plugin/gitgutter.vim:221
Called 5 times
Total time:   0.010858
 Self time:   0.000230

count  total (s)   self (s)
    5   0.000200   0.000042   call gitgutter#setup_maps()
                            
                              " To keep vim's start-up fast, do not process the buffer when vim is starting.
                              " Instead process it a short time later.  Normally we would rely on our
                              " CursorHold autocommand to handle this but it turns out CursorHold is not
                              " guaranteed to fire if the user has not typed anything yet; so set up a
                              " timer instead.  The disadvantage is that if CursorHold does fire, the
                              " plugin will do a round of unnecessary work; but since there will not have
                              " been any changes to the buffer since the first round, the second round
                              " will be cheap.
    5              0.000025   if has('vim_starting') && !$VIM_GITGUTTER_TEST
                                if exists('*timer_start')
                                  call timer_start(&updatetime, 'GitGutterCursorHold')
                                endif
                                return
    5              0.000002   endif
                            
    5              0.000015   if exists('t:gitgutter_didtabenter') && t:gitgutter_didtabenter
                                let t:gitgutter_didtabenter = 0
                                call gitgutter#all(!g:gitgutter_terminal_reports_focus)
    5              0.000003   else
    5   0.010533   0.000064     call gitgutter#process_buffer(bufnr(''), !g:gitgutter_terminal_reports_focus)
    5              0.000004   endif

FUNCTION  coc#float#close_auto_hide_wins()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/float.vim:752
Called 26 times
Total time:   0.002872
 Self time:   0.000679

count  total (s)   self (s)
   26   0.002527   0.000335   let winids = coc#float#get_float_win_list()
   26              0.000073   let except = get(a:, 1, 0)
   27              0.000039   for id in winids
    1              0.000001     if except && id == except
                                  continue
    1              0.000000     endif
    1              0.000002     if getwinvar(id, 'autohide', 0)
                                  call coc#float#close(id)
    1              0.000000     endif
   27              0.000032   endfor

FUNCTION  gitgutter#utility#shellescape()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:73
Called 247 times
Total time:   0.007584
 Self time:   0.006999

count  total (s)   self (s)
  247              0.005413   if a:arg =~ '^[A-Za-z0-9_/.-]\+$'
  204              0.000368     return a:arg
   43   0.001015   0.000430   elseif s:winshell()
                                return '"' . substitute(substitute(a:arg, '"', '""', 'g'), '%', '"%"', 'g') . '"'
   43              0.000036   else
   43              0.000227     return shellescape(a:arg)
                              endif

FUNCTION  <SNR>96_create()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/section.vim:17
Called 2 times
Total time:   0.000915
 Self time:   0.000728

count  total (s)   self (s)
    2              0.000005   let _ = ''
    4              0.000022   for idx in range(len(a:parts))
    2   0.000082   0.000058     let part = airline#parts#get(a:parts[idx])
    2              0.000006     let val = ''
    2              0.000009     let add_sep = get(l:, 'add_sep', 0)
                            
    2              0.000017     if exists('part.function')
    2              0.000008       let func = (part.function).'()'
                                elseif exists('part.text')
                                  let func = '"'.(part.text).'"'
                                else
                                  if a:append > 0 && idx != 0
                                    let val .= s:spc.g:airline_left_alt_sep.s:spc
                                  endif
                                  if a:append < 0 && idx != 0
                                    let t = ''
                                    if !add_sep
                                      let t = s:spc.g:airline_right_alt_sep.s:spc
                                    endif
                                    let val = t.val
                                  endif
                                  if exists('part.raw')
                                    let _ .= s:wrap_accent(part, val.(part.raw))
                                    continue
                                  else
                                    let _ .= s:wrap_accent(part, val.a:parts[idx])
                                    continue
                                  endif
    2              0.000002     endif
                            
    2              0.000012     let minwidth = get(part, 'minwidth', 0)
                            
    2              0.000008     if a:append > 0 && idx != 0
                                  let partval = printf('%%{airline#util#append(%s,%s)}', func, minwidth)
                                  " will add an extra separator, if minwidth is zero
                                  let add_sep = (minwidth == 0)
    2              0.000009     elseif a:append < 0 && idx != len(a:parts) - 1
                                  let partval = printf('%%{airline#util#prepend(%s,%s)}', func, minwidth)
                                  " will add an extra separator, if minwidth is zero
                                  let add_sep = (minwidth == 0)
    2              0.000002     else
    2              0.000021       let partval = printf('%%{airline#util#wrap(%s,%s)}', func, minwidth)
    2              0.000004       let add_sep = 0
    2              0.000002     endif
                            
    2              0.000008     if exists('part.condition')
                                  let partval = substitute(partval, '{', '\="{".(part.condition)." ? "', '')
                                  let partval = substitute(partval, '}', ' : ""}', '')
    2              0.000037     endif
                            
    2   0.000286   0.000122     let val .= s:wrap_accent(part, partval)
    2              0.000007     let _ .= val
    4              0.000021   endfor
    2              0.000004   return _

FUNCTION  <SNR>97_GetHiCmd()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim:140
Called 562 times
Total time:   0.048166
 Self time:   0.048166

count  total (s)   self (s)
                                " a:list needs to have 5 items!
  562              0.000676     let res = ''
  562              0.000512     let i = -1
 3372              0.002276     while i < 4
 2810              0.002561       let i += 1
 2810              0.006144       let item = get(a:list, i, '')
 2810              0.003112       if item is ''
  655              0.000339         continue
 2155              0.000838       endif
 2155              0.001366       if i == 0
  562              0.001470         let res .= ' guifg='.item
 1593              0.001011       elseif i == 1
  479              0.000827         let res .= ' guibg='.item
 1114              0.000601       elseif i == 2
  562              0.001225         let res .= ' ctermfg='.item
  552              0.000281       elseif i == 3
  479              0.000930         let res .= ' ctermbg='.item
   73              0.000042       elseif i == 4
   73              0.000353         let res .= printf(' gui=%s cterm=%s term=%s', item, item, item)
 2155              0.000879       endif
 2717              0.002419     endwhile
  562              0.000582     return res

FUNCTION  airline#util#ignore_buf()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim:136
Called 522 times
Total time:   0.024412
 Self time:   0.024412

count  total (s)   self (s)
  522              0.004760   let pat = '\c\v'. get(g:, 'airline#ignore_bufadd_pat', ''). get(g:, 'airline#extensions#tabline#ignore_bufadd_pat',  '!|defx|gundo|nerd_tree|startify|tagbar|term://|undotree|vimfiler')
  522              0.018882   return match(a:name, pat) > -1

FUNCTION  <SNR>169_is_closing_tag()
    Defined: ~/.vim/plugged/vim-jsx-pretty/autoload/jsx_pretty/indent.vim:57
Called 18 times
Total time:   0.000106
 Self time:   0.000106

count  total (s)   self (s)
   18              0.000097   return a:syntax =~? 'jsxClose'

FUNCTION  gitgutter#async#available()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/async.vim:11
Called 58 times
Total time:   0.000156
 Self time:   0.000156

count  total (s)   self (s)
   58              0.000095   return s:available

FUNCTION  <SNR>162_build_command()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/async.vim:43
Called 58 times
Total time:   0.000387
 Self time:   0.000387

count  total (s)   self (s)
   58              0.000179   if has('unix')
   58              0.000144     return ['sh', '-c', a:cmd]
                              endif
                            
                              if has('win32')
                                return has('nvim') ? ['cmd.exe', '/c', a:cmd] : 'cmd.exe /c '.a:cmd
                              endif
                            
                              throw 'unknown os'

FUNCTION  gitgutter#diff#parse_hunk()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:216
Called 126 times
Total time:   0.005508
 Self time:   0.005508

count  total (s)   self (s)
  126              0.003191   let matches = matchlist(a:line, s:hunk_re)
  126              0.000257   if len(matches) > 0
  126              0.000335     let from_line  = str2nr(matches[1])
  126              0.000371     let from_count = (matches[2] == '') ? 1 : str2nr(matches[2])
  126              0.000264     let to_line    = str2nr(matches[3])
  126              0.000368     let to_count   = (matches[4] == '') ? 1 : str2nr(matches[4])
  126              0.000440     return [from_line, from_count, to_line, to_count]
                              else
                                return []
                              end

FUNCTION  <SNR>8_LoadFTPlugin()
    Defined: /usr/local/Cellar/neovim/0.5.0/share/nvim/runtime/ftplugin.vim:14
Called 1 time
Total time:   0.011197
 Self time:   0.007622

count  total (s)   self (s)
    1              0.000003     if exists("b:undo_ftplugin")
    1              0.000064       exe b:undo_ftplugin
    1              0.000002       unlet! b:undo_ftplugin b:did_ftplugin
    1              0.000001     endif
                            
    1              0.000004     let s = expand("<amatch>")
    1              0.000001     if s != ""
    1              0.000007       if &cpo =~# "S" && exists("b:did_ftplugin")
                            	" In compatible mode options are reset to the global values, need to
                            	" set the local values also when a plugin was already used.
                            	unlet b:did_ftplugin
    1              0.000001       endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "aaa" and then "bbb".
    2              0.000008       for name in split(s, '\.')
    1   0.008291   0.004715         exe 'runtime! ftplugin/' . name . '.vim ftplugin/' . name . '_*.vim ftplugin/' . name . '/*.vim'
                                    " Load lua ftplugins
    1              0.002800         exe printf('runtime! ftplugin/%s.lua ftplugin/%s_*.lua ftplugin/%s/*.lua', name, name, name)
    2              0.000003       endfor
    1              0.000001     endif

FUNCTION  WebDevIconsGetFileTypeSymbol()
    Defined: ~/.vim/plugged/vim-devicons/plugin/webdevicons.vim:494
Called 1209 times
Total time:   0.278022
 Self time:   0.265883

count  total (s)   self (s)
 1209              0.002024   if a:0 == 0
                                let fileNodeExtension = &filetype
                                let fileNode = expand('%:t')
                                let isDirectory = 0
 1209              0.000926   else
 1209              0.006670     let fileNodeExtension = fnamemodify(a:1, ':e')
 1209              0.004673     let fileNode = fnamemodify(a:1, ':t')
 1209              0.001606     if a:0 > 1
  156              0.000358       let isDirectory = a:2
 1053              0.000641     else
 1053              0.001250       let isDirectory = 0
 1209              0.000707     endif
 1209              0.000600   endif
                            
 1209              0.002140   if isDirectory == 0 || g:DevIconsEnableFolderPatternMatching
                            
 1209              0.002404     let symbol = g:WebDevIconsUnicodeDecorateFileNodesDefaultSymbol
 1209              0.004075     let fileNodeExtension = tolower(fileNodeExtension)
 1209              0.003519     let fileNode = tolower(fileNode)
                            
12090              0.038063     for [pattern, glyph] in items(g:WebDevIconsUnicodeDecorateFileNodesPatternSymbols)
10881              0.093111       if match(fileNode, pattern) != -1
                                    let symbol = glyph
                                    break
10881              0.005236       endif
12090              0.007843     endfor
                            
 1209              0.003133     if symbol == g:WebDevIconsUnicodeDecorateFileNodesDefaultSymbol
 1209              0.004092       if has_key(g:WebDevIconsUnicodeDecorateFileNodesExactSymbols, fileNode)
   39              0.000161         let symbol = g:WebDevIconsUnicodeDecorateFileNodesExactSymbols[fileNode]
 1170              0.006376       elseif ((isDirectory == 1 && g:DevIconsEnableFolderExtensionPatternMatching) || isDirectory == 0) && has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, fileNodeExtension)
  975              0.002913         let symbol = g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[fileNodeExtension]
  195              0.000244       elseif isDirectory == 1
  117              0.000337         let symbol = g:WebDevIconsUnicodeDecorateFolderNodesDefaultSymbol
 1209              0.000798       endif
 1209              0.000629     endif
                            
                              else
                                let symbol = g:WebDevIconsUnicodeDecorateFolderNodesDefaultSymbol
 1209              0.000676   endif
                            
 1209   0.028491   0.016351   let artifactFix = s:DevIconsGetArtifactFix()
                            
 1209              0.002539   return symbol . artifactFix
                            

FUNCTION  airline#update_tabline()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline.vim:290
Called 301 times
Total time:  10.142156
 Self time:   0.005498

count  total (s)   self (s)
  301              0.001288   if get(g:, 'airline_statusline_ontop', 0)
  301  10.089418   9.497155     call airline#extensions#tabline#redraw()
  301              0.000164   endif

FUNCTION  airline#parts#get()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/parts.vim:49
Called 523 times
Total time:   0.002805
 Self time:   0.002805

count  total (s)   self (s)
  523              0.002543   return get(s:parts, a:key, {})

FUNCTION  <SNR>97_CheckDefined()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim:108
Called 15651 times
Total time:   0.367430
 Self time:   0.367430

count  total (s)   self (s)
                                " Checks, whether the definition of the colors is valid and is not empty or NONE
                                " e.g. if the colors would expand to this:
                                " hi airline_c ctermfg=NONE ctermbg=NONE
                                " that means to clear that highlighting group, therefore, fallback to Normal
                                " highlighting group for the cterm values
                            
                                " This only works, if the Normal highlighting group is actually defined, so
                                " return early, if it has been cleared
15651              0.059985     if !exists("g:airline#highlighter#normal_fg_hi")
                                  let g:airline#highlighter#normal_fg_hi = synIDattr(synIDtrans(hlID('Normal')), 'fg', 'cterm')
15651              0.007688     endif
15651              0.045772     if empty(g:airline#highlighter#normal_fg_hi) || g:airline#highlighter#normal_fg_hi < 0
                                  return a:colors
15651              0.006364     endif
                            
15651              0.034700     for val in a:colors
15651              0.039637       if !empty(val) && val !=# 'NONE'
15651              0.015344         return a:colors
                                  endif
                                endfor
                                " this adds the bold attribute to the term argument of the :hi command,
                                " but at least this makes sure, the group will be defined
                                let fg = g:airline#highlighter#normal_fg_hi
                                let bg = synIDattr(synIDtrans(hlID('Normal')), 'bg', 'cterm')
                                if empty(bg) || bg < 0
                                  " in case there is no background color defined for Normal
                                  let bg = a:colors[3]
                                endif
                                return a:colors[0:1] + [fg, bg] + [a:colors[4]]

FUNCTION  <SNR>5_guess()
    Defined: ~/.config/nvim/autoload/plugged/vim-polyglot/autoload/polyglot/init.vim:2796
Called 4 times
Total time:   0.007983
 Self time:   0.007065

count  total (s)   self (s)
    4              0.000010     let options = {}
    4              0.000005     let ccomment = 0
    4              0.000004     let podcomment = 0
    4              0.000004     let triplequote = 0
    4              0.000003     let backtick = 0
    4              0.000003     let xmlcomment = 0
    4              0.000004     let heredoc = ''
    4              0.000004     let minindent = 10
    4              0.000005     let spaces_minus_tabs = 0
    4              0.000004     let lineno = 0
    4              0.000006     let stack = [0]
    4              0.000016     let indents = { '2': 0, '3': 0, '4': 0, '6': 0, '8': 0 }
                            
  105              0.000105     for line in a:lines
  101              0.000092       let lineno += 1
                            
  101              0.000406       if line =~# '^\s*$'
    8              0.000004         continue
   93              0.000036       endif
                            
   93              0.000422       if line =~# '^\s*/\*'
    4              0.000004         let ccomment = 1
   93              0.000036       endif
   93              0.000094       if ccomment
   30              0.000064         if line =~# '\*/'
    4              0.000003           let ccomment = 0
   30              0.000011         endif
   30              0.000014         continue
   63              0.000022       endif
                            
   63              0.000135       if line =~# '^=\w'
                                    let podcomment = 1
   63              0.000023       endif
   63              0.000044       if podcomment
                                    if line =~# '^=\%(end\|cut\)\>'
                                      let podcomment = 0
                                    endif
                                    continue
   63              0.000022       endif
                            
   63              0.000042       if triplequote
                                    if line =~# '^[^"]*"""[^"]*$'
                                      let triplequote = 0
                                    endif
                                    continue
   63              0.000377       elseif line =~# '^[^"]*"""[^"]*$'
                                    let triplequote = 1
   63              0.000024       endif
                            
   63              0.000041       if backtick
                                    if line =~# '^[^`]*`[^`]*$'
                                      let backtick = 0
                                    endif
                                    continue
   63              0.000100       elseif &filetype ==# 'go' && line =~# '^[^`]*`[^`]*$'
                                    let backtick = 1
   63              0.000023       endif
                            
   63              0.000253       if line =~# '^\s*<\!--'
                                    let xmlcomment = 1
   63              0.000025       endif
   63              0.000043       if xmlcomment
                                    if line =~# '-->'
                                      let xmlcomment = 0
                                    endif
                                    continue
   63              0.000022       endif
                            
                                  " This is correct order because both "<<EOF" and "EOF" matches end
   63              0.000116       if heredoc != ''
                                    if line =~# heredoc
                                      let heredoc = ''
                                    endif
                                    continue
   63              0.000022       endif
   63              0.000366       let herematch = matchlist(line, '\C<<\W*\([A-Z]\+\)\s*$')
   63              0.000099       if len(herematch) > 0
                                    let heredoc = herematch[1] . '$'
   63              0.000026       endif
                            
   63              0.000094       if line[0] == "\t"
                                    let spaces_minus_tabs -= 1
   63              0.000027       else
   63              0.000097         if line[0] == " "
   43              0.000056           let spaces_minus_tabs += 1
   63              0.000027         endif
   63              0.000325         let indent = len(matchstr(line, '^ *'))
   84              0.000095         while stack[-1] > indent
   21              0.000036           call remove(stack, -1)
   84              0.000072         endwhile
                            
   63              0.000097         let indent_inc = indent - stack[-1]
                            
   63              0.000104         if indent_inc == 0 && len(stack) > 1
   22              0.000028           let indent_inc = indent - stack[-2]
   63              0.000030         endif
                            
   63              0.000120         if has_key(indents, indent_inc)
   43              0.000066           let indents[indent_inc] += 1
   43              0.000040           let prev_indent = indent
   63              0.000025         endif
                            
   63              0.000066         if stack[-1] != indent
   21              0.000038           call add(stack, indent)
   63              0.000026         endif
   63              0.000022       endif
   67              0.000080     endfor
                            
    4              0.000005     if spaces_minus_tabs < 0
                                  setlocal noexpandtab
                                  let &l:shiftwidth=&tabstop
                                  return 1
    4              0.000002     endif
                            
    4   0.000972   0.000053     let shiftwidth = s:get_shiftwidth(indents)
                            
    4              0.000005     if shiftwidth > 0
    4              0.000034       setlocal expandtab
    4              0.000028       let &l:shiftwidth=shiftwidth
    4              0.000003       try
                                    " Sunchronize tabstop with shiftwidth
    4              0.000012         let &l:softtabstop = -1
                                  catch /^Vim\%((\a\+)\)\=:E487/
                                    " -1 was not supported before Vim 7.4
                                    let &l:softtabstop = a:num_spaces
    4              0.000004       endtry
    4              0.000003       return 1
                                endif
                            
                                return 0

FUNCTION  airline#parts#paste()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/parts.vim:63
Called 522 times
Total time:   0.001842
 Self time:   0.001842

count  total (s)   self (s)
  522              0.001462   return g:airline_detect_paste && &paste ? g:airline_symbols.paste : ''

FUNCTION  coc#util#check_refresh()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/util.vim:62
Called 232 times
Total time:   0.008764
 Self time:   0.008764

count  total (s)   self (s)
  232              0.002789   if !bufloaded(a:bufnr)
                                return 0
  232              0.000514   endif
  232              0.001305   if getbufvar(a:bufnr, 'coc_diagnostic_disable', 0)
                                return 0
  232              0.000168   endif
  232              0.001021   if get(g: , 'EasyMotion_loaded', 0)
                                return EasyMotion#is_active() != 1
  232              0.000168   endif
  232              0.000343   return 1

FUNCTION  <SNR>51_buildGitStatusCommand()
    Defined: ~/.vim/plugged/nerdtree-git-plugin/nerdtree_plugin/git_status.vim:146
Called 44 times
Total time:   0.002517
 Self time:   0.000686

count  total (s)   self (s)
   44   0.002418   0.000587     return gitstatus#util#BuildGitStatusCommand(a:workdir, g:)

FUNCTION  209()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/flag_set.vim:20
Called 2923 times
Total time:   0.023295
 Self time:   0.023295

count  total (s)   self (s)
 2923              0.009423     if !has_key(self._flags, a:scope)
                                    let self._flags[a:scope] = []
 2923              0.001917     endif
 2923              0.005862     return self._flags[a:scope]

FUNCTION  airline#update_statusline()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline.vim:144
Called 117 times
Total time:   3.054927
 Self time:   0.011496

count  total (s)   self (s)
  117   0.006943   0.001384   if airline#util#stl_disabled(winnr())
                                return
  117              0.000066   endif
  117              0.001411   let range = filter(range(1, winnr('$')), 'v:val != winnr()')
                              " create inactive statusline
  116   1.503307   0.001413   call airline#update_statusline_inactive(range)
                            
  116              0.000333   unlet! w:airline_render_left w:airline_render_right
  116              0.001658   exe 'unlet! ' 'w:airline_section_'. join(s:sections, ' w:airline_section_')
                            
                              " Now create the active statusline
  116              0.000237   let w:airline_active = 1
  116              0.000786   let context = { 'winnr': winnr(), 'active': 1, 'bufnr': winbufnr(winnr()) }
  116   1.539800   0.003676   call s:invoke_funcrefs(context, g:airline_statusline_funcrefs)

FUNCTION  gitgutter#sign#update_signs()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/sign.vim:57
Called 42 times
Total time:   0.016708
 Self time:   0.012494

count  total (s)   self (s)
   42              0.000166   if exists('*sign_unplace')
                                " Vim is (hopefully) now quick enough to remove all signs then place new ones.
   42              0.001521     call sign_unplace('gitgutter', {'buffer': a:bufnr})
                            
   42   0.001167   0.000599     let modified_lines = s:handle_double_hunk(a:modified_lines)
   42   0.012285   0.008640     let signs = map(copy(modified_lines), '{'. '"buffer":   a:bufnr,'. '"group":    "gitgutter",'. '"name":     s:highlight_name_for_change(v:val[1]),'. '"lnum":     v:val[0],'. '"priority": g:gitgutter_sign_priority'. '}')
                            
   42              0.000115     if exists('*sign_placelist')
   42              0.001202       call sign_placelist(signs)
   42              0.000034       return
                                endif
                            
                                for sign in signs
                                  call sign_place(0, sign.group, sign.name, sign.buffer, {'lnum': sign.lnum, 'priority': sign.priority})
                                endfor
                                return
                              endif
                            
                            
                              " Derive a delta between the current signs and the ones we want.
                              " Remove signs from lines that no longer need a sign.
                              " Upsert the remaining signs.
                            
                              call s:find_current_signs(a:bufnr)
                            
                              let new_gitgutter_signs_line_numbers = map(copy(a:modified_lines), 'v:val[0]')
                              let obsolete_signs = s:obsolete_gitgutter_signs_to_remove(a:bufnr, new_gitgutter_signs_line_numbers)
                            
                              call s:remove_signs(a:bufnr, obsolete_signs, s:remove_all_old_signs)
                              call s:upsert_new_gitgutter_signs(a:bufnr, a:modified_lines)

FUNCTION  airline#update_statusline_focuslost()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline.vim:163
Called 7 times
Total time:   0.000146
 Self time:   0.000146

count  total (s)   self (s)
    7              0.000032   if get(g:, 'airline_focuslost_inactive', 0)
                                let bufnr=bufnr('%')
                                call airline#highlighter#highlight_modified_inactive(bufnr)
                                call airline#highlighter#highlight(['inactive'], bufnr)
                                call airline#update_statusline_inactive(range(1, winnr('$')))
    7              0.000004   endif

FUNCTION  <SNR>120_isEOF()
    Defined: ~/.vim/plugged/nerdtree-git-plugin/autoload/gitstatus/job.vim:128
Called 45 times
Total time:   0.000409
 Self time:   0.000409

count  total (s)   self (s)
   45              0.000314     return len(a:data) == 1 && a:data[0] is# ''

FUNCTION  gitstatus#util#BuildGitStatusCommand()
    Defined: ~/.vim/plugged/nerdtree-git-plugin/autoload/gitstatus/util.vim:59
Called 44 times
Total time:   0.001831
 Self time:   0.001831

count  total (s)   self (s)
   44              0.000627     let l:cmd = [ get(a:opts, 'NERDTreeGitStatusGitBinPath', 'git'), '-C', a:root, 'status', '--porcelain' . (get(a:opts, 'NERDTreeGitStatusPorcelainVersion', 2) ==# 2 ? '=v2' : ''), '-z' ]
   44              0.000120     if has_key(a:opts, 'NERDTreeGitStatusUntrackedFilesMode')
   44              0.000259         let l:cmd += ['--untracked-files=' . a:opts['NERDTreeGitStatusUntrackedFilesMode']]
   44              0.000027     endif
                            
   44              0.000125     if get(a:opts, 'NERDTreeGitStatusShowIgnored', 0)
                                    let l:cmd += ['--ignored=traditional']
   44              0.000021     endif
                            
   44              0.000093     if has_key(a:opts, 'NERDTreeGitStatusIgnoreSubmodules')
                                    let l:cmd += ['--ignore-submodules=' . a:opts['NERDTreeGitStatusIgnoreSubmodules']]
   44              0.000018     endif
                            
   44              0.000105     if has_key(a:opts, 'NERDTreeGitStatusCwdOnly')
   44              0.000091         let l:cmd += ['.']
   44              0.000019     endif
                            
   44              0.000041     return l:cmd

FUNCTION  airline#parts#readonly()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/parts.vim:89
Called 524 times
Total time:   0.038575
 Self time:   0.014164

count  total (s)   self (s)
                              " only consider regular buffers (e.g. ones that represent actual files,
                              " but not special ones like e.g. NERDTree)
  524   0.032632   0.008220   if !empty(&buftype) || airline#util#ignore_buf(bufname('%'))
    2              0.000002     return ''
  522              0.000317   endif
  522              0.001737   if &readonly && !filereadable(bufname('%'))
                                return '[noperm]'
  522              0.000374   else
  522              0.000993     return &readonly ? g:airline_symbols.readonly : ''
                              endif

FUNCTION  airline#extensions#tabline#redraw()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tabline.vim:149
Called 301 times
Total time:  10.136270
 Self time:  10.136270

count  total (s)   self (s)
                                " sometimes, the tabline is not correctly updated see #1580
                                " so force redraw here
  301              0.001148     if exists(":redrawtabline") == 2
  301             10.082473       redrawtabline
                                else
                                " Have to set a property equal to itself to get airline to re-eval.
                                " Setting `let &tabline=&tabline` destroys the cursor position so we
                                " need something less invasive.
                                  let &ro = &ro
  301              0.000161     endif

FUNCTION  <SNR>46_findAndRevealPath()
    Defined: ~/.vim/plugged/nerdtree/autoload/nerdtree/ui_glue.vim:296
Called 1 time
Total time:   0.030450
 Self time:   0.000483

count  total (s)   self (s)
    1              0.000163     let l:pathStr = !empty(a:pathStr) ? a:pathStr : expand('%:p')
    1              0.000005     let l:revealOpts = {}
                            
    1              0.000005     if empty(l:pathStr)
                                    call nerdtree#echoWarning('no file for the current buffer')
                                    return
    1              0.000001     endif
                            
    1              0.000039     if !filereadable(l:pathStr)
                                    let l:pathStr = fnamemodify(l:pathStr, ':h')
                                    let l:revealOpts['open'] = 1
    1              0.000001     endif
                            
    1              0.000002     try
    1   0.000134   0.000026         let l:pathStr = g:NERDTreePath.Resolve(l:pathStr)
    1   0.000816   0.000012         let l:pathObj = g:NERDTreePath.New(l:pathStr)
                                catch /^NERDTree.InvalidArgumentsError/
                                    call nerdtree#echoWarning('invalid path')
                                    return
    1              0.000002     endtry
                            
    1   0.000183   0.000013     if !g:NERDTree.ExistsForTab()
                                    try
                                        let l:cwd = g:NERDTreePath.New(getcwd())
                                    catch /^NERDTree.InvalidArgumentsError/
                                        call nerdtree#echo('current directory does not exist.')
                                        let l:cwd = l:pathObj.getParent()
                                    endtry
                            
                                    if l:pathObj.isUnder(l:cwd)
                                        call g:NERDTreeCreator.CreateTabTree(l:cwd.str())
                                    else
                                        call g:NERDTreeCreator.CreateTabTree(l:pathObj.getParent().str())
                                    endif
    1              0.000001     else
    1   0.000710   0.000020         NERDTreeFocus
                            
    1   0.000152   0.000015         if !l:pathObj.isUnder(b:NERDTree.root.path)
                                        call s:chRoot(g:NERDTreeDirNode.New(l:pathObj.getParent(), b:NERDTree))
    1              0.000001         endif
    1              0.000001     endif
                            
    1   0.000187   0.000012     if l:pathObj.isHiddenUnder(b:NERDTree.root.path)
                                    call b:NERDTree.ui.setShowHidden(1)
    1              0.000001     endif
                            
    1   0.011179   0.000053     let l:node = b:NERDTree.root.reveal(l:pathObj, l:revealOpts)
    1   0.015556   0.000020     call b:NERDTree.render()
    1   0.001240   0.000019     call l:node.putCursorHere(1, 0)

FUNCTION  285()
    Defined: ~/.vim/plugged/nerdtree-git-plugin/autoload/gitstatus/listener.vim:105
Called 1408 times
Total time:   0.006382
 Self time:   0.006382

count  total (s)   self (s)
 1408              0.005721     return get(self.opts, 'NERDTreeGitStatus' . a:name, a:default)

FUNCTION  nerdtree#has_opt()
    Defined: ~/.vim/plugged/nerdtree/autoload/nerdtree.vim:170
Called 3045 times
Total time:   0.014225
 Self time:   0.014225

count  total (s)   self (s)
 3045              0.012672     return has_key(a:options, a:name) && a:options[a:name] ==# 1

FUNCTION  <SNR>107_search_term()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/searchcount.vim:20
Called 33 times
Total time:   0.001955
 Self time:   0.000453

count  total (s)   self (s)
                              " shorten for all width smaller than 300 (this is just a guess)
                              " this uses a non-breaking space, because it looks like
                              " a leading space is stripped :/
   33   0.001883   0.000382   return "\ua0" .  '/' . airline#util#shorten(getreg('/'), 300, 8)

FUNCTION  airline#builder#should_change_group()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/builder.vim:130
Called 1218 times
Total time:   0.616876
 Self time:   0.044552

count  total (s)   self (s)
 1218              0.002919   if a:group1 == a:group2
                                return 0
 1218              0.000634   endif
 1218   0.318080   0.017879   let color1 = airline#highlighter#get_highlight(a:group1)
 1218   0.287792   0.015669   let color2 = airline#highlighter#get_highlight(a:group2)
 1218              0.004516   return color1[1] != color2[1] || color1[0] != color2[0] ||  color1[2] != color2[2] || color1[3] != color2[3]

FUNCTION  227()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/nerdtree.vim:171
Called 41 times
Total time:   0.008100
 Self time:   0.000662

count  total (s)   self (s)
   41   0.007832   0.000394     if !s:NERDTree.IsOpen()
                                    throw 'NERDTree.TreeNotOpen'
   41              0.000047     endif

FUNCTION  <SNR>59_DevIconsGetArtifactFix()
    Defined: ~/.vim/plugged/vim-devicons/plugin/webdevicons.vim:545
Called 2418 times
Total time:   0.024637
 Self time:   0.024637

count  total (s)   self (s)
 2418              0.004581   if g:DevIconsAppendArtifactFix == 1
                                let artifactFix = g:DevIconsArtifactFixChar
 2418              0.002195   else
 2418              0.004235     let artifactFix = ''
 2418              0.001786   endif
                            
 2418              0.003460   return artifactFix

FUNCTION  IsNERDTreeOpen()
    Defined: ~/.config/nvim/vim-plug/benawad.vim:95
Called 1 time
Total time:   0.000202
 Self time:   0.000202

count  total (s)   self (s)
    1              0.000200   return exists("t:NERDTreeBufName") && (bufwinnr(t:NERDTreeBufName) != -1)

FUNCTION  gitgutter#utility#setbufvar()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:9
Called 412 times
Total time:   0.007232
 Self time:   0.007232

count  total (s)   self (s)
  412              0.000718   let buffer = +a:buffer
                              " Default value for getbufvar() was introduced in Vim 7.3.831.
  412              0.001295   let ggvars = getbufvar(buffer, 'gitgutter')
  412              0.001013   if type(ggvars) == type('')
                                unlet ggvars
                                let ggvars = {}
                                call setbufvar(buffer, 'gitgutter', ggvars)
  412              0.000214   endif
  412              0.001822   let ggvars[a:varname] = a:val

FUNCTION  36()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/path.vim:648
Called 1209 times
Total time:   1.199605
 Self time:   0.021872

count  total (s)   self (s)
 1209   1.109132   0.014225     call g:NERDTreePathNotifier.NotifyListeners('refreshFlags', self, a:nerdtree, {})
 1209   0.089622   0.006795     call self.cacheDisplayString()

FUNCTION  coc#highlight#add_highlights()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/highlight.vim:256
Called 26 times
Total time:   0.393036
 Self time:   0.001673

count  total (s)   self (s)
                              " clear highlights
   26   0.012525   0.000261   call coc#compat#execute(a:winid, 'syntax clear')
   26              0.000128   let bufnr = winbufnr(a:winid)
   26   0.001218   0.000346   call coc#highlight#clear_highlight(bufnr, -1, 0, -1)
   26              0.000046   if !empty(a:codes)
   26   0.378566   0.000339     call coc#highlight#highlight_lines(a:winid, a:codes)
   26              0.000015   endif
   26              0.000084   if !empty(a:highlights)
                                for item in a:highlights
                                  call coc#highlight#add_highlight(bufnr, -1, item['hlGroup'], item['lnum'], item['colStart'], item['colEnd'])
                                endfor
   26              0.000012   endif

FUNCTION  39()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/path.vim:735
Called 42 times
Total time:   0.000685
 Self time:   0.000685

count  total (s)   self (s)
   42              0.000395     let toReturn = '/' . join(self.pathSegments, '/')
   42              0.000093     if self.isDirectory && toReturn !=# '/'
   41              0.000087         let toReturn  = toReturn . '/'
   42              0.000019     endif
   42              0.000040     return toReturn

FUNCTION  nerdtree#exec()
    Defined: ~/.vim/plugged/nerdtree/autoload/nerdtree.vim:157
Called 42 times
Total time:   0.007270
 Self time:   0.007264

count  total (s)   self (s)
   42              0.000246     let old_ei = &eventignore
   42              0.000077     if a:ignoreAll
   41              0.000518         set eventignore=all
   42              0.000070     endif
   42              0.000056     try
   42              0.005474         exec a:cmd
   42              0.000125     finally
   42   0.000392   0.000385         let &eventignore = old_ei
   42              0.000078     endtry

FUNCTION  <SNR>97_get_array()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim:60
Called 47279 times
Total time:   0.263594
 Self time:   0.263594

count  total (s)   self (s)
47279              0.242662     return [ a:guifg, a:guibg, a:ctermfg, a:ctermbg, empty(a:opts) ? '' : join(a:opts, ',') ]

FUNCTION  airline#extensions#append_to_section()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions.vim:53
Called 116 times
Total time:   0.003788
 Self time:   0.002282

count  total (s)   self (s)
  116   0.003189   0.001683   call <sid>check_defined_section(a:name)
  116              0.000490   let w:airline_section_{a:name} .= a:value

FUNCTION  292()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/builder.vim:8
Called 381 times
Total time:   0.001823
 Self time:   0.001823

count  total (s)   self (s)
  381              0.001461   call add(self._sections, ['|', a:0 ? a:1 : '%='])

FUNCTION  <SNR>162_on_stderr_nvim()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/async.vim:66
Called 72 times
Total time:   0.001593
 Self time:   0.001112

count  total (s)   self (s)
   72              0.000528   if a:data != ['']  " With Neovim there is always [''] reported on stderr.
   15   0.000646   0.000164     call self.handler.err(self.buffer)
   72              0.000048   endif

FUNCTION  <SNR>110_get_accented_line()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/builder.vim:163
Called 1865 times
Total time:   0.106477
 Self time:   0.106477

count  total (s)   self (s)
 1865              0.003223   if a:self._context.active
                                " active window
  918              0.001565     let contents = []
  918              0.009481     let content_parts = split(a:contents, '__accent')
 2748              0.003977     for cpart in content_parts
 1830              0.013416       let accent = matchstr(cpart, '_\zs[^#]*\ze')
 1830              0.004769       call add(contents, cpart)
 2748              0.002624     endfor
  918              0.004803     let line = join(contents, a:group)
  918              0.007188     let line = substitute(line, '__restore__', a:group, 'g')
  947              0.000535   else
                                " inactive window
  947              0.017945     let line = substitute(a:contents, '%#__accent[^#]*#', '', 'g')
  947              0.007580     let line = substitute(line, '%#__restore__#', '', 'g')
 1865              0.001031   endif
 1865              0.001805   return line

FUNCTION  <SNR>102_check_mixed_indent_file()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/whitespace.vim:34
Called 11 times
Total time:   0.000704
 Self time:   0.000704

count  total (s)   self (s)
   11              0.000137   let c_like_langs = get(g:, 'airline#extensions#c_like_langs', [ 'arduino', 'c', 'cpp', 'cuda', 'go', 'javascript', 'ld', 'php' ])
   11              0.000051   if index(c_like_langs, &ft) > -1
                                " for C-like languages: allow /** */ comment style with one space before the '*'
   11              0.000015     let head_spc = '\v(^ +\*@!)'
                              else
                                let head_spc = '\v(^ +)'
   11              0.000006   endif
   11              0.000130   let indent_tabs = search('\v(^\t+)', 'nw')
   11              0.000247   let indent_spc  = search(head_spc, 'nw')
   11              0.000015   if indent_tabs > 0 && indent_spc > 0
                                return printf("%d:%d", indent_tabs, indent_spc)
   11              0.000006   else
   11              0.000007     return ''
                              endif

FUNCTION  coc#float#close_related()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/float.vim:789
Called 53 times
Total time:   0.020281
 Self time:   0.014273

count  total (s)   self (s)
   53              0.000346   let timer = getwinvar(a:winid, 'timer', 0)
   53              0.000065   if timer
                                call timer_stop(timer)
   53              0.000041   endif
   53              0.000191   let kind = get(a:, 1, '')
   53   0.007093   0.001084   let winids = filter(coc#float#get_float_win_list(1), 'getwinvar(v:val, "target_winid", 0) == '.a:winid)
   79              0.000132   for id in winids
   26              0.000032     if s:is_vim
                                  " vim doesn't throw
                                  call popup_close(id)
   26              0.000078     elseif nvim_win_is_valid(id)
   26              0.000080       if empty(kind) || getwinvar(id, 'kind', '') ==# kind
   26              0.010842         noa call nvim_win_close(id, 1)
   26              0.000057       endif
   26              0.000010     endif
   79              0.000117   endfor

FUNCTION  coc#helper#min()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/helper.vim:84
Called 78 times
Total time:   0.001371
 Self time:   0.001371

count  total (s)   self (s)
   78              0.000102   let val = a:first
  156              0.000442   for i in range(0, len(a:000) - 1)
   78              0.000134     if a:000[i] < val
   74              0.000132       let val = a:000[i]
   78              0.000040     endif
  156              0.000143   endfor
   78              0.000070   return val

FUNCTION  airline#highlighter#exec()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim:219
Called 15651 times
Total time:   4.628345
 Self time:   1.431355

count  total (s)   self (s)
15651              0.024585     if pumvisible()
                                  return
15651              0.006100     endif
15651              0.022071     let colors = a:colors
15651              0.034596     if len(colors) == 4
14599              0.036828       call add(colors, '')
15651              0.008222     endif
                                " colors should always be string values
15651              0.274864     let colors = map(copy(colors), 'type(v:val) != type("") ? string(v:val) : v:val')
15651              0.015961     if s:is_win32term
                                  let colors[2] = s:gui2cui(get(colors, 0, ''), get(colors, 2, ''))
                                  let colors[3] = s:gui2cui(get(colors, 1, ''), get(colors, 3, ''))
15651              0.007284     endif
15651   2.737368   0.179086     let old_hi = airline#highlighter#get_highlight(a:group)
15651              0.095718     let new_hi = [colors[0], colors[1], printf('%s', colors[2]), printf('%s', colors[3]), colors[4]]
15651   0.495421   0.127991     let colors = s:CheckDefined(colors)
15651   0.361110   0.137998     if old_hi != new_hi || !s:hl_group_exists(a:group)
  562   0.053719   0.005552       let cmd = printf('hi %s%s', a:group, s:GetHiCmd(colors))
  562              0.000442       try
  562              0.011267         exe cmd
                                  catch /^Vim\%((\a\+)\)\=:E421:/ " color definition not found
                                    let group=matchstr(v:exception, '\w\+\ze=')
                                    let color=matchstr(v:exception, '=\zs\w\+')
                                    let cmd=substitute(cmd, color, 'grey', 'g')
                                    exe cmd
                                    call airline#util#warning('color definition for group ' . a:group . ' not found, using grey as fallback')
                                  catch
                                    call airline#util#warning('Error when running command: '. cmd)
  562              0.000460       endtry
  562              0.001565       if has_key(s:hl_groups, a:group)
  562              0.001171         let s:hl_groups[a:group] = colors
  562              0.000274       endif
15651              0.004866     endif

FUNCTION  gitgutter#utility#repo_path()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:112
Called 217 times
Total time:   0.008429
 Self time:   0.004130

count  total (s)   self (s)
  217   0.006085   0.002919   let p = gitgutter#utility#getbufvar(a:bufnr, 'path', '')
  217   0.002173   0.001040   return a:shellesc ? gitgutter#utility#shellescape(p) : p

FUNCTION  nerdtree#renderView()
    Defined: ~/.vim/plugged/nerdtree/autoload/nerdtree.vim:245
Called 39 times
Total time:   0.509267
 Self time:   0.000490

count  total (s)   self (s)
   39   0.509141   0.000364     call b:NERDTree.render()

FUNCTION  <SNR>120_newJob()
    Defined: ~/.vim/plugged/nerdtree-git-plugin/autoload/gitstatus/job.vim:30
Called 45 times
Total time:   0.001255
 Self time:   0.001255

count  total (s)   self (s)
   45              0.001190     return extend(deepcopy(s:Job), { 'name': a:name, 'opts': a:opts })

FUNCTION  <SNR>169_jsx_indent_element()
    Defined: ~/.vim/plugged/vim-jsx-pretty/autoload/jsx_pretty/indent.vim:122
Called 14 times
Total time:   0.015362
 Self time:   0.003273

count  total (s)   self (s)
   14   0.001649   0.000267   let syntax_stack = s:syntax_stack_at(a:lnum, s:start_col(a:lnum))
   14              0.000073   let syntax_name = syntax_stack[-1]
   14              0.000054   let element_count = count(syntax_stack, 'jsxElement')
                            
   14   0.000392   0.000163   if s:trim(getline(a:lnum)) =~ '^>'
                                return s:jsx_indent_trail_punct(a:lnum)
   14              0.000011   endif
                            
                              " If current tag is closing tag
   14   0.000180   0.000105   if s:is_closing_tag(syntax_name)
                                return s:jsx_indent_closing_tag(a:lnum)
   14              0.000007   endif
                            
                              " Normalize the jsxElement count for opening tag
   14   0.000199   0.000134   if s:is_opening_tag(syntax_name)
                                " <div>
                                "   <div></div> <-- jsxRegion->jsxElement->jsxElement->jsxTag->jsxOpenTag->jsxOpenPunct
                                " </div>
   10   0.000198   0.000131     if s:is_jsx_element(syntax_stack[-4]) && s:is_jsx_element(syntax_stack[-5])
   10              0.000018       let element_count = element_count - 1
   10              0.000005     endif
   14              0.000007   endif
                            
   14              0.000063   let start_time = localtime()
   14              0.000362   let pos = searchpos(s:start_tag, 'bW')
                            
   38   0.010856   0.000656   while !s:is_parent_element(pos, element_count)
   24              0.000089     if localtime() - start_time >= 0.5
                                  return -1
   24              0.000015     endif
   24              0.000414     let pos = searchpos(s:start_tag, 'bW')
   38              0.000049   endwhile
                            
   14   0.000342   0.000271   return indent(pos[0]) + s:sw()

FUNCTION  airline#extensions#searchcount#apply()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/searchcount.vim:15
Called 116 times
Total time:   0.005416
 Self time:   0.001629

count  total (s)   self (s)
  116   0.005296   0.001508   call airline#extensions#append_to_section('y', '%{v:hlsearch ? airline#extensions#searchcount#status() : ""}')

FUNCTION  airline#highlighter#add_accent()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim:180
Called 2 times
Total time:   0.000040
 Self time:   0.000040

count  total (s)   self (s)
    2              0.000034     let s:accents[a:accent] = 1

FUNCTION  gitgutter#utility#windows()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:236
Called 58 times
Total time:   0.000530
 Self time:   0.000530

count  total (s)   self (s)
   58              0.000486   return has('win64') || has('win32') || has('win16')

FUNCTION  airline#parts#spell()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/parts.vim:67
Called 522 times
Total time:   0.015646
 Self time:   0.015646

count  total (s)   self (s)
  522              0.007853   let spelllang = g:airline_detect_spelllang ? printf(" [%s]", toupper(substitute(&spelllang, ',', '/', 'g'))) : ''
  522              0.001088   if g:airline_detect_spell && &spell
                                let winwidth = airline#util#winwidth()
                                if winwidth >= 90
                                  return g:airline_symbols.spell . spelllang
                                elseif winwidth >= 70
                                  return g:airline_symbols.spell
                                else
                                  return split(g:airline_symbols.spell, '\zs')[0]
                                endif
  522              0.000208   endif
  522              0.000392   return ''

FUNCTION  gitgutter#hunk#summary()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/hunk.vim:20
Called 723 times
Total time:   0.024197
 Self time:   0.012497

count  total (s)   self (s)
  723   0.023680   0.011981   return gitgutter#utility#getbufvar(a:bufnr, 'summary', [0,0,0])

FUNCTION  <SNR>96_wrap_accent()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/section.vim:9
Called 2 times
Total time:   0.000163
 Self time:   0.000123

count  total (s)   self (s)
    2              0.000022   if exists('a:part.accent')
    2   0.000114   0.000074     call airline#highlighter#add_accent(a:part.accent)
    2              0.000020     return '%#__accent_'.(a:part.accent).'#'.a:value.'%#__restore__#'
                              endif
                              return a:value

FUNCTION  <SNR>97_exec_separator()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim:189
Called 14596 times
Total time:  11.660243
 Self time:   0.756705

count  total (s)   self (s)
14596              0.022739     if pumvisible()
                                  return
14596              0.005920     endif
14596              0.053591     let group = a:from.'_to_'.a:to.a:suffix
14596   3.803926   0.151357     let l:from = airline#themes#get_highlight(a:from.a:suffix)
14596   3.155501   0.138444     let l:to = airline#themes#get_highlight(a:to.a:suffix)
14596              0.012243     if a:inverse
  658              0.002559       let colors = [ l:from[1], l:to[1], l:from[3], l:to[3] ]
13938              0.006138     else
13938              0.046423       let colors = [ l:to[1], l:from[1], l:to[3], l:from[3] ]
14596              0.005950     endif
14596              0.077450     let a:dict[group] = colors
14596   4.403274   0.169362     call airline#highlighter#exec(group, colors)

FUNCTION  coc#float#content_height()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/float.vim:765
Called 26 times
Total time:   0.001548
 Self time:   0.001548

count  total (s)   self (s)
   26              0.000095   if !bufloaded(a:bufnr)
                                return 0
   26              0.000027   endif
   26              0.000033   if !a:wrap
                                return has('nvim') ? nvim_buf_line_count(a:bufnr) : len(getbufline(a:bufnr, 1, '$'))
   26              0.000011   endif
   26              0.000229   let lines = has('nvim') ? nvim_buf_get_lines(a:bufnr, 0, -1, 0) : getbufline(a:bufnr, 1, '$')
   26              0.000024   let total = 0
   62              0.000090   for line in lines
   36              0.000167     let dw = max([1, strdisplaywidth(line)])
   36              0.000304     let total += float2nr(ceil(str2float(string(dw))/a:width))
   62              0.000082   endfor
   26              0.000026   return total

FUNCTION  <SNR>110_get_transitioned_seperator()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/builder.vim:140
Called 1484 times
Total time:   1.489808
 Self time:   0.066997

count  total (s)   self (s)
 1484              0.002502   let line = ''
 1484              0.007242   if get(a:self._context, 'tabline', 0) && get(g:, 'airline#extensions#tabline#alt_sep', 0) && a:group ==# 'airline_tabsel' && a:side
                                call airline#highlighter#add_separator(a:prev_group, a:group, 0)
                                let line .= '%#'.a:prev_group.'_to_'.a:group.'#'
                                let line .=  a:self._context.right_sep.'%#'.a:group.'#'
 1484              0.001036   else
 1484   1.444316   0.021505     call airline#highlighter#add_separator(a:prev_group, a:group, a:side)
 1484              0.008659     let line .= '%#'.a:prev_group.'_to_'.a:group.'#'
 1484              0.006231     let line .= a:side ? a:self._context.left_sep : a:self._context.right_sep
 1484              0.003711     let line .= '%#'.a:group.'#'
 1484              0.000845   endif
 1484              0.001544   return line

FUNCTION  <SNR>74_VimNavigate()
    Defined: ~/.vim/plugged/vim-tmux-navigator/plugin/tmux_navigator.vim:10
Called 2 times
Total time:   0.081813
 Self time:   0.000388

count  total (s)   self (s)
    2              0.000008   try
    2   0.081788   0.000363     execute 'wincmd ' . a:direction
                              catch
                                echohl ErrorMsg | echo 'E11: Invalid in command-line window; <CR> executes, CTRL-C quits: wincmd k' | echohl None
    2              0.000002   endtry

FUNCTION  207()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/flag_set.vim:7
Called 1714 times
Total time:   0.039463
 Self time:   0.025511

count  total (s)   self (s)
 1714   0.025887   0.011934     let flags = self._flagsForScope(a:scope)
 1714              0.005283     if index(flags, a:flag) == -1
 1714              0.005334         call add(flags, a:flag)
 1714              0.001102     end

FUNCTION  208()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/flag_set.vim:15
Called 2418 times
Total time:   0.013800
 Self time:   0.013800

count  total (s)   self (s)
 2418              0.012580     let self._flags[a:scope] = []

FUNCTION  <SNR>166_write_buffer()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:375
Called 43 times
Total time:   0.027301
 Self time:   0.027301

count  total (s)   self (s)
   43              0.000535   let bufcontents = getbufline(a:bufnr, 1, '$')
                            
   43              0.000191   if bufcontents == [''] && line2byte(1) == -1
                                " Special case: completely empty buffer.
                                " A nearly empty buffer of only a newline has line2byte(1) == 1.
                                call writefile([], a:file)
                                return
   43              0.000027   endif
                            
   43              0.000236   if getbufvar(a:bufnr, '&fileformat') ==# 'dos'
                                call map(bufcontents, 'v:val."\r"')
   43              0.000025   endif
                            
   43              0.000126   if getbufvar(a:bufnr, '&endofline')
   43              0.000138     call add(bufcontents, '')
   43              0.000026   endif
                            
   43              0.000158   let fenc = getbufvar(a:bufnr, '&fileencoding')
   43              0.000099   if fenc !=# &encoding
                                call map(bufcontents, 'iconv(v:val, &encoding, "'.fenc.'")')
   43              0.000024   endif
                            
   43              0.000117   if getbufvar(a:bufnr, '&bomb')
                                let bufcontents[0]='﻿'.bufcontents[0]
   43              0.000022   endif
                            
                              " The file we are writing to is a temporary file.  Sometimes the parent
                              " directory is deleted outside Vim but, because Vim caches the directory
                              " name at startup and does not check for its existence subsequently, Vim
                              " does not realise.  This causes E482 errors.
   43              0.000036   try
   43              0.023948     call writefile(bufcontents, a:file, 'b')
                              catch /E482/
                                call mkdir(fnamemodify(a:file, ':h'), '', '0700')
                                call writefile(bufcontents, a:file, 'b')
   43              0.000080   endtry

FUNCTION  coc#float#nvim_right_pad()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/float.vim:279
Called 26 times
Total time:   0.016354
 Self time:   0.005656

count  total (s)   self (s)
   26   0.000836   0.000465   let winid = coc#float#get_related(a:winid, 'pad')
   26              0.000038   let bufnr = 0
   26              0.000276   let config = { 'relative': a:config['relative'], 'width': 1, 'height': a:config['height'], 'row': a:config['row'], 'col': a:config['col'] + a:config['width'], 'focusable': v:false, 'style': 'minimal', }
   26              0.000053   if winid && nvim_win_is_valid(winid)
                                let bufnr = nvim_win_get_buf(winid)
                                noa call nvim_win_close(winid, 1)
   26              0.000012   endif
   26   0.010678   0.000350   let bufnr = coc#float#create_buf(bufnr, repeat([''], a:config['height']))
   26              0.001162   noa let winid = nvim_open_win(bufnr, 0, config)
   26              0.000023   if winid
                                " minimal not work
   26              0.000080     if !has('nvim-0.4.3')
                                  call setwinvar(winid, '&colorcolumn', 0)
                                  call setwinvar(winid, '&number', 0)
                                  call setwinvar(winid, '&relativenumber', 0)
                                  call setwinvar(winid, '&foldcolumn', 0)
                                  call setwinvar(winid, '&signcolumn', 0)
   26              0.000014     endif
   26              0.002450     call setwinvar(winid, '&winhl', 'Normal:'.a:hlgroup.',NormalNC:'.a:hlgroup)
   26              0.000112     call setwinvar(winid, 'target_winid', a:winid)
   26              0.000062     call setwinvar(winid, 'kind', 'pad')
   26              0.000062     call add(a:related, winid)
   26              0.000015   endif

FUNCTION  <SNR>169_is_jsx_expression()
    Defined: ~/.vim/plugged/vim-jsx-pretty/autoload/jsx_pretty/indent.vim:72
Called 44 times
Total time:   0.000289
 Self time:   0.000289

count  total (s)   self (s)
   44              0.000260   return a:syntax =~? 'jsxExpressionBlock'

FUNCTION  <SNR>29_request()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/client.vim:156
Called 76 times
Total time:   0.703323
 Self time:   0.132416

count  total (s)   self (s)
   76   0.001677   0.001001   let channel = coc#client#get_channel(self)
   76              0.000243   if empty(channel) | return '' | endif
   76              0.000084   try
   76              0.000074     if s:is_vim
                                  let res = ch_evalexpr(channel, [a:method, a:args], {'timeout': 60 * 1000})
                                  if type(res) == 1 && res ==# ''
                                    throw 'request '.a:method. ' '.string(a:args).' timeout after 60s'
                                  endif
                                  let [l:errmsg, res] =  res
                                  if !empty(l:errmsg)
                                    throw l:errmsg
                                  else
                                    return res
                                  endif
   76              0.000043     else
   76   0.697078   0.126848       return call('rpcrequest', [channel, a:method] + a:args)
                                endif
                              catch /.*/
                                if v:exception =~# 'E475'
                                  if get(g:, 'coc_vim_leaving', 0) | return | endif
                                  echohl Error | echom '['.self.name.'] server connection lost' | echohl None
                                  let name = self.name
                                  call s:on_exit(name, 0)
                                  execute 'silent do User ConnectionLost'.toupper(name[0]).name[1:]
                                elseif v:exception =~# 'E12'
                                  " neovim's bug, ignore it
                                else
                                  echohl Error | echo 'Error on request ('.a:method.'): '.v:exception | echohl None
                                endif
   76              0.000108   endtry

FUNCTION  <SNR>67_on_focus_gained()
    Defined: ~/.vim/plugged/vim-airline/plugin/airline.vim:77
Called 7 times
Total time:   1.725592
 Self time:   0.000657

count  total (s)   self (s)
    7   0.000888   0.000376   if airline#util#try_focusgained()
    6   1.724690   0.000249     unlet! w:airline_lastmode | :call <sid>airline_refresh(1)
    6              0.000002   endif

FUNCTION  airline#parts#crypt()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/parts.vim:59
Called 522 times
Total time:   0.004986
 Self time:   0.004986

count  total (s)   self (s)
  522              0.004637   return g:airline_detect_crypt && exists("+key") && !empty(&key) ? g:airline_symbols.crypt : ''

FUNCTION  <SNR>166_is_added()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:273
Called 126 times
Total time:   0.000406
 Self time:   0.000406

count  total (s)   self (s)
  126              0.000276   return a:from_count == 0 && a:to_count > 0

FUNCTION  nerdtree#runningWindows()
    Defined: ~/.vim/plugged/nerdtree/autoload/nerdtree.vim:202
Called 6048 times
Total time:   0.052312
 Self time:   0.052312

count  total (s)   self (s)
 6048              0.048828     return has('win16') || has('win32') || has('win64')

FUNCTION  210()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/flag_set.vim:28
Called 6 times
Total time:   0.000117
 Self time:   0.000117

count  total (s)   self (s)
    6              0.000045     let newObj = copy(self)
    6              0.000052     let newObj._flags = {}
    6              0.000013     return newObj

FUNCTION  212()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/flag_set.vim:45
Called 1160 times
Total time:   0.021936
 Self time:   0.021936

count  total (s)   self (s)
 1160              0.001119     let flagstring = ''
 3480              0.004826     for i in values(self._flags)
 2320              0.006257         let flagstring .= join(i)
 3480              0.001853     endfor
                            
 1160              0.001910     if len(flagstring) == 0
                                    return ''
 1160              0.000498     endif
                            
 1160              0.001598     return '[' . flagstring . ']'

FUNCTION  217()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/nerdtree.vim:93
Called 41 times
Total time:   0.023328
 Self time:   0.001752

count  total (s)   self (s)
   41   0.008497   0.000398     call g:NERDTree.MustBeOpen()
   41   0.014767   0.001290     call nerdtree#exec(g:NERDTree.GetWinNum() . 'wincmd w', a:0 >0 ? a:1 : 1)

FUNCTION  219()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/nerdtree.vim:106
Called 1 time
Total time:   0.000170
 Self time:   0.000170

count  total (s)   self (s)
    1              0.000005     if !exists('t:NERDTreeBufName')
                                    return
    1              0.000001     end
                            
                                "check b:NERDTree is still there and hasn't been e.g. :bdeleted
    1              0.000160     return !empty(getbufvar(bufnr(t:NERDTreeBufName), 'NERDTree'))

FUNCTION  jsx_pretty#comment#update_commentstring()
    Defined: ~/.vim/plugged/vim-jsx-pretty/autoload/jsx_pretty/comment.vim:1
Called 114 times
Total time:   0.061937
 Self time:   0.012618

count  total (s)   self (s)
  114              0.000556   let line = getline(".")
  114              0.000289   let col = col('.')
  114              0.001788   if line !~# '^\s*$' && line[: col - 1] =~# '^\s*$'    " skip indent
    1              0.000005     let col = indent('.') + 1
  114              0.000087   endif
  114   0.029425   0.001891   let syn_start = s:syn_name(line('.'), col)
  114              0.000482   let save_cursor = getcurpos()
                            
  114              0.000839   if syn_start =~? '^jsx'
   78              0.000555     if line =~ '^\s*//'
                                  let &l:commentstring = '// %s'
   78   0.023378   0.001593     elseif s:syn_contains(line('.'), col, 'jsxTaggedRegion')
                                  let &l:commentstring = '<!-- %s -->'
   78              0.000605     elseif syn_start =~? '^jsxAttrib'
    2              0.000023       let &l:commentstring = '// %s'
   76              0.000068     else
   76              0.000689       let &l:commentstring = '{/* %s */}'
   78              0.000057     endif
   36              0.000019   else
   36              0.000329     let &l:commentstring = a:original
  114              0.000067   endif
                            
                              " Restore the cursor position
  114              0.000492   call setpos('.', save_cursor)

FUNCTION  airline#extensions#keymap#status()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/keymap.vim:10
Called 522 times
Total time:   0.021623
 Self time:   0.021623

count  total (s)   self (s)
  522              0.003542   if (get(g:, 'airline#extensions#keymap#enabled', 1) && has('keymap'))
  522              0.002288     let short_codes = get(g:, 'airline#extensions#keymap#short_codes', {})
  522              0.002660     let label = get(g:, 'airline#extensions#keymap#label', g:airline_symbols.keymap)
  522              0.001623     let default = get(g:, 'airline#extensions#keymap#default', '')
  522              0.000814     if (label !=# '')
  522              0.001275       let label .= ' '
  522              0.000299     endif
  522              0.000885     let keymap = &keymap
  522              0.001608     if has_key(short_codes, keymap)
                                  let keymap = short_codes[keymap]
  522              0.000271     endif
  522              0.003555     return printf('%s', (!empty(keymap) && &iminsert ? (label . keymap) : (!empty(default) ? label . default : default)))
                              else
                                return ''
                              endif

FUNCTION  <SNR>121_setup_path()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter.vim:156
Called 88 times
Total time:   0.066408
 Self time:   0.002024

count  total (s)   self (s)
   88   0.005751   0.001081   if gitgutter#utility#has_repo_path(a:bufnr) | return | endif
                            
   15   0.060493   0.000779   return gitgutter#utility#set_repo_path(a:bufnr, a:continuation)

FUNCTION  <SNR>169_is_jsx_comment()
    Defined: ~/.vim/plugged/vim-jsx-pretty/autoload/jsx_pretty/indent.vim:82
Called 14 times
Total time:   0.000079
 Self time:   0.000079

count  total (s)   self (s)
   14              0.000064   return a:syntax =~? 'jsxComment'

FUNCTION  <SNR>51_hasPrefix()
    Defined: ~/.vim/plugged/nerdtree-git-plugin/nerdtree_plugin/git_status.vim:221
Called 43 times
Total time:   0.000360
 Self time:   0.000360

count  total (s)   self (s)
   43              0.000316     return len(a:text) >= len(a:prefix) && a:text[:len(a:prefix)-1] ==# a:prefix

FUNCTION  NERDTreeFocus()
    Defined: ~/.vim/plugged/nerdtree/plugin/NERD_tree.vim:191
Called 1 time
Total time:   0.000690
 Self time:   0.000027

count  total (s)   self (s)
    1   0.000172   0.000010     if g:NERDTree.IsOpen()
    1   0.000511   0.000009         call g:NERDTree.CursorToTreeWin(0)
                                else
                                    call g:NERDTreeCreator.ToggleTabTree('')
    1              0.000001     endif

FUNCTION  <SNR>169_syntax_at()
    Defined: ~/.vim/plugged/vim-jsx-pretty/autoload/jsx_pretty/indent.vim:26
Called 14 times
Total time:   0.001254
 Self time:   0.001254

count  total (s)   self (s)
   14              0.001224   return synIDattr(synID(a:lnum, a:col, 1), 'name')

FUNCTION  <SNR>67_airline_refresh()
    Defined: ~/.vim/plugged/vim-airline/plugin/airline.vim:216
Called 7 times
Total time:   1.724441
 Self time:   0.000932

count  total (s)   self (s)
                              " a:1, fast refresh, do not reload the theme
    7              0.000056   let fast=!empty(get(a:000, 0, 0))
    7              0.000030   if !exists("#airline")
                                " disabled
                                return
    7              0.000005   endif
    7   0.001427   0.000286   call airline#util#doautocmd('AirlineBeforeRefresh')
    7   0.018586   0.000159   call airline#highlighter#reset_hlcache()
    7              0.000049   if !fast
                                call airline#load_theme()
    7              0.000009   endif
    6   0.116085   0.000209   call airline#update_statusline()
    6   1.591587   0.000046   call airline#update_tabline()

FUNCTION  gitgutter#diff#run_diff()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:71
Called 43 times
Total time:   0.283531
 Self time:   0.021775

count  total (s)   self (s)
   43   0.001736   0.000511   if gitgutter#utility#repo_path(a:bufnr, 0) == -1
                                throw 'gitgutter path not set'
   43              0.000045   endif
                            
   43   0.001510   0.000497   if gitgutter#utility#repo_path(a:bufnr, 0) == -2
                                throw 'gitgutter not tracked'
   43              0.000024   endif
                            
                              " Wrap compound commands in parentheses to make Windows happy.
                              " bash doesn't mind the parentheses.
   43              0.000057   let cmd = '('
                            
                              " Append buffer number to temp filenames to avoid race conditions between
                              " writing and reading the files when asynchronously processing multiple
                              " buffers.
                            
                              " Without the buffer number, buff_file would have a race between the
                              " second gitgutter#process_buffer() writing the file (synchronously, below)
                              " and the first gitgutter#process_buffer()'s async job reading it (with
                              " git-diff).
   43              0.000203   let buff_file = s:temp_buffer.'.'.a:bufnr
                            
                              " Add a counter to avoid a similar race with two quick writes of the same buffer.
                              " Use a modulus greater than a maximum reasonable number of visible buffers.
   43              0.000253   let s:counter = (s:counter + 1) % 20
   43              0.000176   let buff_file .= '.'.s:counter
                            
   43   0.009727   0.000461   let extension = gitgutter#utility#extension(a:bufnr)
   43              0.000123   if !empty(extension)
   43              0.000148     let buff_file .= '.'.extension
   43              0.000036   endif
                            
                              " Write buffer to temporary file.
                              " Note: this is synchronous.
   43   0.028400   0.001099   call s:write_buffer(a:bufnr, buff_file)
                            
   43              0.000138   if a:from ==# 'index'
                                " Without the buffer number, from_file would have a race in the shell
                                " between the second process writing it (with git-show) and the first
                                " reading it (with git-diff).
   43              0.000327     let from_file = s:temp_from.'.'.a:bufnr
                            
                                " Add a counter to avoid a similar race with two quick writes of the same buffer.
   43              0.000186     let from_file .= '.'.s:counter
                            
   43              0.000136     if !empty(extension)
   43              0.000120       let from_file .= '.'.extension
   43              0.000033     endif
                            
                                " Write file from index to temporary file.
   43   0.014015   0.001566     let index_name = gitgutter#utility#get_diff_base(a:bufnr).':'.gitgutter#utility#repo_path(a:bufnr, 1)
   43              0.000499     let cmd .= g:gitgutter_git_executable.' '.g:gitgutter_git_args.' --no-pager show '.index_name.' > '.from_file.' && '
                            
                              elseif a:from ==# 'working_tree'
                                let from_file = gitgutter#utility#repo_path(a:bufnr, 1)
   43              0.000033   endif
                            
                              " Call git-diff.
   43              0.000222   let cmd .= g:gitgutter_git_executable.' '.g:gitgutter_git_args.' --no-pager'
   43              0.000059   if s:c_flag
   43              0.000137     let cmd .= ' -c "diff.autorefreshindex=0"'
   43              0.000103     let cmd .= ' -c "diff.noprefix=false"'
   43              0.000098     let cmd .= ' -c "core.safecrlf=false"'
   43              0.000027   endif
   43              0.000338   let cmd .= ' diff --no-ext-diff --no-color -U0 '.g:gitgutter_diff_args.' -- '.from_file.' '.buff_file
                            
                              " Pipe git-diff output into grep.
   43              0.000155   if !a:preserve_full_diff && !empty(g:gitgutter_grep)
   43   0.002678   0.000789     let cmd .= ' | '.g:gitgutter_grep.' '.gitgutter#utility#shellescape('^@@ ')
   43              0.000033   endif
                            
                              " grep exits with 1 when no matches are found; git-diff exits with 1 when
                              " differences are found.  However we want to treat non-matches and
                              " differences as non-erroneous behaviour; so we OR the command with one
                              " which always exits with success (0).
   43              0.000262   let cmd .= ' || exit 0'
                            
   43              0.000093   let cmd .= ')'
                            
   43   0.022290   0.000593   let cmd = gitgutter#utility#cd_cmd(a:bufnr, cmd)
                            
   43   0.000604   0.000479   if g:gitgutter_async && gitgutter#async#available()
   43   0.193020   0.006228     call gitgutter#async#execute(cmd, a:bufnr, {   'out': function('gitgutter#diff#handler'),   'err': function('gitgutter#hunk#reset'), })
   43              0.000340     return 'async'
                            
                              else
                                let diff = gitgutter#utility#system(cmd)
                            
                                if v:shell_error
                                  call gitgutter#debug#log(diff)
                                  throw 'gitgutter diff failed'
                                endif
                            
                                return diff
                              endif

FUNCTION  234()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/ui.vim:25
Called 40 times
Total time:   0.005608
 Self time:   0.005313

count  total (s)   self (s)
   40   0.000421   0.000275     if self.getShowHelp()
                                    let help  = "\" NERDTree (" . nerdtree#version() . ") quickhelp~\n"
                                    let help .= "\" ============================\n"
                                    let help .= "\" File node mappings~\n"
                                    let help .= '" '. (g:NERDTreeMouseMode ==# 3 ? 'single' : 'double') ."-click,\n"
                                    if self.nerdtree.isTabTree()
                                        let help .= '" '. g:NERDTreeMapActivateNode .": open in prev window\n"
                                    else
                                        let help .= '" '. g:NERDTreeMapActivateNode .": open in current window\n"
                                    endif
                                    if self.nerdtree.isTabTree()
                                        let help .= '" '. g:NERDTreeMapPreview .": preview\n"
                                    endif
                                    let help .= '" '. g:NERDTreeMapOpenInTab.": open in new tab\n"
                                    let help .= '" '. g:NERDTreeMapOpenInTabSilent .": open in new tab silently\n"
                                    let help .= "\" middle-click,\n"
                                    let help .= '" '. g:NERDTreeMapOpenSplit .": open split\n"
                                    let help .= '" '. g:NERDTreeMapPreviewSplit .": preview split\n"
                                    let help .= '" '. g:NERDTreeMapOpenVSplit .": open vsplit\n"
                                    let help .= '" '. g:NERDTreeMapPreviewVSplit .": preview vsplit\n"
                                    let help .= '" '. g:NERDTreeMapCustomOpen .": custom open\n"
                            
                                    let help .= "\"\n\" ----------------------------\n"
                                    let help .= "\" Directory node mappings~\n"
                                    let help .= '" '. (g:NERDTreeMouseMode ==# 1 ? 'double' : 'single') ."-click,\n"
                                    let help .= '" '. g:NERDTreeMapActivateNode .": open & close node\n"
                                    let help .= '" '. g:NERDTreeMapOpenRecursively .": recursively open node\n"
                                    let help .= '" '. g:NERDTreeMapOpenInTab.": open in new tab\n"
                                    let help .= '" '. g:NERDTreeMapOpenInTabSilent .": open in new tab silently\n"
                                    let help .= '" '. g:NERDTreeMapCustomOpen .": custom open\n"
                                    let help .= '" '. g:NERDTreeMapCloseDir .": close parent of node\n"
                                    let help .= '" '. g:NERDTreeMapCloseChildren .": close all child nodes of\n"
                                    let help .= "\"    current node recursively\n"
                                    let help .= "\" middle-click,\n"
                                    let help .= '" '. g:NERDTreeMapOpenExpl.": explore selected dir\n"
                            
                                    let help .= "\"\n\" ----------------------------\n"
                                    let help .= "\" Bookmark table mappings~\n"
                                    let help .= "\" double-click,\n"
                                    let help .= '" '. g:NERDTreeMapActivateNode .": open bookmark\n"
                                    let help .= '" '. g:NERDTreeMapPreview .": preview file\n"
                                    let help .= '" '. g:NERDTreeMapPreview .": find dir in tree\n"
                                    let help .= '" '. g:NERDTreeMapOpenInTab.": open in new tab\n"
                                    let help .= '" '. g:NERDTreeMapOpenInTabSilent .": open in new tab silently\n"
                                    let help .= '" '. g:NERDTreeMapOpenSplit .": open split\n"
                                    let help .= '" '. g:NERDTreeMapPreviewSplit .": preview split\n"
                                    let help .= '" '. g:NERDTreeMapOpenVSplit .": open vsplit\n"
                                    let help .= '" '. g:NERDTreeMapPreviewVSplit .": preview vsplit\n"
                                    let help .= '" '. g:NERDTreeMapCustomOpen .": custom open\n"
                                    let help .= '" '. g:NERDTreeMapDeleteBookmark .": delete bookmark\n"
                            
                                    let help .= "\"\n\" ----------------------------\n"
                                    let help .= "\" Tree navigation mappings~\n"
                                    let help .= '" '. g:NERDTreeMapJumpRoot .": go to root\n"
                                    let help .= '" '. g:NERDTreeMapJumpParent .": go to parent\n"
                                    let help .= '" '. g:NERDTreeMapJumpFirstChild  .": go to first child\n"
                                    let help .= '" '. g:NERDTreeMapJumpLastChild   .": go to last child\n"
                                    let help .= '" '. g:NERDTreeMapJumpNextSibling .": go to next sibling\n"
                                    let help .= '" '. g:NERDTreeMapJumpPrevSibling .": go to prev sibling\n"
                            
                                    let help .= "\"\n\" ----------------------------\n"
                                    let help .= "\" Filesystem mappings~\n"
                                    let help .= '" '. g:NERDTreeMapChangeRoot .": change tree root to the\n"
                                    let help .= "\"    selected dir\n"
                                    let help .= '" '. g:NERDTreeMapUpdir .": move tree root up a dir\n"
                                    let help .= '" '. g:NERDTreeMapUpdirKeepOpen .": move tree root up a dir\n"
                                    let help .= "\"    but leave old root open\n"
                                    let help .= '" '. g:NERDTreeMapRefresh .": refresh cursor dir\n"
                                    let help .= '" '. g:NERDTreeMapRefreshRoot .": refresh current root\n"
                                    let help .= '" '. g:NERDTreeMapMenu .": Show menu\n"
                                    let help .= '" '. g:NERDTreeMapChdir .":change the CWD to the\n"
                                    let help .= "\"    selected dir\n"
                                    let help .= '" '. g:NERDTreeMapCWD .":change tree root to CWD\n"
                            
                                    let help .= "\"\n\" ----------------------------\n"
                                    let help .= "\" Tree filtering mappings~\n"
                                    let help .= '" '. g:NERDTreeMapToggleHidden .': hidden files (' . (self.getShowHidden() ? 'on' : 'off') . ")\n"
                                    let help .= '" '. g:NERDTreeMapToggleFilters .': file filters (' . (self.isIgnoreFilterEnabled() ? 'on' : 'off') . ")\n"
                                    let help .= '" '. g:NERDTreeMapToggleFiles .': files (' . (self.getShowFiles() ? 'on' : 'off') . ")\n"
                                    let help .= '" '. g:NERDTreeMapToggleBookmarks .': bookmarks (' . (self.getShowBookmarks() ? 'on' : 'off') . ")\n"
                            
                                    " add quickhelp entries for each custom key map
                                    let help .= "\"\n\" ----------------------------\n"
                                    let help .= "\" Custom mappings~\n"
                                    for i in g:NERDTreeKeyMap.All()
                                        if !empty(i.quickhelpText)
                                            let help .= '" '. i.key .': '. i.quickhelpText ."\n"
                                        endif
                                    endfor
                            
                                    let help .= "\"\n\" ----------------------------\n"
                                    let help .= "\" Other mappings~\n"
                                    let help .= '" '. g:NERDTreeMapQuit .": Close the NERDTree window\n"
                                    let help .= '" '. g:NERDTreeMapToggleZoom .": Zoom (maximize-minimize)\n"
                                    let help .= "\"    the NERDTree window\n"
                                    let help .= '" '. g:NERDTreeMapHelp .": toggle help\n"
                                    let help .= "\"\n\" ----------------------------\n"
                                    let help .= "\" Bookmark commands~\n"
                                    let help .= "\" :Bookmark [<name>]\n"
                                    let help .= "\" :BookmarkToRoot <name>\n"
                                    let help .= "\" :RevealBookmark <name>\n"
                                    let help .= "\" :OpenBookmark <name>\n"
                                    let help .= "\" :ClearBookmarks [<names>]\n"
                                    let help .= "\" :ClearAllBookmarks\n"
                                    let help .= "\" :ReadBookmarks\n"
                                    let help .= "\" :WriteBookmarks\n"
                                    let help .= "\" :EditBookmarks\n"
                                    silent! put =help
   40   0.000565   0.000415     elseif !self.isMinimal()
   40              0.000132         let help ='" Press '. g:NERDTreeMapHelp ." for help\n"
   40              0.000356         silent! put =help
   40              0.000023     endif

FUNCTION  223()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/nerdtree.vim:140
Called 169 times
Total time:   0.027118
 Self time:   0.027118

count  total (s)   self (s)
  169              0.000903     if exists('t:NERDTreeBufName')
  169              0.025855         return bufwinnr(t:NERDTreeBufName)
                                endif
                            
                                " If WindowTree, there is no t:NERDTreeBufName variable. Search all windows.
                                for w in range(1,winnr('$'))
                                    if bufname(winbufnr(w)) =~# '^' . g:NERDTreeCreator.BufNamePrefix() . '\d\+$'
                                        return w
                                    endif
                                endfor
                            
                                return -1

FUNCTION  224()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/nerdtree.vim:156
Called 128 times
Total time:   0.022741
 Self time:   0.001858

count  total (s)   self (s)
  128   0.022601   0.001717     return s:NERDTree.GetWinNum() !=# -1

FUNCTION  <SNR>166_is_modified_and_removed()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:289
Called 1 time
Total time:   0.000002
 Self time:   0.000002

count  total (s)   self (s)
    1              0.000002   return a:from_count > 0 && a:to_count > 0 && a:from_count > a:to_count

FUNCTION  238()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/ui.vim:259
Called 1 time
Total time:   0.000036
 Self time:   0.000036

count  total (s)   self (s)
    1              0.000001     let rootLine = 1
    4              0.000025     while rootLine <= line('$') && getline(rootLine) !~# '^\(/\|<\)'
    3              0.000004         let rootLine = rootLine + 1
    4              0.000003     endwhile
    1              0.000001     return rootLine

FUNCTION  <SNR>166_process_modified()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:310
Called 50 times
Total time:   0.001201
 Self time:   0.001201

count  total (s)   self (s)
   50              0.000071   let offset = 0
  108              0.000148   while offset < a:to_count
   58              0.000233     let line_number = a:to_line + offset
   58              0.000240     call add(a:modifications, [line_number, 'modified'])
   58              0.000103     let offset += 1
  108              0.000101   endwhile

FUNCTION  <SNR>51_onNERDTreeInit()
    Defined: ~/.vim/plugged/nerdtree-git-plugin/nerdtree_plugin/git_status.vim:309
Called 1 time
Total time:   0.003884
 Self time:   0.000019

count  total (s)   self (s)
    1   0.003882   0.000018     call s:getGitWorkdir(a:path)

FUNCTION  GitGutterGetHunkSummary()
    Defined: ~/.vim/plugged/vim-gitgutter/plugin/gitgutter.vim:189
Called 521 times
Total time:   0.027005
 Self time:   0.007510

count  total (s)   self (s)
  521   0.026460   0.006965   return gitgutter#hunk#summary(winbufnr(0))

FUNCTION  airline#parts#mode()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/parts.vim:55
Called 522 times
Total time:   0.031811
 Self time:   0.011858

count  total (s)   self (s)
  522   0.031451   0.011498   return airline#util#shorten(get(w:, 'airline_current_mode', ''), 79, 1)

FUNCTION  airline#extensions#hunks#get_raw_hunks()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/hunks.vim:76
Called 521 times
Total time:   0.063595
 Self time:   0.019701

count  total (s)   self (s)
  521              0.002970   if !exists('b:source_func') || get(b:, 'source_func', '') is# 's:get_hunks_empty'
                                if get(g:, 'loaded_signify') && sy#buffer_is_active()
                                  let b:source_func = 's:get_hunks_signify'
                                elseif exists('*GitGutterGetHunkSummary')
                                  let b:source_func = 's:get_hunks_gitgutter'
                                elseif exists('*changes#GetStats')
                                  let b:source_func = 's:get_hunks_changes'
                                elseif exists('*quickfixsigns#vcsdiff#GetHunkSummary')
                                  let b:source_func = 'quickfixsigns#vcsdiff#GetHunkSummary'
                                elseif s:coc_git_enabled()
                                  let b:source_func = 's:get_hunks_coc'
                                else
                                  let b:source_func = 's:get_hunks_empty'
                                endif
  521              0.000204   endif
  521   0.050693   0.006800   return {b:source_func}()

FUNCTION  coc#util#get_bufoptions()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/util.vim:204
Called 1 time
Total time:   0.000458
 Self time:   0.000182

count  total (s)   self (s)
    1              0.000004   if !bufloaded(a:bufnr) | return v:null | endif
    1              0.000003   let bufname = bufname(a:bufnr)
    1              0.000005   let buftype = getbufvar(a:bufnr, '&buftype')
    1              0.000001   let previewwindow = 0
    1              0.000002   let winid = bufwinid(a:bufnr)
    1              0.000001   if winid != -1
    1              0.000004     let previewwindow = getwinvar(winid, '&previewwindow', 0)
    1              0.000000   endif
    1              0.000001   let size = -1
    1              0.000002   if bufnr('%') == a:bufnr
    1              0.000005     let size = line2byte(line("$") + 1)
                              elseif !empty(bufname)
                                let size = getfsize(bufname)
    1              0.000000   endif
    1              0.000001   let lines = []
    1              0.000004   if getbufvar(a:bufnr, 'coc_enabled', 1) && (buftype == '' || buftype == 'acwrite') && size < a:maxFileSize
    1              0.000008     let lines = getbufline(a:bufnr, 1, '$')
    1              0.000000   endif
    1   0.000410   0.000133   return { 'bufname': bufname, 'size': size, 'buftype': buftype, 'winid': winid, 'previewwindow': previewwindow == 0 ? v:false : v:true, 'variables': s:variables(a:bufnr), 'fullpath': empty(bufname) ? '' : fnamemodify(bufname, ':p'), 'eol': getbufvar(a:bufnr, '&eol'), 'filetype': getbufvar(a:bufnr, '&filetype'), 'iskeyword': getbufvar(a:bufnr, '&iskeyword'), 'changedtick': getbufvar(a:bufnr, 'changedtick'), 'lines': lines,}

FUNCTION  airline#extensions#quickfix#apply()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/quickfix.vim:14
Called 116 times
Total time:   0.001207
 Self time:   0.001207

count  total (s)   self (s)
  116              0.000368   if &buftype == 'quickfix'
                                let w:airline_section_a = airline#extensions#quickfix#get_type()
                                let w:airline_section_b = '%{get(w:, "quickfix_title", "")}'
                                let w:airline_section_c = ''
                                let w:airline_section_x = ''
  116              0.000070   endif

FUNCTION  <SNR>82_Remove_Matches()
    Defined: /usr/local/Cellar/neovim/0.5.0/share/nvim/runtime/plugin/matchparen.vim:197
Called 403 times
Total time:   0.005011
 Self time:   0.005011

count  total (s)   self (s)
  403              0.002126   if exists('w:paren_hl_on') && w:paren_hl_on
  118              0.000609     silent! call matchdelete(3)
  118              0.000244     let w:paren_hl_on = 0
  403              0.000268   endif

FUNCTION  <SNR>102_ws_refresh()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/whitespace.vim:186
Called 44 times
Total time:   0.001006
 Self time:   0.001006

count  total (s)   self (s)
   44              0.000298   if !exists('#airline')
                                " airline disabled
                                return
   44              0.000036   endif
   44              0.000225   if get(b:, 'airline_ws_changedtick', 0) == b:changedtick
   32              0.000022     return
   12              0.000004   endif
   12              0.000112   unlet! b:airline_whitespace_check
   12              0.000028   if get(g:, 'airline_skip_empty_sections', 0)
                                exe ':AirlineRefresh!'
   12              0.000005   endif
   12              0.000037   let b:airline_ws_changedtick = b:changedtick

FUNCTION  gitgutter#hunk#increment_lines_removed()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/hunk.vim:40
Called 1 time
Total time:   0.000057
 Self time:   0.000032

count  total (s)   self (s)
    1   0.000018   0.000004   let summary = gitgutter#hunk#summary(a:bufnr)
    1              0.000006   let summary[2] += a:count
    1   0.000032   0.000022   call gitgutter#utility#setbufvar(a:bufnr, 'summary', summary)

FUNCTION  232()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/nerdtree.vim:205
Called 40 times
Total time:   0.524313
 Self time:   0.000595

count  total (s)   self (s)
   40   0.524288   0.000570     call self.ui.render()

FUNCTION  coc#helper#dict_pick()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/helper.vim:73
Called 26 times
Total time:   0.001483
 Self time:   0.001483

count  total (s)   self (s)
   26              0.000062   let res = {}
  182              0.000334   for key in keys(a:dict)
  156              0.000361     if index(a:keys, key) != -1
  130              0.000320       let res[key] = a:dict[key]
  156              0.000101     endif
  182              0.000099   endfor
   26              0.000026   return res

FUNCTION  237()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/ui.vim:211
Called 1 time
Total time:   0.001178
 Self time:   0.000402

count  total (s)   self (s)
                            
    1   0.000236   0.000005     if a:node.isRoot()
                                    return self.getRootLineNum()
    1              0.000000     endif
                            
    1   0.000172   0.000019     let l:pathComponents = [substitute(self.nerdtree.root.path.str({'format': 'UI'}), '/\s*$', '', '')]
    1              0.000002     let l:currentPathComponent = 1
                            
    1   0.000063   0.000007     let l:fullPath = a:node.path.str({'format': 'UI'})
                            
    8   0.000053   0.000017     for l:lineNumber in range(self.getRootLineNum() + 1, line('$'))
    8              0.000018         let l:currentLine = getline(l:lineNumber)
    8   0.000237   0.000054         let l:indentLevel = self._indentLevelFor(l:currentLine)
                            
    8              0.000011         if l:indentLevel !=# l:currentPathComponent
                                        continue
    8              0.000003         endif
                            
    8   0.000154   0.000038         let l:currentLine = self._stripMarkup(l:currentLine)
    8              0.000032         let l:currentPath =  join(l:pathComponents, '/') . '/' . l:currentLine
                            
                                    " Directories: If the current path 'starts with' the full path, then
                                    " either the paths are equal or the line is a cascade containing the
                                    " full path.
    8              0.000021         if l:fullPath[-1:] ==# '/' && stridx(l:currentPath, l:fullPath) ==# 0
                                        return l:lineNumber
    8              0.000003         endif
                            
                                    " Files: The paths must exactly match.
    8              0.000011         if l:fullPath ==# l:currentPath
    1              0.000001             return l:lineNumber
    7              0.000003         endif
                            
                                    " Otherwise: If the full path starts with the current path and the
                                    " current path is a directory, we add a new path component.
    7              0.000045         if stridx(l:fullPath, l:currentPath) ==# 0 && l:currentPath[-1:] ==# '/'
    1              0.000006             let l:currentLine = substitute(l:currentLine, '/\s*$', '', '')
    1              0.000003             call add(l:pathComponents, l:currentLine)
    1              0.000002             let l:currentPathComponent += 1
    7              0.000013         endif
    7              0.000004     endfor
                            
                                return -1

FUNCTION  airline#builder#get_prev_group()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/builder.vim:37
Called 2246 times
Total time:   0.029018
 Self time:   0.029018

count  total (s)   self (s)
 2246              0.004326   let x = a:i - 1
 2512              0.003195   while x >= 0
 2131              0.005186     let group = a:sections[x][0]
 2131              0.005184     if group != '' && group != '|'
 1865              0.002412       return group
  266              0.000238     endif
  266              0.000266     let x = x - 1
  647              0.000775   endwhile
  381              0.000367   return ''

FUNCTION  gitgutter#async#execute()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/async.vim:16
Called 58 times
Total time:   0.236572
 Self time:   0.233515

count  total (s)   self (s)
   58   0.003551   0.000882   call gitgutter#debug#log('[async] '.a:cmd)
                            
   58              0.000336   let options = {   'stdoutbuffer': [],   'buffer': a:bufnr,   'handler': a:handler }
   58   0.000988   0.000601   let command = s:build_command(a:cmd)
                            
   58              0.000152   if has('nvim')
   58              0.224047     call jobstart(command, extend(options, {   'on_stdout': function('s:on_stdout_nvim'),   'on_stderr': function('s:on_stderr_nvim'),   'on_exit':   function('s:on_exit_nvim') }))
                              else
                                let job = job_start(command, {   'out_cb':   function('s:on_stdout_vim', options),   'err_cb':   function('s:on_stderr_vim', options),   'close_cb': function('s:on_exit_vim', options) })
                                let s:jobs[s:job_id(job)] = 1
   58              0.000059   endif

FUNCTION  coc#_complete()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc.vim:50
Called 103 times
Total time:   7.249741
 Self time:   5.668507

count  total (s)   self (s)
  103              0.000923   let items = get(g:coc#_context, 'candidates', [])
  103              0.000400   let preselect = get(g:coc#_context, 'preselect', -1)
  103              0.000244   let startcol = g:coc#_context.start + 1
  103              0.000475   if s:select_api && len(items) && preselect != -1
                                noa call complete(startcol, items)
                                call nvim_select_popupmenu_item(preselect, v:false, v:false, {})
  103              0.000102   else
  103   7.245797   5.664563     call complete(startcol, items)
  103              0.000087   endif
  103              0.000145   return ''

FUNCTION  <SNR>169_is_jsx_brace()
    Defined: ~/.vim/plugged/vim-jsx-pretty/autoload/jsx_pretty/indent.vim:77
Called 14 times
Total time:   0.000078
 Self time:   0.000078

count  total (s)   self (s)
   14              0.000072   return a:syntax =~? 'jsxBraces'

FUNCTION  airline#extensions#wordcount#apply()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/wordcount.vim:88
Called 116 times
Total time:   0.005017
 Self time:   0.005017

count  total (s)   self (s)
  116              0.001246   let filetypes = get(g:, 'airline#extensions#wordcount#filetypes',  ['asciidoc', 'help', 'mail', 'markdown', 'nroff', 'org', 'rst', 'plaintex', 'tex', 'text'])
                              " export current filetypes settings to global namespace
  116              0.000444   let g:airline#extensions#wordcount#filetypes = filetypes
                            
                              " Check if filetype needs testing
  116              0.000232   if did_filetype()
                                " correctly test for compound filetypes (e.g. markdown.pandoc)
    1              0.000004     let ft = substitute(&filetype, '\.', '\\|', 'g')
                            
                                " Select test based on type of "filetypes": new=list, old=string
    1              0.000012     if type(filetypes) == get(v:, 't_list', type([])) ? match(filetypes, '\<'. ft. '\>') > -1 || index(filetypes, 'all') > -1 : match(&filetype, filetypes) > -1
                                  let b:airline_changedtick = -1
                                  call s:update_wordcount(1) " force update: ensures initial worcount exists
    1              0.000002     elseif exists('b:airline_wordcount') " cleanup when filetype is removed
                                  unlet b:airline_wordcount
    1              0.000000     endif
  116              0.000043   endif
                            
  116              0.000383   if exists('b:airline_wordcount')
                                call airline#extensions#prepend_to_section( 'z', '%{airline#extensions#wordcount#get()}')
  116              0.000049   endif

FUNCTION  polyglot#init#is_disabled()
    Defined: ~/.config/nvim/autoload/plugged/vim-polyglot/autoload/polyglot/init.vim:23
Called 148 times
Total time:   0.003455
 Self time:   0.003455

count  total (s)   self (s)
  148              0.000352   if !g:polyglot_initialized
                                if a:path[0:7] == "autoload"
                                  let g:polyglot_initialized = 1
                            
                                  for p in globpath(&rtp, a:path, 0, 1)
                                    if p != a:caller
                                      exe "source " . p
                                    endif
                                  endfor
                                endif
  148              0.000068   endif
                            
  148              0.000512   return has_key(g:polyglot_is_disabled, a:name)

FUNCTION  gitgutter#diff#handler()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:173
Called 42 times
Total time:   0.075389
 Self time:   0.005210

count  total (s)   self (s)
   42   0.002241   0.000594   call gitgutter#debug#log(a:diff)
                            
   42              0.000122   if !bufexists(a:bufnr)
                                return
   42              0.000016   endif
                            
   42   0.014905   0.000782   call gitgutter#hunk#set_hunks(a:bufnr, gitgutter#diff#parse_diff(a:diff))
   42   0.037194   0.000761   let modified_lines = gitgutter#diff#process_hunks(a:bufnr, gitgutter#hunk#hunks(a:bufnr))
                            
   42              0.000091   let signs_count = len(modified_lines)
   42              0.000094   if g:gitgutter_max_signs != -1 && signs_count > g:gitgutter_max_signs
                                call gitgutter#utility#warn_once(a:bufnr, printf( 'exceeded maximum number of signs (%d > %d, configured by g:gitgutter_max_signs).', signs_count, g:gitgutter_max_signs), 'max_signs')
                                call gitgutter#sign#clear_signs(a:bufnr)
                            
   42              0.000020   else
   42              0.000081     if g:gitgutter_signs || g:gitgutter_highlight_lines || g:gitgutter_highlight_linenrs
   42   0.017876   0.001168       call gitgutter#sign#update_signs(a:bufnr, modified_lines)
   42              0.000028     endif
   42              0.000015   endif
                            
   42   0.001742   0.000474   call s:save_last_seen_change(a:bufnr)
   42              0.000229   if exists('#User#GitGutter')
                                let g:gitgutter_hook_context = {'bufnr': a:bufnr}
                                execute 'doautocmd' s:nomodeline 'User GitGutter'
                                unlet g:gitgutter_hook_context
   42              0.000016   endif

FUNCTION  gitstatus#util#FormatPath()
    Defined: ~/.vim/plugged/nerdtree-git-plugin/autoload/gitstatus/util.vim:45
Called 1210 times
Total time:   0.183029
 Self time:   0.010260

count  total (s)   self (s)
 1210   0.182443   0.009674         return a:path.str()

FUNCTION  <SNR>169_start_syntax()
    Defined: ~/.vim/plugged/vim-jsx-pretty/autoload/jsx_pretty/indent.vim:36
Called 14 times
Total time:   0.001786
 Self time:   0.000272

count  total (s)   self (s)
   14   0.001768   0.000254   return s:syntax_at(a:lnum, s:start_col(a:lnum))

FUNCTION  <SNR>97_hl_group_exists()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim:99
Called 15089 times
Total time:   0.223112
 Self time:   0.223112

count  total (s)   self (s)
15089              0.066752     if !hlexists(a:group)
                                  return 0
15089              0.103533     elseif empty(synIDattr(synIDtrans(hlID(a:group)), 'fg'))
                                  return 0
15089              0.005952     endif
15089              0.008758     return 1

FUNCTION  <SNR>169_syntax_context()
    Defined: ~/.vim/plugged/vim-jsx-pretty/autoload/jsx_pretty/indent.vim:194
Called 14 times
Total time:   0.005478
 Self time:   0.003284

count  total (s)   self (s)
   14   0.000414   0.000156   let start_col = s:start_col(a:lnum)
   14   0.001297   0.000197   let syntax_stack = s:syntax_stack_at(a:lnum, start_col)
   14              0.000053   let start_syntax = syntax_stack[-1]
   14              0.000044   let reversed = reverse(syntax_stack)
   14              0.000018   let i = 0
                            
   44              0.000090   for syntax_name in reversed
                                " If the current line is jsxExpressionBlock and not starts with jsxBraces
   44   0.000754   0.000464     if s:is_jsx_expression(syntax_name)
                                  return 'jsxExpressionBlock'
   44              0.000032     endif
                            
   44   0.000704   0.000513     if s:is_jsx_region(syntax_name)
                                  return 'jsxRegion'
   44              0.000021     endif
                            
   44   0.000613   0.000390     if s:is_jsx_element(syntax_name)
                                  " If current line starts with the opening tag
   14   0.000332   0.000229       if s:is_opening_tag(start_syntax) || s:is_closing_tag(start_syntax)
                                    " And the next syntax is jsxRegion
   10   0.000097   0.000065         if s:is_jsx_region(reversed[i+1])
                                      return 'jsxRegion'
   10              0.000042         elseif reversed[i+1] =~ 'jsxTaggedRegion'
                                      return 'jsxTaggedRegion'
   10              0.000005         else
   10              0.000009           return 'jsxElement'
                                    endif
    4              0.000028       elseif reversed[i+1] =~ 'jsxTaggedRegion'
                                    return 'jsxTaggedRegion'
    4              0.000003       else
    4              0.000005         return 'jsxElement'
                                  endif
   30              0.000013     endif
                            
   30              0.000040     let i = i + 1
   30              0.000020   endfor
                              
                              return 'Other'

FUNCTION  gitgutter#setup_maps()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter.vim:107
Called 5 times
Total time:   0.000159
 Self time:   0.000083

count  total (s)   self (s)
    5              0.000007   if !g:gitgutter_map_keys
                                return
    5              0.000003   endif
                            
                              " Note hasmapto() and maparg() operate on the current buffer.
                            
    5              0.000013   let bufnr = bufnr('')
                            
    5   0.000115   0.000038   if gitgutter#utility#getbufvar(bufnr, 'mapped', 0)
    5              0.000003     return
                              endif
                            
                              if !hasmapto('<Plug>(GitGutterPrevHunk)') && maparg('[c', 'n') ==# ''
                                nmap <buffer> [c <Plug>(GitGutterPrevHunk)
                              endif
                              if !hasmapto('<Plug>(GitGutterNextHunk)') && maparg(']c', 'n') ==# ''
                                nmap <buffer> ]c <Plug>(GitGutterNextHunk)
                              endif
                            
                              if !hasmapto('<Plug>(GitGutterStageHunk)', 'v') && maparg('<Leader>hs', 'x') ==# ''
                                xmap <buffer> <Leader>hs <Plug>(GitGutterStageHunk)
                              endif
                              if !hasmapto('<Plug>(GitGutterStageHunk)', 'n') && maparg('<Leader>hs', 'n') ==# ''
                                nmap <buffer> <Leader>hs <Plug>(GitGutterStageHunk)
                              endif
                              if !hasmapto('<Plug>(GitGutterUndoHunk)') && maparg('<Leader>hu', 'n') ==# ''
                                nmap <buffer> <Leader>hu <Plug>(GitGutterUndoHunk)
                              endif
                              if !hasmapto('<Plug>(GitGutterPreviewHunk)') && maparg('<Leader>hp', 'n') ==# ''
                                nmap <buffer> <Leader>hp <Plug>(GitGutterPreviewHunk)
                              endif
                            
                              if !hasmapto('<Plug>(GitGutterTextObjectInnerPending)') && maparg('ic', 'o') ==# ''
                                omap <buffer> ic <Plug>(GitGutterTextObjectInnerPending)
                              endif
                              if !hasmapto('<Plug>(GitGutterTextObjectOuterPending)') && maparg('ac', 'o') ==# ''
                                omap <buffer> ac <Plug>(GitGutterTextObjectOuterPending)
                              endif
                              if !hasmapto('<Plug>(GitGutterTextObjectInnerVisual)') && maparg('ic', 'x') ==# ''
                                xmap <buffer> ic <Plug>(GitGutterTextObjectInnerVisual)
                              endif
                              if !hasmapto('<Plug>(GitGutterTextObjectOuterVisual)') && maparg('ac', 'x') ==# ''
                                xmap <buffer> ac <Plug>(GitGutterTextObjectOuterVisual)
                              endif
                            
                              call gitgutter#utility#setbufvar(bufnr, 'mapped', 1)

FUNCTION  240()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/ui.vim:273
Called 3000 times
Total time:   0.003768
 Self time:   0.003768

count  total (s)   self (s)
 3000              0.002670     return self._showFiles

FUNCTION  244()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/ui.vim:301
Called 8 times
Total time:   0.000008
 Self time:   0.000008

count  total (s)   self (s)
    8              0.000005     return 2

FUNCTION  gitstatus#util#UpdateParentDirsStatus()
    Defined: ~/.vim/plugged/nerdtree-git-plugin/autoload/gitstatus/util.vim:207
Called 610 times
Total time:   0.020431
 Self time:   0.020431

count  total (s)   self (s)
  610              0.002059     if get(a:cache, a:pathStr, '') ==# 'Ignored'
                                    return
  610              0.000317     endif
  610              0.002425     let l:dirtyPath = fnamemodify(a:pathStr, ':h')
  610              0.001717     let l:dir_dirty_only = get(a:opts, 'NERDTreeGitStatusDirDirtyOnly', 1)
  830              0.001671     while l:dirtyPath !=# a:root
  742              0.002453         let l:key = get(a:cache, l:dirtyPath, '')
  742              0.000778         if l:dir_dirty_only
  742              0.000879             if l:key ==# ''
  220              0.000642                 let a:cache[l:dirtyPath] = 'Dirty'
  522              0.000335             else
  522              0.000294                 return
  220              0.000096             endif
                                    else
                                        if l:key ==# ''
                                            let a:cache[l:dirtyPath] = a:statusKey
                                        elseif l:key ==# 'Dirty' || l:key ==# a:statusKey
                                            return
                                        else
                                            let a:cache[l:dirtyPath] = 'Dirty'
                                        endif
  220              0.000091         endif
  220              0.000703         let l:dirtyPath = fnamemodify(l:dirtyPath, ':h')
  308              0.000361     endwhile

FUNCTION  246()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/ui.vim:311
Called 120 times
Total time:   0.000244
 Self time:   0.000244

count  total (s)   self (s)
  120              0.000204     return g:NERDTreeMinimalUI

FUNCTION  gitgutter#hunk#increment_lines_added()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/hunk.vim:28
Called 75 times
Total time:   0.004888
 Self time:   0.001798

count  total (s)   self (s)
   75   0.002882   0.000765   let summary = gitgutter#hunk#summary(a:bufnr)
   75              0.000128   let summary[0] += a:count
   75   0.001662   0.000689   call gitgutter#utility#setbufvar(a:bufnr, 'summary', summary)

FUNCTION  <SNR>121_has_fresh_changes()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter.vim:162
Called 70 times
Total time:   0.002085
 Self time:   0.001082

count  total (s)   self (s)
   70   0.002047   0.001044   return getbufvar(a:bufnr, 'changedtick') != gitgutter#utility#getbufvar(a:bufnr, 'tick')

FUNCTION  <SNR>122_convert_config_nvim()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/float.vim:723
Called 26 times
Total time:   0.003088
 Self time:   0.001473

count  total (s)   self (s)
   26              0.000121   let valids = ['relative', 'win', 'anchor', 'width', 'height', 'bufpos', 'col', 'row', 'focusable', 'style']
   26   0.001746   0.000263   let result = coc#helper#dict_pick(a:config, valids)
   26              0.000089   let border = get(a:config, 'border', [])
   26   0.000410   0.000278   if !s:empty_border(border)
                                if result['relative'] ==# 'cursor' && result['row'] < 0
                                  " move top when has bottom border
                                  if get(border, 2, 0)
                                    let result['row'] = result['row'] - 1
                                  endif
                                else
                                  " move down when has top border
                                  if get(border, 0, 0) && !get(a:config, 'prompt', 0)
                                    let result['row'] = result['row'] + 1
                                  endif
                                endif
                                " move right when has left border
                                if get(border, 3, 0)
                                  let result['col'] = result['col'] + 1
                                endif
                                let result['width'] = float2nr(result['width'] + 1 - get(border,3, 0))
   26              0.000015   else
   26              0.000086     let result['width'] = float2nr(result['width'] + 1)
   26              0.000013   endif
   26              0.000059   let result['height'] = float2nr(result['height'])
   26              0.000022   return result

FUNCTION  <SNR>169_is_jsx_region()
    Defined: ~/.vim/plugged/vim-jsx-pretty/autoload/jsx_pretty/indent.vim:62
Called 54 times
Total time:   0.000222
 Self time:   0.000222

count  total (s)   self (s)
   54              0.000201   return a:syntax =~? 'jsxRegion'

FUNCTION  <SNR>115_trim()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc.vim:130
Called 2049 times
Total time:   0.018091
 Self time:   0.018091

count  total (s)   self (s)
 2049              0.008013   if exists('*trim')
 2049              0.006923     return trim(a:str)
                              endif
                              return substitute(a:str, '\s\+$', '', '')

FUNCTION  coc#float#nvim_create_related()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/float.vim:183
Called 26 times
Total time:   0.019300
 Self time:   0.002648

count  total (s)   self (s)
   26              0.000116   let related = getwinvar(a:winid, 'related', [])
   26              0.000056   let exists = !empty(related)
   26              0.000064   let border = get(a:opts, 'border', [])
   26              0.000061   let highlights = get(a:opts, 'borderhighlight', [])
   26              0.000077   let hlgroup = get(a:opts, 'highlight', 'CocFloating')
   26              0.000121   let borderhighlight = type(highlights) == 1 ? highlights : get(highlights, 0, 'CocFloating')
   26   0.000537   0.000342   let borderhighlight =  coc#highlight#compose_hlgroup(borderhighlight, hlgroup)
   26              0.000063   let title = get(a:opts, 'title', '')
   26              0.000055   let buttons = get(a:opts, 'buttons', [])
   26              0.000071   let pad = empty(border) || get(border, 1, 0) == 0
   26              0.000044   if get(a:opts, 'close', 0)
                                call coc#float#nvim_close_btn(a:config, a:winid, border, borderhighlight, related)
   26              0.000023   elseif exists
                                call coc#float#close_related(a:winid, 'close')
   26              0.000013   endif
   26              0.000036   if !empty(buttons)
                                call coc#float#nvim_buttons(a:config, a:winid, buttons, get(border, 2, 0), pad, hlgroup, borderhighlight, related)
   26              0.000017   elseif exists
                                call coc#float#close_related(a:winid, 'buttons')
   26              0.000010   endif
   26   0.000278   0.000176   if !s:empty_border(border)
                                call coc#float#nvim_border_win(a:config, a:winid, border, title, !empty(buttons), borderhighlight, related)
   26              0.000018   elseif exists
                                call coc#float#close_related(a:winid, 'border')
   26              0.000010   endif
                              " Check right border
   26              0.000016   if pad
   26   0.016775   0.000421     call coc#float#nvim_right_pad(a:config, a:winid, hlgroup, related)
                              elseif exists
                                call coc#float#close_related(a:winid, 'pad')
   26              0.000013   endif
   26              0.000216   call setwinvar(a:winid, 'related', filter(related, 'nvim_win_is_valid(v:val)'))

FUNCTION  <SNR>111_build_sections()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/default.vim:35
Called 495 times
Total time:   0.207027
 Self time:   0.033896

count  total (s)   self (s)
 2512              0.003570   for key in a:keys
 2017              0.005772     if (key == 'warning' || key == 'error') && !a:context.active
  304              0.000187       continue
 1713              0.000779     endif
 1713   0.189387   0.016256     call s:add_section(a:builder, a:context, key)
 2208              0.002136   endfor

FUNCTION  <SNR>59_CursorHoldUpdate()
    Defined: ~/.vim/plugged/vim-devicons/plugin/webdevicons.vim:400
Called 41 times
Total time:   1.743395
 Self time:   0.007870

count  total (s)   self (s)
   41              0.000294   if g:NERDTreeUpdateOnCursorHold != 1 || g:NERDTreeGitStatusUpdateOnCursorHold != 1
                                return
   41              0.000037   endif
                            
   41   0.009963   0.000712   if !exists('g:NERDTree') || !g:NERDTree.IsOpen()
    2              0.000005     return
   39              0.000060   endif
                            
                              " Do not update when a special buffer is selected
   39              0.000296   if !empty(&l:buftype)
    1              0.000001     return
   38              0.000026   endif
                            
                              " winnr need to make focus go to opened file
                              " CursorToTreeWin needed to avoid error on opening file
   38              0.000183   let l:winnr = winnr()
   38              0.000160   let l:altwinnr = winnr('#')
                            
   38   0.022649   0.000631   call g:NERDTree.CursorToTreeWin()
   38   1.206700   0.000767   call b:NERDTree.root.refreshFlags()
   38   0.498761   0.000438   call NERDTreeRender()
                            
   38              0.000686   exec l:altwinnr . 'wincmd w'
   38              0.002902   exec l:winnr . 'wincmd w'

FUNCTION  gitstatus#shouldConceal()
    Defined: ~/.vim/plugged/nerdtree-git-plugin/autoload/gitstatus.vim:67
Called 505 times
Total time:   0.002698
 Self time:   0.002698

count  total (s)   self (s)
  505              0.002290     return has('conceal') && g:NERDTreeGitStatusConcealBrackets

FUNCTION  250()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/ui.vim:364
Called 1 time
Total time:   0.000661
 Self time:   0.000104

count  total (s)   self (s)
    1              0.000008     let win = winnr()
    1              0.000026     let self._screenState = {}
    1              0.000002     try
    1   0.000544   0.000015         call g:NERDTree.CursorToTreeWin()
    1              0.000011         let self._screenState['oldPos'] = getpos('.')
    1              0.000007         let self._screenState['oldTopLine'] = line('w0')
    1              0.000011         let self._screenState['oldWindowSize'] = winnr('$')==1 ? g:NERDTreeWinSize : winwidth('')
    1   0.000043   0.000015         call nerdtree#exec(win . 'wincmd w', 1)
                                catch
    1              0.000001     endtry

FUNCTION  252()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/ui.vim:387
Called 8 times
Total time:   0.000116
 Self time:   0.000116

count  total (s)   self (s)
    8              0.000079     let l:line = substitute(a:line, '^.\{-}' . g:NERDTreeNodeDelimiter, '', '')
    8              0.000033     return substitute(l:line, g:NERDTreeNodeDelimiter.'.*$', '', '')

FUNCTION  253()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/ui.vim:393
Called 40 times
Total time:   0.523718
 Self time:   0.010357

count  total (s)   self (s)
   40   0.000660   0.000657     setlocal noreadonly modifiable
                            
                                " remember the top line of the buffer and the current line so we can
                                " restore the view exactly how it was
   40              0.000109     let curLine = line('.')
   40              0.000200     let curCol = col('.')
   40              0.000080     let topLine = line('w0')
                            
                                " delete all lines in the buffer (being careful not to clobber a register)
   40              0.001941     silent 1,$delete _
                            
   40   0.005953   0.000345     call self._dumpHelp()
                            
                                " delete the blank line before the help and add one after it
   40   0.000244   0.000193     if !self.isMinimal()
   40              0.000230         call setline(line('.')+1, '')
   40              0.000137         call cursor(line('.')+1, col('.'))
   40              0.000019     endif
                            
   40   0.000312   0.000200     if self.getShowBookmarks()
                                    call self._renderBookmarks()
   40              0.000018     endif
                            
                                " add the 'up a dir' line
   40   0.000169   0.000126     if !self.isMinimal()
   40   0.000447   0.000390         call setline(line('.')+1, s:UI.UpDirLine())
   40              0.000193         call cursor(line('.')+1, col('.'))
   40              0.000018     endif
                            
                                " draw the header line
   40   0.016523   0.000588     let header = self.nerdtree.root.path.str({'format': 'UI', 'truncateTo': winwidth(0)})
   40              0.000236     call setline(line('.')+1, header)
   40              0.000122     call cursor(line('.')+1, col('.'))
                            
                                " draw the tree
   40   0.492934   0.001440     silent put =self.nerdtree.root.renderToString()
                            
                                " delete the blank line at the top of the buffer
   40              0.000351     silent 1,1delete _
                            
                                " restore the view
   40              0.000156     let old_scrolloff=&scrolloff
   40   0.000266   0.000264     let &scrolloff=0
   40              0.000133     call cursor(topLine, 1)
   40              0.001056     normal! zt
   40              0.000129     call cursor(curLine, curCol)
   40   0.000196   0.000145     let &scrolloff = old_scrolloff
                            
   40   0.000228   0.000226     setlocal readonly nomodifiable

FUNCTION  airline#statusline()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline.vim:207
Called 524 times
Total time:   0.008754
 Self time:   0.008754

count  total (s)   self (s)
  524              0.003077   if has_key(s:contexts, a:winnr)
  524              0.004674     return '%{airline#check_mode('.a:winnr.')}'.s:contexts[a:winnr].line
                              endif
                              " in rare circumstances this happens...see #276
                              return ''

FUNCTION  <SNR>5_detect_indent()
    Defined: ~/.config/nvim/autoload/plugged/vim-polyglot/autoload/polyglot/init.vim:2929
Called 5 times
Total time:   0.009091
 Self time:   0.001107

count  total (s)   self (s)
    5              0.000021     if &buftype ==# 'help'
                                  return
    5              0.000003     endif
                            
                                " Do not autodetect indent if language or user sets it
    5              0.000011     if &l:shiftwidth != s:default_shiftwidth
    1              0.000001       return
    4              0.000002     endif
                            
    4              0.000871     let b:sleuth_culprit = expand("<afile>:p")
    4   0.008156   0.000173     if s:guess(getline(1, 128))
    4              0.000003       return
                                endif
                                if s:guess(getline(1, 1024))
                                  return
                                endif
                                let pattern = polyglot#sleuth#GlobForFiletype(&filetype)
                                if len(pattern) == 0
                                  return
                                endif
                                let pattern = '{' . pattern . ',.git,.svn,.hg}'
                                let dir = expand('%:p:h')
                                let level = 3
                                while isdirectory(dir) && dir !=# fnamemodify(dir, ':h') && level > 0
                                  " Ignore files from homedir and root 
                                  if dir == expand('~') || dir == '/'
                                    unlet b:sleuth_culprit
                                    return
                                  endif
                                  for neighbor in glob(dir . '/' . pattern, 0, 1)[0:level]
                                    let b:sleuth_culprit = neighbor
                                    " Do not consider directories above .git, .svn or .hg
                                    if fnamemodify(neighbor, ":h:t")[0] == "."
                                      let level = 0
                                      continue
                                    endif
                                    if neighbor !=# expand('%:p') && filereadable(neighbor)
                                      if s:guess(readfile(neighbor, '', 32))
                                        return
                                      endif
                                    endif
                                  endfor
                            
                                  let dir = fnamemodify(dir, ':h')
                                  let level -= 1
                                endwhile
                            
                                let b:sleuth_culprit = "default"

FUNCTION  <SNR>110_get_seperator()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/builder.vim:155
Called 1218 times
Total time:   1.865418
 Self time:   0.036726

count  total (s)   self (s)
 1218   0.635212   0.018336   if airline#builder#should_change_group(a:prev_group, a:group)
 1218   1.228876   0.017061     return s:get_transitioned_seperator(a:self, a:prev_group, a:group, a:side)
                              else
                                return a:side ? a:self._context.left_alt_sep : a:self._context.right_alt_sep
                              endif

FUNCTION  <SNR>169_sw()
    Defined: ~/.vim/plugged/vim-jsx-pretty/autoload/jsx_pretty/indent.vim:2
Called 14 times
Total time:   0.000071
 Self time:   0.000071

count  total (s)   self (s)
   14              0.000038     return shiftwidth()

FUNCTION  coc#highlight#clear_highlight()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/highlight.vim:230
Called 27 times
Total time:   0.001080
 Self time:   0.000967

count  total (s)   self (s)
   27              0.000082   let bufnr = a:bufnr == 0 ? bufnr('%') : a:bufnr
   27              0.000058   if !bufloaded(bufnr)
                                return
   27              0.000011   endif
   27   0.000342   0.000229   let src_id = coc#highlight#create_namespace(a:key)
   27              0.000069   if has('nvim')
   27              0.000330     call nvim_buf_clear_namespace(a:bufnr, src_id, a:start_line, a:end_line)
                              else
                                call coc#api#call('buf_clear_namespace', [a:bufnr, src_id, a:start_line, a:end_line])
   27              0.000022   endif

FUNCTION  airline#extensions#coc#get_status()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/coc.vim:46
Called 522 times
Total time:   0.022510
 Self time:   0.006780

count  total (s)   self (s)
                              " Shorten text for windows < 91 characters
  522   0.021823   0.006093   return airline#util#shorten(get(g:, 'coc_status', ''), 91, 9)

FUNCTION  <SNR>112_reset_summary()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/hunk.vim:24
Called 42 times
Total time:   0.001178
 Self time:   0.000538

count  total (s)   self (s)
   42   0.001126   0.000486   call gitgutter#utility#setbufvar(a:bufnr, 'summary', [0,0,0])

FUNCTION  gitgutter#utility#is_active()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:50
Called 90 times
Total time:   0.055122
 Self time:   0.004712

count  total (s)   self (s)
   90   0.055031   0.004620   return g:gitgutter_enabled && gitgutter#utility#getbufvar(a:bufnr, 'enabled', 1) && !pumvisible() && s:is_file_buffer(a:bufnr) && s:exists_file(a:bufnr) && s:not_git_dir(a:bufnr)

FUNCTION  261()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/ui.vim:528
Called 40 times
Total time:   0.000057
 Self time:   0.000057

count  total (s)   self (s)
   40              0.000043     return '.. (up a dir)'

FUNCTION  262()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/event.vim:6
Called 1209 times
Total time:   0.016679
 Self time:   0.016679

count  total (s)   self (s)
 1209              0.004733     let newObj = copy(self)
 1209              0.002615     let newObj.nerdtree = a:nerdtree
 1209              0.002252     let newObj.subject = a:subject
 1209              0.002110     let newObj.action = a:action
 1209              0.001860     let newObj.params = a:params
 1209              0.001423     return newObj

FUNCTION  <SNR>61_abs_path()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:205
Called 350 times
Total time:   0.066321
 Self time:   0.066321

count  total (s)   self (s)
  350              0.054087   let p = resolve(expand('#'.a:bufnr.':p'))
                            
                              " Remove extra parts from fugitive's filepaths
  350              0.009631   let p = substitute(substitute(p, '^fugitive:', '', ''), '\v\.git/\x{40,}/', '', '')
                            
  350              0.001421   return a:shellesc ? gitgutter#utility#shellescape(p) : p

FUNCTION  CocActionAsync()
    Defined: ~/.vim/plugged/coc.nvim/plugin/coc.vim:82
Called 41 times
Total time:   0.012963
 Self time:   0.001497

count  total (s)   self (s)
   41   0.012869   0.001403   return s:AsyncRequest(a:name, a:000)

FUNCTION  265()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/notifier.vim:23
Called 1209 times
Total time:   0.009099
 Self time:   0.009099

count  total (s)   self (s)
 1209              0.004185     if !exists('s:refreshListenersMap')
                                    let s:refreshListenersMap = {}
 1209              0.000886     endif
 1209              0.001512     return s:refreshListenersMap

FUNCTION  <SNR>51_onGitStatusSuccessCB()
    Defined: ~/.vim/plugged/nerdtree-git-plugin/nerdtree_plugin/git_status.vim:161
Called 44 times
Total time:   0.119037
 Self time:   0.003628

count  total (s)   self (s)
   44              0.000348     if !exists('g:NTGitWorkdir') || g:NTGitWorkdir !=# a:job.opts.cwd
                                    call s:logger.debug(printf("git workdir has changed: '%s' -> '%s'", a:job.opts.cwd, get(g:, 'NTGitWorkdir', '')))
                                    return
   44              0.000023     endif
   44              0.000285     let l:output = join(a:job.chunks, '')
   44              0.000806     let l:lines = split(l:output, "\n")
   44   0.073379   0.000816     let l:cache = gitstatus#util#ParseGitStatusLines(a:job.opts.cwd, l:lines, g:)
                            
   44              0.000030     try
   44   0.001907   0.000421         call s:listener.SetNext(l:cache)
   44   0.041747   0.000387         call s:listener.TryUpdateNERDTreeUI()
                                catch
   44              0.000040     endtry

FUNCTION  airline#extensions#apply()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions.vim:71
Called 381 times
Total time:   0.047058
 Self time:   0.026308

count  total (s)   self (s)
  381              0.002008   let filetype_overrides = get(s:, 'filetype_overrides', {})
  381              0.002997   call extend(filetype_overrides, get(g:, 'airline_filetype_overrides', {}), 'force')
                            
  381   0.023864   0.004140   if s:is_excluded_window()
                                return -1
  381              0.000137   endif
                            
  381              0.000763   if &buftype == 'terminal'
                                let w:airline_section_x = ''
                                let w:airline_section_y = ''
  381              0.000166   endif
                            
  381              0.001251   if &previewwindow && empty(get(w:, 'airline_section_a', ''))
                                let w:airline_section_a = 'Preview'
                                let w:airline_section_b = ''
                                let w:airline_section_c = bufname(winbufnr(winnr()))
  381              0.000171   endif
                            
  381              0.002483   if has_key(filetype_overrides, &ft) && ((&filetype == 'help' && &buftype == 'help') || &filetype !~ 'help')
                                " for help files only override it, if the buftype is also of type 'help',
                                " else it would trigger when editing Vim help files
    2              0.000012     let args = filetype_overrides[&ft]
    2   0.001061   0.000035     call airline#extensions#apply_left_override(args[0], args[1])
  381              0.000242   endif
                            
  381              0.000503   if &buftype == 'help'
                                let w:airline_section_x = ''
                                let w:airline_section_y = ''
                                let w:airline_render_right = 1
  381              0.000164   endif
                            
  381              0.001476   for item in items(s:filetype_regex_overrides)
                                if match(&ft, item[0]) >= 0
                                  call airline#extensions#apply_left_override(item[1][0], item[1][1])
                                endif
  381              0.000401   endfor

FUNCTION  <SNR>166_is_modified_and_added()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:285
Called 76 times
Total time:   0.000303
 Self time:   0.000303

count  total (s)   self (s)
   76              0.000208   return a:from_count > 0 && a:to_count > 0 && a:from_count < a:to_count

FUNCTION  coc#highlight#match_ranges()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/highlight.vim:342
Called 7 times
Total time:   0.001641
 Self time:   0.001641

count  total (s)   self (s)
    7              0.000020   let winid = a:winid == 0 ? win_getid() : a:winid
    7              0.000019   let bufnr = a:bufnr == 0 ? winbufnr(winid) : a:bufnr
    7              0.000077   if empty(getwininfo(winid)) || (a:bufnr != 0 && winbufnr(a:winid) != a:bufnr)
                                " not valid
                                return []
    7              0.000003   endif
    7              0.000012   if !s:clear_match_by_window
                                let curr = win_getid()
                                if has('nvim')
                                  noa call nvim_set_current_win(winid)
                                else
                                  noa call win_gotoid(winid)
                                endif
    7              0.000003   endif
    7              0.000008   let ids = []
   15              0.000020   for range in a:ranges
    8              0.000008     let pos = []
    8              0.000015     let start = range['start']
    8              0.000011     let end = range['end']
   16              0.000038     for lnum in range(start['line'] + 1, end['line'] + 1)
    8              0.000028       let arr = getbufline(bufnr, lnum)
    8              0.000023       let line = empty(arr) ? '' : arr[0]
    8              0.000015       if empty(line)
                                    continue
    8              0.000004       endif
    8              0.000060       let colStart = lnum == start['line'] + 1 ? strlen(strcharpart(line, 0, start['character'])) + 1 : 1
    8              0.000043       let colEnd = lnum == end['line'] + 1 ? strlen(strcharpart(line, 0, end['character'])) + 1 : strlen(line) + 1
    8              0.000010       if colStart == colEnd
                                    continue
    8              0.000003       endif
    8              0.000034       call add(pos, [lnum, colStart, colEnd - colStart])
   16              0.000010     endfor
    8              0.000012     if !empty(pos)
    8              0.000027       let opts = s:clear_match_by_window ? {'window': a:winid} : {}
    8              0.000008       let i = 1
    8              0.000019       let l = []
   16              0.000018       for p in pos
    8              0.000014         call add(l, p)
    8              0.000008         if i % 8 == 0
                                      let id = matchaddpos(a:hlGroup, l, a:priority, -1, opts)
                                      call add(ids, id)
                                      let l = []
    8              0.000004         endif
    8              0.000016         let i += 1
   16              0.000008       endfor
    8              0.000017       if !empty(l)
    8              0.000244         let id = matchaddpos(a:hlGroup, l, a:priority, -1, opts)
    8              0.000021         call add(ids, id)
    8              0.000004       endif
    8              0.000003     endif
   15              0.000031   endfor
    7              0.000015   if !s:clear_match_by_window
                                if has('nvim')
                                  noa call nvim_set_current_win(curr)
                                else
                                  noa call win_gotoid(curr)
                                endif
    7              0.000003   endif
    7              0.000007   return ids

FUNCTION  coc#status()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc.vim:118
Called 2049 times
Total time:   0.127051
 Self time:   0.108960

count  total (s)   self (s)
 2049              0.021218   let info = get(b:, 'coc_diagnostic_info', {})
 2049              0.003398   let msgs = []
 2049              0.010539   if !empty(info) && get(info, 'error', 0)
                                call add(msgs, s:error_sign . info['error'])
 2049              0.002354   endif
 2049              0.006847   if !empty(info) && get(info, 'warning', 0)
 2035              0.013517     call add(msgs, s:warning_sign . info['warning'])
 2049              0.001373   endif
 2049   0.054270   0.036178   return s:trim(join(msgs, ' ') . ' ' . get(g:, 'coc_status', ''))

FUNCTION  <SNR>167_handle_double_hunk()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/sign.vim:212
Called 42 times
Total time:   0.000568
 Self time:   0.000568

count  total (s)   self (s)
   42              0.000306   if a:modified_lines[0:1] == [[1, 'removed_first_line'], [1, 'removed']]
                                return [[1, 'removed_above_and_below']] + a:modified_lines[2:]
   42              0.000025   endif
                            
   42              0.000060   return a:modified_lines

FUNCTION  airline#highlighter#get_highlight()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim:68
Called 47279 times
Total time:   9.359280
 Self time:   3.947224

count  total (s)   self (s)
                                " only check for the cterm reverse attribute
                                " TODO: do we need to check all modes (gui, term, as well)?
47279              0.714949     let reverse = synIDattr(synIDtrans(hlID(a:group)), 'reverse', 'cterm')
47279              0.169696     if get(g:, 'airline_highlighting_cache', 0) && has_key(s:hl_groups, a:group)
                                  let res = s:hl_groups[a:group]
                                  return reverse ? [ res[1], res[0], res[3], res[2], res[4] ] : res
47279              0.026392     else
47279   1.773644   0.390965       let ctermfg = s:get_syn(a:group, 'fg', 'cterm')
47279   1.633388   0.358524       let ctermbg = s:get_syn(a:group, 'bg', 'cterm')
47279   1.599860   0.347812       let guifg = s:get_syn(a:group, 'fg', 'gui')
47279   1.584273   0.345401       let guibg = s:get_syn(a:group, 'bg', 'gui')
47279              0.373947       let bold = synIDattr(synIDtrans(hlID(a:group)), 'bold')
47279              0.038859       if reverse
                                    let res = s:get_array(guibg, guifg, ctermbg, ctermfg, bold ? ['bold'] : a:000)
47279              0.024811       else
47279   0.701746   0.438152         let res = s:get_array(guifg, guibg, ctermfg, ctermbg, bold ? ['bold'] : a:000)
47279              0.027057       endif
47279              0.017922     endif
47279              0.219001     let s:hl_groups[a:group] = res
47279              0.035464     return res

FUNCTION  airline#util#shorten()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim:28
Called 1599 times
Total time:   0.052679
 Self time:   0.037871

count  total (s)   self (s)
 1599   0.034871   0.020064   if airline#util#winwidth() < a:winwidth && len(split(a:text, '\zs')) > a:minwidth
                                if get(a:000, 0, 0)
                                  " shorten from tail
                                  return '…'.matchstr(a:text, '.\{'.a:minwidth.'}$')
                                else
                                  " shorten from beginning of string
                                  return matchstr(a:text, '^.\{'.a:minwidth.'}').'…'
                                endif
 1599              0.000754   else
 1599              0.001538     return a:text
                              endif

FUNCTION  <SNR>169_is_parent_element()
    Defined: ~/.vim/plugged/vim-jsx-pretty/autoload/jsx_pretty/indent.vim:103
Called 38 times
Total time:   0.010200
 Self time:   0.001196

count  total (s)   self (s)
   38   0.009287   0.000528   let syntax_stack = s:syntax_stack_at(a:pos[0], a:pos[1])
   38   0.000864   0.000620   return s:is_opening_tag(syntax_stack[-1]) && count(syntax_stack, 'jsxElement') <= a:element_count

FUNCTION  270()
    Defined: ~/.vim/plugged/nerdtree-git-plugin/autoload/gitstatus/log.vim:24
Called 44 times
Total time:   0.001064
 Self time:   0.001064

count  total (s)   self (s)
   44              0.000743     if a:level < self.level
   44              0.000067         return
                                endif
                                echomsg '[nerdtree-git-status] ' . a:msg

FUNCTION  271()
    Defined: ~/.vim/plugged/nerdtree-git-plugin/autoload/gitstatus/log.vim:31
Called 44 times
Total time:   0.006090
 Self time:   0.005027

count  total (s)   self (s)
   44   0.005812   0.004748     echohl LineNr | call self.output(s:debug, a:msg) | echohl None

FUNCTION  airline#extensions#coc#get_current_function()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/coc.vim:51
Called 522 times
Total time:   0.002576
 Self time:   0.002576

count  total (s)   self (s)
  522              0.002015   return get(b:, 'coc_current_function', '')

FUNCTION  <SNR>91_is_excluded_window()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions.vim:111
Called 381 times
Total time:   0.019724
 Self time:   0.019724

count  total (s)   self (s)
  381              0.001092   for matchft in g:airline_exclude_filetypes
                                if matchft ==# &ft
                                  return 1
                                endif
  381              0.000503   endfor
                            
 1524              0.002119   for matchw in g:airline_exclude_filenames
 1143              0.008568     if matchstr(expand('%'), matchw) ==# matchw
                                  return 1
 1143              0.000460     endif
 1524              0.000922   endfor
                            
  381              0.000634   if g:airline_exclude_preview && &previewwindow
                                return 1
  381              0.000171   endif
                            
  381              0.000272   return 0

FUNCTION  278()
    Defined: ~/.vim/plugged/nerdtree-git-plugin/autoload/gitstatus/listener.vim:35
Called 1209 times
Total time:   0.303335
 Self time:   0.040235

count  total (s)   self (s)
 1209              0.002606     let l:path = a:event.subject
 1209   0.251216   0.009692     let l:indicator = self.getIndicatorByPath(l:path)
 1209   0.014732   0.007968     call l:path.flagSet.clearFlags('git')
 1209              0.002181     if l:indicator !=# ''
  505   0.007144   0.004445         if gitstatus#shouldConceal()
                                        let l:indicator = printf(' %s ', l:indicator)
  505              0.000463         endif
  505   0.016188   0.004074         call l:path.flagSet.addFlag('git', l:indicator)
 1209              0.000666     endif

FUNCTION  coc#util#set_buf_var()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/util.vim:852
Called 4 times
Total time:   0.000166
 Self time:   0.000166

count  total (s)   self (s)
    4              0.000084   if !bufloaded(a:bufnr) | return | endif
    4              0.000067   call setbufvar(a:bufnr, a:name, a:val)

FUNCTION  coc#float#nvim_refresh_scrollbar()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/float.vim:781
Called 115 times
Total time:   0.005696
 Self time:   0.003239

count  total (s)   self (s)
  115   0.004681   0.002224   let id = coc#float#get_related(a:winid, 'scrollbar')
  115              0.000377   if id && nvim_win_is_valid(id)
                                call coc#float#nvim_scrollbar(a:winid)
  115              0.000084   endif

FUNCTION  241()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/ui.vim:278
Called 40 times
Total time:   0.000146
 Self time:   0.000146

count  total (s)   self (s)
   40              0.000081     return self._showHelp

FUNCTION  242()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/ui.vim:283
Called 3000 times
Total time:   0.003378
 Self time:   0.003378

count  total (s)   self (s)
 3000              0.002540     return self._showHidden

FUNCTION  243()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/ui.vim:288
Called 8 times
Total time:   0.000184
 Self time:   0.000176

count  total (s)   self (s)
                                " Replace multi-character DirArrows with a single space so the
                                " indentation calculation doesn't get messed up.
    8              0.000013     if g:NERDTreeDirArrowExpandable ==# ''
                                    let l:line = '  '.a:line
    8              0.000004     else
    8              0.000064         let l:line = substitute(substitute(a:line, '\V'.g:NERDTreeDirArrowExpandable, ' ', ''), '\V'.g:NERDTreeDirArrowCollapsible, ' ', '')
    8              0.000004     endif
    8              0.000037     let leadChars = match(l:line, '\M\[^ ]')
    8   0.000040   0.000033     return leadChars / s:UI.IndentWid()

FUNCTION  280()
    Defined: ~/.vim/plugged/nerdtree-git-plugin/autoload/gitstatus/listener.vim:65
Called 44 times
Total time:   0.001486
 Self time:   0.001486

count  total (s)   self (s)
   44              0.001421     let self.next = a:cache

FUNCTION  282()
    Defined: ~/.vim/plugged/nerdtree-git-plugin/autoload/gitstatus/listener.vim:73
Called 41 times
Total time:   0.000339
 Self time:   0.000339

count  total (s)   self (s)
   41              0.000307     return self.current !=# self.next

FUNCTION  coc#rpc#notify()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/rpc.vim:96
Called 1121 times
Total time:   0.144581
 Self time:   0.028538

count  total (s)   self (s)
 1121   0.022148   0.010641   if !coc#rpc#ready()
                                return ''
 1121              0.000530   endif
 1121   0.118102   0.013565   call s:client['notify'](a:method, a:args)
 1121              0.001352   return ''

FUNCTION  <SNR>166_is_removed()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:277
Called 126 times
Total time:   0.000381
 Self time:   0.000381

count  total (s)   self (s)
  126              0.000242   return a:from_count > 0 && a:to_count == 0

FUNCTION  airline#extensions#hunks#get_hunks()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/hunks.vim:95
Called 522 times
Total time:   0.167186
 Self time:   0.082900

count  total (s)   self (s)
  522              0.002148   if !get(w:, 'airline_active', 0)
    1              0.000001     return ''
  521              0.000282   endif
                              " Cache values, so that it isn't called too often
  521   0.013674   0.010773   if exists("b:airline_hunks") && get(b:,  'airline_changenr', 0) == b:changedtick && airline#util#winwidth() == get(s:, 'airline_winwidth', 0) && get(b:, 'source_func', '') isnot# 's:get_hunks_signify' && get(b:, 'source_func', '') isnot# 's:get_hunks_gitgutter' && get(b:, 'source_func', '') isnot# 's:get_hunks_empty' && get(b:, 'source_func', '') isnot# 's:get_hunks_changes' && get(b:, 'source_func', '') isnot# 's:get_hunks_coc'
                                return b:airline_hunks
  521              0.000252   endif
  521   0.070716   0.007121   let hunks = airline#extensions#hunks#get_raw_hunks()
  521              0.000666   let string = ''
  521   0.007987   0.005205   let winwidth = get(airline#parts#get('hunks'), 'minwidth', 100)
  521              0.000998   if !empty(hunks)
                                " hunks should contain [added, changed, deleted]
 2084              0.003306     for i in [0, 1, 2]
 1563   0.025061   0.014584       if (s:non_zero_only == 0 && airline#util#winwidth() > winwidth) || hunks[i] > 0
 1563              0.009401         let string .= printf('%s%s ', s:hunk_symbols[i], hunks[i])
 1563              0.001013       endif
 2084              0.001678     endfor
  521              0.000275   endif
  521   0.009795   0.008512   if index(airline#extensions#get_loaded_extensions(), 'branch') == -1 && string[-1:] == ' '
                                " branch extension not loaded, skip trailing whitespace
  521              0.001209     let string = string[0:-2]
  521              0.000261   endif
                            
  521              0.001167   let b:airline_hunks = string
  521              0.000909   let b:airline_changenr = b:changedtick
  521   0.007359   0.004110   let s:airline_winwidth = airline#util#winwidth()
  521              0.000504   return string

FUNCTION  coc#float#valid()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/float.vim:173
Called 26 times
Total time:   0.000338
 Self time:   0.000338

count  total (s)   self (s)
   26              0.000039   if a:winid <= 0
                                return 0
   26              0.000019   endif
   26              0.000056   if has('nvim')
   26              0.000145     return nvim_win_is_valid(a:winid) ? 1 : 0
                              endif
                              return s:popup_visible(a:winid)

FUNCTION  <SNR>51_onGitWorkdirSuccessCB()
    Defined: ~/.vim/plugged/nerdtree-git-plugin/nerdtree_plugin/git_status.vim:114
Called 1 time
Total time:   0.003799
 Self time:   0.000055

count  total (s)   self (s)
    1              0.000017     let g:NTGitWorkdir = split(join(a:job.chunks, ''), "\n")[0]
    1   0.000056   0.000013     call s:logger.debug(printf("'%s' is in a git repo: '%s'", a:job.opts.cwd, g:NTGitWorkdir))
    1   0.000368   0.000007     call s:enableLiveUpdate()
                            
    1   0.003354   0.000015     call s:refreshGitStatus('init', g:NTGitWorkdir)

FUNCTION  coc#highlight#highlight_lines()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/highlight.vim:282
Called 26 times
Total time:   0.378227
 Self time:   0.007590

count  total (s)   self (s)
   26              0.000073   let currwin = win_getid()
   26              0.000081   let switch = has('nvim') && currwin != a:winid
   26              0.000017   if switch
   26              0.000977     noa call nvim_set_current_win(a:winid)
   26              0.000021   endif
   26              0.000065   let defined = []
   26              0.000033   let region_id = 1
   52              0.000104   for config in a:blocks
   26              0.000068     let start = config['startLine'] + 1
   26              0.000154     let end = config['endLine'] == -1 ? len(getbufline(winbufnr(a:winid), 1, '$')) + 1 : config['endLine'] + 1
   26              0.000080     let filetype = get(config, 'filetype', '')
   26              0.000059     let hlGroup = get(config, 'hlGroup', '')
   26              0.000061     if !empty(hlGroup)
                                  call s:execute(a:winid, 'syntax region '.hlGroup.' start=/\%'.start.'l/ end=/\%'.end.'l/')
   26              0.000017     else
   26              0.000310       let filetype = matchstr(filetype, '\v^\w+')
   26              0.000164       if empty(filetype) || filetype == 'txt' || index(get(g:, 'coc_markdown_disabled_languages', []), filetype) != -1
                                    continue
   26              0.000013       endif
   26              0.000067       if index(defined, filetype) == -1
   26   0.370478   0.000517         call s:execute(a:winid, 'syntax include @'.toupper(filetype).' syntax/'.filetype.'.vim')
   26              0.000102         if has('nvim')
   26              0.000046           unlet! b:current_syntax
                                    elseif exists('*win_execute')
                                      call win_execute(a:winid, 'unlet! b:current_syntax')
   26              0.000014         endif
   26              0.000107         call add(defined, filetype)
   26              0.000039       endif
   26   0.001222   0.000546       call s:execute(a:winid, 'syntax region CodeBlock'.region_id.' start=/\%'.start.'l/ end=/\%'.end.'l/ contains=@'.toupper(filetype).' keepend')
   26              0.000055       let region_id = region_id + 1
   26              0.000014     endif
   52              0.000218   endfor
   26              0.000027   if switch
   26              0.002053     noa call nvim_set_current_win(currwin)
   26              0.000031   endif

FUNCTION  294()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/builder.vim:17
Called 1865 times
Total time:   0.007952
 Self time:   0.007952

count  total (s)   self (s)
 1865              0.007072   call add(self._sections, [a:group, a:contents])

FUNCTION  299()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/builder.vim:62
Called 381 times
Total time:   2.571879
 Self time:   0.270766

count  total (s)   self (s)
  381              0.000539   let side = 1
  381              0.000353   let line = ''
  381              0.000347   let i = 0
  381              0.001065   let length = len(self._sections)
  381              0.000432   let split = 0
  381              0.000478   let is_empty = 0
  381              0.000666   let prev_group = ''
                            
 2627              0.004175   while i < length
 2246              0.005564     let section = self._sections[i]
 2246              0.004284     let group = section[0]
 2246              0.004143     let contents = section[1]
 2246              0.003306     let pgroup = prev_group
 2246   0.058512   0.029494     let prev_group = airline#builder#get_prev_group(self._sections, i)
 2246              0.006572     if group ==# 'airline_c' && &buftype ==# 'terminal' && self._context.active
                                  let group = 'airline_term'
 2246              0.007103     elseif group ==# 'airline_c' && !self._context.active && has_key(self._context, 'bufnr')
  113              0.000277       let group = 'airline_c'. self._context.bufnr
 2133              0.006275     elseif prev_group ==# 'airline_c' && !self._context.active && has_key(self._context, 'bufnr')
  113              0.000277       let prev_group = 'airline_c'. self._context.bufnr
 2246              0.001473     endif
 2246              0.001774     if is_empty
                                  let prev_group = pgroup
 2246              0.001009     endif
 2246   0.047553   0.025346     let is_empty = s:section_is_empty(self, contents)
                            
 2246              0.001928     if is_empty
                                  " need to fix highlighting groups, since we
                                  " have skipped a section, we actually need
                                  " the previous previous group and so the
                                  " seperator goes from the previous previous group
                                  " to the current group
                                  let pgroup = group
 2246              0.001143     endif
                            
 2246              0.002942     if group == ''
                                  let line .= contents
 2246              0.002590     elseif group == '|'
  381              0.000370       let side = 0
  381              0.000848       let line .= contents
  381              0.000323       let split = 1
 1865              0.000987     else
 1865              0.002378       if prev_group == ''
  381              0.001429         let line .= '%#'.group.'#'
 1484              0.001246       elseif split
  266              0.000206         if !is_empty
  266   0.282469   0.004477           let line .= s:get_transitioned_seperator(self, prev_group, group, side)
  266              0.000196         endif
  266              0.000344         let split = 0
 1218              0.000613       else
 1218              0.001133         if !is_empty
 1218   1.884128   0.018710           let line .= s:get_seperator(self, prev_group, group, side)
 1218              0.000845         endif
 1865              0.001142       endif
 1865   0.136249   0.029773       let line .= is_empty ? '' : s:get_accented_line(self, group, contents)
 2246              0.001362     endif
                            
 2246              0.003383     let i = i + 1
 2627              0.004902   endwhile
                            
  381              0.000589   if !self._context.active
                                "let line = substitute(line, '%#airline_c#', '%#airline_c'.self._context.bufnr.'#', '')
  265              0.014275     let line = substitute(line, '%#.\{-}\ze#', '\0_inactive', 'g')
  381              0.000296   endif
  381              0.000526   return line

FUNCTION  gitgutter#utility#getbufvar()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:21
Called 1147 times
Total time:   0.018443
 Self time:   0.018443

count  total (s)   self (s)
 1147              0.006446   let ggvars = getbufvar(a:buffer, 'gitgutter')
 1147              0.007056   if type(ggvars) == type({}) && has_key(ggvars, a:varname)
 1024              0.002407     return ggvars[a:varname]
  123              0.000094   endif
  123              0.000137   if a:0
  123              0.000121     return a:1
                              endif

FUNCTION  <SNR>5_get_shiftwidth()
    Defined: ~/.config/nvim/autoload/plugged/vim-polyglot/autoload/polyglot/init.vim:2774
Called 4 times
Total time:   0.000919
 Self time:   0.000919

count  total (s)   self (s)
    4              0.000006     let shiftwidth = 0
    4              0.000004     let max_count = 0
    4              0.000006     let final_counts = {}
   24              0.000054     for [indent, indent_count] in items(a:indents)
   20              0.000030       let indent_count = indent_count * 1.5
  120              0.000214       for [indent2, indent2_count] in items(a:indents)
  100              0.000153         if indent2 > indent && indent2 % indent == 0
   20              0.000025           let indent_count = indent_count + indent2_count
  100              0.000038         endif
  120              0.000040       endfor
   20              0.000035       let final_counts[indent] = indent_count
   24              0.000015     endfor
   24              0.000043     for [indent, final_count] in items(final_counts)
   20              0.000019       if final_count > max_count
    4              0.000005         let shiftwidth = indent
    4              0.000005         let max_count = final_count
   20              0.000008       endif
   24              0.000011     endfor
    4              0.000005     return shiftwidth

FUNCTION  218()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/nerdtree.vim:100
Called 162 times
Total time:   0.000571
 Self time:   0.000571

count  total (s)   self (s)
  162              0.000436     return exists('b:NERDTree')

FUNCTION  <SNR>122_close_win()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/float.vim:1527
Called 26 times
Total time:   0.014837
 Self time:   0.001496

count  total (s)   self (s)
   26              0.000041   if a:winid <= 0
                                return
   26              0.000012   endif
                              " vim not throw for none exists winid
   26              0.000038   if s:is_vim
                                call popup_close(a:winid)
   26              0.000014   else
   26              0.000092     if nvim_win_is_valid(a:winid)
   26   0.014484   0.001143       call nvim_win_close(a:winid, 1)
   26              0.000018     endif
   26              0.000010   endif

FUNCTION  <SNR>61_winshell()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:68
Called 43 times
Total time:   0.000585
 Self time:   0.000585

count  total (s)   self (s)
   43              0.000526   return &shell =~? 'cmd' || exists('+shellslash') && !&shellslash

FUNCTION  airline#extensions#nvimlsp#get_warning()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/nvimlsp.vim:38
Called 522 times
Total time:   0.049023
 Self time:   0.006794

count  total (s)   self (s)
  522   0.048594   0.006365   return airline#extensions#nvimlsp#get('Warning')

FUNCTION  airline#highlighter#reset_hlcache()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim:64
Called 7 times
Total time:   0.018427
 Self time:   0.018427

count  total (s)   self (s)
    7              0.018412     let s:hl_groups = {}

FUNCTION  airline#util#prepend()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim:63
Called 3132 times
Total time:   0.020686
 Self time:   0.020686

count  total (s)   self (s)
 3132              0.007191   if a:minwidth > 0 && airline#util#winwidth() < a:minwidth
                                return ''
 3132              0.001329   endif
 3132              0.007853   return empty(a:text) ? '' : a:text.s:spc.g:airline_right_alt_sep.s:spc

FUNCTION  coc#_do_complete()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc.vim:63
Called 88 times
Total time:   0.006860
 Self time:   0.006860

count  total (s)   self (s)
   88              0.004568   let g:coc#_context = { 'start': a:start, 'candidates': a:items, 'preselect': a:preselect}
   88              0.001176   if mode() =~# 'i' && &paste != 1
   87              0.000742     call feedkeys("\<Plug>CocRefresh", 'i')
   88              0.000106   endif

FUNCTION  coc#highlight#update_highlights()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/highlight.vim:76
Called 59 times
Total time:   0.054435
 Self time:   0.026321

count  total (s)   self (s)
   59              0.000535   if !bufloaded(a:bufnr)
                                return
   59              0.000071   endif
   59              0.000397   let start = get(a:, 1, 0)
   59              0.000166   let end = get(a:, 2, -1)
   59              0.000178   if empty(a:highlights)
                                call coc#highlight#clear_highlight(a:bufnr, a:key, start, end)
                                return
   59              0.000030   endif
   59              0.000171   let total = len(a:highlights)
                              " index list that exists with current highlights
   59              0.000115   let exists = []
   59   0.001794   0.000830   let ns = coc#highlight#create_namespace(a:key)
   59              0.000088   let currIndex = 0
   59              0.000361   if has('nvim-0.5.0') || exists('*prop_list')
   59   0.015763   0.001243     let current = coc#highlight#get(a:bufnr, a:key, start, end)
  138   0.001664   0.001647     for lnum in sort(map(keys(current), 'str2nr(v:val)'), {a, b -> a - b})
   79              0.000307       let items = current[lnum]
   79              0.000126       let indexes = []
   79              0.000117       let nextIndex = currIndex
   79              0.000107       if currIndex != total
  230              0.000266         for item in items
  452              0.000836           for i in range(currIndex, total - 1)
  342              0.000591             let hi = a:highlights[i]
  342              0.000710             if hi['lnum'] > item['lnum']
   42              0.000055               let nextIndex = i
   42              0.000026               break
  300              0.000131             endif
  300   0.011609   0.003224             if coc#helper#obj_equal(item, hi)
  250              0.000582               call add(indexes, i)
  250              0.000926               let nextIndex = max([nextIndex, i + 1])
  300              0.000205             endif
  452              0.000281           endfor
  230              0.000147         endfor
   79              0.000037       endif
   79              0.000100       let currIndex = nextIndex
                                  " all highlights of current line exists, not clear.
   79              0.000242       if len(indexes) == len(items)
   26              0.000071         let exists = exists + indexes
   53              0.000037       else
   53              0.000148         if has('nvim')
   53              0.000659           call nvim_buf_clear_namespace(a:bufnr, ns, lnum, lnum + 1)
                                    else
                                      call coc#api#call('buf_clear_namespace', [a:bufnr, ns, lnum, lnum + 1])
   53              0.000031         endif
   79              0.000037       endif
  138              0.000342     endfor
                              else
                                call coc#highlight#clear_highlight(a:bufnr, a:key, start, end)
   59              0.000034   endif
  216              0.000363   for i in range(0, total - 1)
  157              0.000398     if index(exists, i) == -1
  107              0.000206       let hi = a:highlights[i]
  107   0.005744   0.001515       call coc#highlight#add_highlight(a:bufnr, ns, hi['hlGroup'], hi['lnum'], hi['colStart'], hi['colEnd'])
  157              0.000092     endif
  216              0.000156   endfor

FUNCTION  140()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/tree_dir_node.vim:141
Called 80 times
Total time:   0.137926
 Self time:   0.000796

count  total (s)   self (s)
   80   0.137728   0.000599     if !self.isCascadable()
   80              0.000113         return [self]
                                endif
                            
                                let vc = self.getVisibleChildren()
                                let visChild = vc[0]
                            
                                return [self] + visChild.getCascade()

FUNCTION  coc#float#nvim_scrollbar()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/float.vim:357
Called 26 times
Total time:   0.005470
 Self time:   0.002685

count  total (s)   self (s)
   26   0.000686   0.000348   if !has('nvim-0.4.0') || !coc#float#valid(a:winid) || getwinvar(a:winid, 'target_winid', 0)
                                return
   26              0.000010   endif
   26              0.000258   let config = nvim_win_get_config(a:winid)
   26              0.000134   let [row, column] = nvim_win_get_position(a:winid)
   26              0.000031   let relative = 'editor'
   26              0.000033   if row == 0 && column == 0
                                " fix bad value when ext_multigrid is enabled. https://github.com/neovim/neovim/issues/11935
                                let [row, column] = [config.row, config.col]
                                let relative = config.relative
   26              0.000012   endif
   26              0.000089   let width = nvim_win_get_width(a:winid)
   26              0.000070   let height = nvim_win_get_height(a:winid)
   26              0.000061   let bufnr = winbufnr(a:winid)
   26              0.000155   let cw = getwinvar(a:winid, '&foldcolumn', 0) ? width - 1 : width
   26   0.001938   0.000390   let ch = coc#float#content_height(bufnr, cw, getwinvar(a:winid, '&wrap'))
   26   0.000803   0.000286   let closewin = coc#float#get_related(a:winid, 'close')
   26              0.000098   let border = getwinvar(a:winid, 'border', [])
   26              0.000066   let move_down = closewin && !get(border, 0, 0)
   26              0.000025   if move_down
                                let height = height - 1
   26              0.000013   endif
   26   0.000562   0.000180   let id = coc#float#get_related(a:winid, 'scrollbar')
   26              0.000039   if ch <= height || height <= 0
                                " no scrollbar, remove exists
   26              0.000019     if id
                                  call s:close_win(id)
   26              0.000014     endif
   26              0.000015     return
                              endif
                              call coc#float#close_related(a:winid, 'pad')
                              let sbuf = id ? winbufnr(id) : 0
                              let sbuf = coc#float#create_buf(sbuf, repeat([' '], height))
                              let opts = { 'row': move_down ? row + 1 : row, 'col': column + width, 'relative': relative, 'width': 1, 'height': height, 'focusable': v:false, 'style': 'minimal', }
                              if id
                                call nvim_win_set_config(id, opts)
                              else
                                noa let id = nvim_open_win(sbuf, 0 , opts)
                                if id == 0
                                  return
                                endif
                                call setwinvar(id, 'kind', 'scrollbar')
                                call setwinvar(id, 'target_winid', a:winid)
                              endif
                              let thumb_height = max([1, float2nr(floor(height * (height + 0.0)/ch))])
                              let wininfo = getwininfo(a:winid)[0]
                              let start = 0
                              if wininfo['topline'] != 1
                                " needed for correct getwininfo
                                let firstline = wininfo['topline']
                                let lastline = s:nvim_get_botline(firstline, height, cw, bufnr)
                                let linecount = nvim_buf_line_count(winbufnr(a:winid))
                                if lastline >= linecount
                                  let start = height - thumb_height
                                else
                                  let start = max([1, float2nr(round((height - thumb_height + 0.0)*(firstline - 1.0)/(ch - height)))])
                                endif
                              endif
                              " add highlights
                              call nvim_buf_clear_namespace(sbuf, -1, 0, -1)
                              for idx in range(0, height - 1)
                                if idx >= start && idx < start + thumb_height
                                  call nvim_buf_add_highlight(sbuf, -1, 'PmenuThumb', idx, 0, 1)
                                else
                                  call nvim_buf_add_highlight(sbuf, -1, 'PmenuSbar', idx, 0, 1)
                                endif
                              endfor
                              call s:add_related(id, a:winid)

FUNCTION  <SNR>102_check_mixed_indent()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/whitespace.vim:17
Called 11 times
Total time:   0.001919
 Self time:   0.001919

count  total (s)   self (s)
   11              0.000094   let indent_algo = get(g:, 'airline#extensions#whitespace#mixed_indent_algo', 0)
   11              0.000013   if indent_algo == 1
                                " [<tab>]<space><tab>
                                " spaces before or between tabs are not allowed
                                let t_s_t = '(^\t* +\t\s*\S)'
                                " <tab>(<space> x count)
                                " count of spaces at the end of tabs should be less than tabstop value
                                let t_l_s = '(^\t+ {' . &ts . ',}' . '\S)'
                                return search('\v' . t_s_t . '|' . t_l_s, 'nw')
   11              0.000012   elseif indent_algo == 2
                                return search('\v(^\t* +\t\s*\S)', 'nw', 0, 500)
   11              0.000005   else
   11              0.001652     return search('\v(^\t+ +)|(^ +\t+)', 'nw', 0, 500)
                              endif

FUNCTION  <SNR>110_section_is_empty()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/builder.vim:182
Called 2246 times
Total time:   0.022207
 Self time:   0.022207

count  total (s)   self (s)
 2246              0.003433   let start=1
                            
                              " do not check for inactive windows or the tabline
 2246              0.003735   if a:self._context.active == 0
 1212              0.000981     return 0
 1034              0.002727   elseif get(a:self._context, 'tabline', 0)
                                return 0
 1034              0.000559   endif
                            
                              " only check, if airline#skip_empty_sections == 1
 1034              0.002693   if get(g:, 'airline_skip_empty_sections', 0) == 0
 1034              0.000702     return 0
                              endif
                            
                              " only check, if airline#skip_empty_sections == 1
                              if get(w:, 'airline_skip_empty_sections', -1) == 0
                                return 0
                              endif
                              " assume accents sections to be never empty
                              " (avoides, that on startup the mode message becomes empty)
                              if match(a:content, '%#__accent_[^#]*#.*__restore__#') > -1
                                return 0
                              endif
                              if empty(a:content)
                                return 1
                              endif
                              let list=matchlist(a:content, '%{\zs.\{-}\ze}', 1, start)
                              if empty(list)
                                return 0 " no function in statusline text
                              endif
                              while len(list) > 0
                                let expr = list[0]
                                try
                                  " catch all exceptions, just in case
                                  if !empty(eval(expr))
                                    return 0
                                  endif
                                catch
                                  return 0
                                endtry
                                let start += 1
                                let list=matchlist(a:content, '%{\zs.\{-}\ze}', 1, start)
                              endw
                              return 1

FUNCTION  <SNR>111_get_section()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/default.vim:20
Called 2626 times
Total time:   0.135164
 Self time:   0.113028

count  total (s)   self (s)
 2626              0.007578   if has_key(s:section_truncate_width, a:key)
 1483   0.026117   0.015096     if airline#util#winwidth(a:winnr) < s:section_truncate_width[a:key]
                                  return ''
 1483              0.000789     endif
 2626              0.001063   endif
 2626              0.004278   let spc = g:airline_symbols.space
 2626              0.011605   if !exists('g:airline_section_{a:key}')
                                return ''
 2626              0.001005   endif
 2626   0.041890   0.030776   let text = airline#util#getwinvar(a:winnr, 'airline_section_'.a:key, g:airline_section_{a:key})
 2626              0.018263   let [prefix, suffix] = [get(a:000, 0, '%('.spc), get(a:000, 1, spc.'%)')]
 2626              0.009865   return empty(text) ? '' : prefix.text.suffix

FUNCTION  airline#util#getbufvar()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim:71
Called 498 times
Total time:   0.001864
 Self time:   0.001864

count  total (s)   self (s)
  498              0.001678     return getbufvar(a:bufnr, a:key, a:def)

FUNCTION  <SNR>165_syn_name()
    Defined: ~/.vim/plugged/vim-jsx-pretty/autoload/jsx_pretty/comment.vim:28
Called 114 times
Total time:   0.027534
 Self time:   0.027534

count  total (s)   self (s)
  114              0.026737   let syn_id = get(synstack(a:lnum, a:cnum), -1)
  114              0.000612   return synIDattr(syn_id, "name")

FUNCTION  <SNR>169_syntax_stack_at()
    Defined: ~/.vim/plugged/vim-jsx-pretty/autoload/jsx_pretty/indent.vim:21
Called 66 times
Total time:   0.011011
 Self time:   0.011011

count  total (s)   self (s)
   66              0.010962   return map(synstack(a:lnum, a:col), 'synIDattr(v:val, "name")')

FUNCTION  <SNR>169_is_opening_tag()
    Defined: ~/.vim/plugged/vim-jsx-pretty/autoload/jsx_pretty/indent.vim:52
Called 80 times
Total time:   0.000456
 Self time:   0.000456

count  total (s)   self (s)
   80              0.000407   return a:syntax =~? 'jsxOpenPunct'

FUNCTION  264()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/notifier.vim:14
Called 1209 times
Total time:   1.094906
 Self time:   0.087538

count  total (s)   self (s)
 1209   0.028090   0.011411     let event = g:NERDTreeEvent.New(a:nerdtree, a:path, a:event, a:params)
                            
 3627   0.036790   0.014508     for Listener in s:Notifier.GetListenersForEvent(a:event)
 2418              0.021157         let l:Callback = type(Listener) == type(function('tr')) ? Listener : function(Listener)
 2418   0.993353   0.024946         call l:Callback(event)
 3627              0.003705     endfor

FUNCTION  gitstatus#util#ParseGitStatusLines()
    Defined: ~/.vim/plugged/nerdtree-git-plugin/autoload/gitstatus/util.vim:86
Called 44 times
Total time:   0.072563
 Self time:   0.026509

count  total (s)   self (s)
   44              0.000113     let l:result = {}
   44              0.000058     let l:is_rename = 0
  654              0.000846     for l:line in a:statusLines
  610              0.000449         if l:is_rename
                                        call gitstatus#util#UpdateParentDirsStatus(l:result, a:root, a:root . '/' . l:line, 'Dirty', a:opts)
                                        let l:is_rename = 0
                                        continue
  610              0.000242         endif
  610   0.032440   0.006816         let [l:pathStr, l:statusKey] = gitstatus#util#ParseGitStatusLine(l:line, a:opts)
                            
  610              0.001450         let l:pathStr = a:root . '/' . l:pathStr
  610              0.001106         if l:pathStr[-1:-1] is# '/'
                                        let l:pathStr = l:pathStr[:-2]
  610              0.000247         endif
  610              0.000985         let l:is_rename = l:statusKey is# 'Renamed'
  610              0.001587         let l:result[l:pathStr] = l:statusKey
                            
  610   0.028303   0.007872         call gitstatus#util#UpdateParentDirsStatus(l:result, a:root, l:pathStr, l:statusKey, a:opts)
  654              0.000463     endfor
   44              0.000071     return l:result

FUNCTION  airline#extensions#get_loaded_extensions()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions.vim:505
Called 521 times
Total time:   0.001283
 Self time:   0.001283

count  total (s)   self (s)
  521              0.000930   return s:loaded_ext

FUNCTION  <SNR>61_is_file_buffer()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:63
Called 90 times
Total time:   0.001051
 Self time:   0.001051

count  total (s)   self (s)
   90              0.000927   return empty(getbufvar(a:bufnr, '&buftype'))

FUNCTION  gitgutter#diff#process_hunks()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:231
Called 42 times
Total time:   0.035157
 Self time:   0.002286

count  total (s)   self (s)
   42              0.000103   let modified_lines = []
  168              0.000206   for hunk in a:hunks
  126   0.034485   0.001613     call extend(modified_lines, s:process_hunk(a:bufnr, hunk))
  168              0.000120   endfor
   42              0.000041   return modified_lines

FUNCTION  <SNR>51_onFileUpdate()
    Defined: ~/.vim/plugged/nerdtree-git-plugin/nerdtree_plugin/git_status.vim:209
Called 3 times
Total time:   0.016585
 Self time:   0.000644

count  total (s)   self (s)
    3              0.000030     let l:fname = s:is_win ? substitute(a:fname, '\', '/', 'g') : a:fname
    3   0.000131   0.000092     if !exists('g:NTGitWorkdir') || !s:hasPrefix(l:fname, g:NTGitWorkdir)
                                    return
    3              0.000004     endif
    3   0.015719   0.000203     let l:job = s:refreshGitStatus('file-update', g:NTGitWorkdir)
    3   0.000673   0.000288     call s:logger.debug('run file-update job: ' . l:job.id)

FUNCTION  airline#builder#new()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/builder.vim:229
Called 381 times
Total time:   0.012429
 Self time:   0.012429

count  total (s)   self (s)
  381              0.002921   let builder = copy(s:prototype)
  381              0.000895   let builder._context = a:context
  381              0.000613   let builder._sections = []
                            
  381              0.006738   call extend(builder._context, { 'left_sep': g:airline_left_sep, 'left_alt_sep': g:airline_left_alt_sep, 'right_sep': g:airline_right_sep, 'right_alt_sep': g:airline_right_alt_sep, }, 'keep')
  381              0.000459   return builder

FUNCTIONS SORTED ON TOTAL TIME
count  total (s)   self (s)  function
14596  11.660243   0.756705  <SNR>97_exec_separator()
  524  11.382767   0.068197  airline#check_mode()
   29  11.292424   0.619954  airline#highlighter#highlight()
  301  10.142156   0.005498  airline#update_tabline()
  301  10.136270             airline#extensions#tabline#redraw()
47279   9.359280   3.947224  airline#highlighter#get_highlight()
  103   7.249741   5.668507  coc#_complete()
29192   6.669625   0.440952  airline#themes#get_highlight()
189116   5.148463             <SNR>97_get_syn()
15651   4.628345   1.431355  airline#highlighter#exec()
   26   3.113953   2.672593  coc#float#create_pum_float()
  117   3.054927   0.011496  airline#update_statusline()
  381   3.002394   0.028288  <SNR>93_invoke_funcrefs()
  110   2.947159   0.007751  <SNR>67_on_window_changed()
  381   2.571879   0.270766  299()
  156   2.265546   0.011579  162()
 1218   1.865418   0.036726  <SNR>110_get_seperator()
   41   1.743395   0.007870  <SNR>59_CursorHoldUpdate()
    7   1.725592   0.000657  <SNR>67_on_focus_gained()
    7   1.724441   0.000932  <SNR>67_airline_refresh()

FUNCTIONS SORTED ON SELF TIME
count  total (s)   self (s)  function
  301             10.136270  airline#extensions#tabline#redraw()
  103   7.249741   5.668507  coc#_complete()
189116              5.148463  <SNR>97_get_syn()
47279   9.359280   3.947224  airline#highlighter#get_highlight()
   26   3.113953   2.672593  coc#float#create_pum_float()
15651   4.628345   1.431355  airline#highlighter#exec()
 1200   0.989379   0.932396  131()
14596  11.660243   0.756705  <SNR>97_exec_separator()
   29  11.292424   0.619954  airline#highlighter#highlight()
    3              0.447943  coc#util#echo_messages()
29192   6.669625   0.440952  airline#themes#get_highlight()
15651              0.367430  <SNR>97_CheckDefined()
  381   2.571879   0.270766  299()
 1209   0.278022   0.265883  WebDevIconsGetFileTypeSymbol()
47279              0.263594  <SNR>97_get_array()
   58   0.236572   0.233515  gitgutter#async#execute()
15089              0.223112  <SNR>97_hl_group_exists()
  399   0.204543   0.199589  <SNR>82_Highlight_Matching_Pair()
 3045   0.416314   0.198990  38()
   45              0.163575  305()

